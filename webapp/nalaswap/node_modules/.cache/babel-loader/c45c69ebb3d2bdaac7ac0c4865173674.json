{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.replaceBackslashes = exports.isAbsolutePathSourceName = exports.normalizeSourceName = exports.localSourceNameToPath = exports.localPathToSourceName = exports.validateSourceNameExistenceAndCasing = exports.isLocalSourceName = exports.validateSourceNameFormat = void 0;\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst errors_1 = require(\"../internal/core/errors\");\n\nconst errors_list_1 = require(\"../internal/core/errors-list\");\n\nconst NODE_MODULES = \"node_modules\";\n/**\n * This function validates the source name's format.\n *\n * It throws if the format is invalid.\n * If it doesn't throw all you know is that the format is valid.\n */\n\nfunction validateSourceNameFormat(sourceName) {\n  if (isAbsolutePathSourceName(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_ABSOLUTE_PATH, {\n      name: sourceName\n    });\n  }\n\n  if (isExplicitRelativePath(sourceName)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_RELATIVE_PATH, {\n      name: sourceName\n    });\n  } // We check this before normalizing so we are sure that the difference\n  // comes from slash vs backslash\n\n\n  if (replaceBackslashes(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NAME_BACKSLASHES, {\n      name: sourceName\n    });\n  }\n\n  if (normalizeSourceName(sourceName) !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.INVALID_SOURCE_NOT_NORMALIZED, {\n      name: sourceName\n    });\n  }\n}\n\nexports.validateSourceNameFormat = validateSourceNameFormat;\n/**\n * This function returns true if the sourceName is, potentially, from a local\n * file. It doesn't validate that the file actually exists.\n *\n * The source name must be in a valid format.\n */\n\nasync function isLocalSourceName(projectRoot, sourceName) {\n  // Note that we consider \"hardhat/console.sol\" as a special case here.\n  // This lets someone have a \"hardhat\" directory within their project without\n  // it impacting their use of `console.log`.\n  // See issue https://github.com/nomiclabs/hardhat/issues/998\n  if (sourceName.includes(NODE_MODULES) || sourceName === \"hardhat/console.sol\") {\n    return false;\n  }\n\n  const slashIndex = sourceName.indexOf(\"/\");\n  const firstDirOrFileName = slashIndex !== -1 ? sourceName.substring(0, slashIndex) : sourceName;\n\n  try {\n    await getPathTrueCase(projectRoot, firstDirOrFileName);\n  } catch (error) {\n    if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n      return false;\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n\n  return true;\n}\n\nexports.isLocalSourceName = isLocalSourceName;\n/**\n * Validates that a source name exists, starting from `fromDir`, and has the\n * right casing.\n *\n * The source name must be in a valid format.\n */\n\nasync function validateSourceNameExistenceAndCasing(fromDir, sourceName) {\n  const trueCaseSourceName = await getPathTrueCase(fromDir, sourceName);\n\n  if (trueCaseSourceName !== sourceName) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING, {\n      incorrect: sourceName,\n      correct: trueCaseSourceName\n    });\n  }\n}\n\nexports.validateSourceNameExistenceAndCasing = validateSourceNameExistenceAndCasing;\n/**\n * Returns the source name of an existing local file's absolute path.\n *\n * Throws is the file doesn't exist, it's not inside the project, or belongs\n * to a library.\n */\n\nasync function localPathToSourceName(projectRoot, localFileAbsolutePath) {\n  const relativePath = path_1.default.relative(projectRoot, localFileAbsolutePath);\n  const normalized = normalizeSourceName(relativePath);\n\n  if (normalized.startsWith(\"..\")) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.EXTERNAL_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  if (normalized.includes(NODE_MODULES)) {\n    throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.NODE_MODULES_AS_LOCAL, {\n      path: localFileAbsolutePath\n    });\n  }\n\n  return getPathTrueCase(projectRoot, relativePath);\n}\n\nexports.localPathToSourceName = localPathToSourceName;\n/**\n * This function takes a valid local source name and returns its path. The\n * source name doesn't need to point to an existing file.\n */\n\nfunction localSourceNameToPath(projectRoot, sourceName) {\n  return path_1.default.join(projectRoot, sourceName);\n}\n\nexports.localSourceNameToPath = localSourceNameToPath;\n/**\n * Normalizes the source name, for example, by replacing `a/./b` with `a/b`.\n *\n * The sourceName param doesn't have to be a valid source name. It can,\n * for example, be denormalized.\n */\n\nfunction normalizeSourceName(sourceName) {\n  return replaceBackslashes(path_1.default.normalize(sourceName));\n}\n\nexports.normalizeSourceName = normalizeSourceName;\n/**\n * This function returns true if the sourceName is a unix absolute path or a\n * platform-dependent one.\n *\n * This function is used instead of just `path.isAbsolute` to ensure that\n * source names never start with `/`, even on Windows.\n */\n\nfunction isAbsolutePathSourceName(sourceName) {\n  return path_1.default.isAbsolute(sourceName) || sourceName.startsWith(\"/\");\n}\n\nexports.isAbsolutePathSourceName = isAbsolutePathSourceName;\n/**\n * This function returns true if the sourceName is a unix path that is based on\n * the current directory `./`.\n */\n\nfunction isExplicitRelativePath(sourceName) {\n  const [base] = sourceName.split(\"/\", 1);\n  return base === \".\" || base === \"..\";\n}\n/**\n * This function replaces backslashes (\\\\) with slashes (/).\n *\n * Note that a source name must not contain backslashes.\n */\n\n\nfunction replaceBackslashes(str) {\n  const slash = require(\"slash\");\n\n  return slash(str);\n}\n\nexports.replaceBackslashes = replaceBackslashes;\n/**\n * Returns the true casing of `p` as a relative path from `fromDir`. Throws if\n * `p` doesn't exist. `p` MUST be in source name format.\n */\n\nasync function getPathTrueCase(fromDir, p) {\n  const {\n    trueCasePath\n  } = await Promise.resolve().then(() => __importStar(require(\"true-case-path\")));\n\n  try {\n    const tcp = await trueCasePath(p, fromDir);\n    return normalizeSourceName(path_1.default.relative(fromDir, tcp));\n  } catch (error) {\n    if (error instanceof Error) {\n      if (typeof error.message === \"string\" && error.message.includes(\"no matching file exists\")) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND, {\n          name: p\n        }, error);\n      }\n    } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n    throw error;\n  }\n}","map":{"version":3,"mappings":"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","names":["NODE_MODULES","validateSourceNameFormat","sourceName","isAbsolutePathSourceName","errors_1","errors_list_1","SOURCE_NAMES","INVALID_SOURCE_NAME_ABSOLUTE_PATH","name","isExplicitRelativePath","INVALID_SOURCE_NAME_RELATIVE_PATH","replaceBackslashes","INVALID_SOURCE_NAME_BACKSLASHES","normalizeSourceName","INVALID_SOURCE_NOT_NORMALIZED","exports","isLocalSourceName","projectRoot","includes","slashIndex","indexOf","firstDirOrFileName","substring","getPathTrueCase","error","isHardhatErrorType","FILE_NOT_FOUND","validateSourceNameExistenceAndCasing","fromDir","trueCaseSourceName","WRONG_CASING","incorrect","correct","localPathToSourceName","localFileAbsolutePath","relativePath","path_1","relative","normalized","startsWith","EXTERNAL_AS_LOCAL","path","NODE_MODULES_AS_LOCAL","localSourceNameToPath","join","normalize","isAbsolute","base","split","str","slash","require","p","trueCasePath","tcp","Error","message"],"sourceRoot":"","sources":["../src/utils/source-names.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}