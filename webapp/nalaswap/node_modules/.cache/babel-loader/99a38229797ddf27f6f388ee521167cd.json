{"ast":null,"code":"'use strict';\n/* global WebAssembly */\n\nconst assert = require('assert');\n\nconst net = require('net');\n\nconst util = require('./core/util');\n\nconst Request = require('./core/request');\n\nconst Dispatcher = require('./dispatcher');\n\nconst RedirectHandler = require('./handler/redirect');\n\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  ClientDestroyedError,\n  ClientClosedError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors');\n\nconst buildConnector = require('./core/connect');\n\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kClosed,\n  kDestroyed,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kOnDestroyed,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter\n} = require('./core/symbols');\n\nconst channels = {};\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel');\n\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError');\n  channels.connected = diagnosticsChannel.channel('undici:client:connected');\n} catch {\n  channels.sendHeaders = {\n    hasSubscribers: false\n  };\n  channels.beforeConnect = {\n    hasSubscribers: false\n  };\n  channels.connectError = {\n    hasSubscribers: false\n  };\n  channels.connected = {\n    hasSubscribers: false\n  };\n}\n\nclass Client extends Dispatcher {\n  constructor(url) {\n    let {\n      maxHeaderSize,\n      headersTimeout,\n      socketTimeout,\n      requestTimeout,\n      connectTimeout,\n      bodyTimeout,\n      idleTimeout,\n      keepAlive,\n      keepAliveTimeout,\n      maxKeepAliveTimeout,\n      keepAliveMaxTimeout,\n      keepAliveTimeoutThreshold,\n      socketPath,\n      pipelining,\n      tls,\n      strictContentLength,\n      maxCachedSessions,\n      maxRedirections,\n      connect,\n      maxRequestsPerClient\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead');\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead');\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead');\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead');\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead');\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize');\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath');\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout');\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout');\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout');\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold');\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero');\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number');\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({ ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      });\n    }\n\n    this[kUrl] = util.parseOrigin(url);\n    this[kConnector] = connect;\n    this[kSocket] = null;\n    this[kPipelining] = pipelining != null ? pipelining : 1;\n    this[kMaxHeadersSize] = maxHeaderSize || 16384;\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout;\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];\n    this[kClosed] = false;\n    this[kDestroyed] = false;\n    this[kServerName] = null;\n    this[kOnDestroyed] = [];\n    this[kResuming] = 0; // 0, idle, 1, scheduled, 2 resuming\n\n    this[kNeedDrain] = 0; // 0, idle, 1, scheduled, 2 resuming\n\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`;\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3;\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3;\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;\n    this[kMaxRedirections] = maxRedirections;\n    this[kMaxRequests] = maxRequestsPerClient; // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = [];\n    this[kRunningIdx] = 0;\n    this[kPendingIdx] = 0;\n  } // TODO: Make private?\n\n\n  get pipelining() {\n    return this[kPipelining];\n  } // TODO: Make private?\n\n\n  set pipelining(value) {\n    this[kPipelining] = value;\n    resume(this, true);\n  }\n\n  get destroyed() {\n    return this[kDestroyed];\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get [kPending]() {\n    return this[kQueue].length - this[kPendingIdx];\n  }\n\n  get [kRunning]() {\n    return this[kPendingIdx] - this[kRunningIdx];\n  }\n\n  get [kSize]() {\n    return this[kQueue].length - this[kRunningIdx];\n  }\n\n  get [kConnected]() {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;\n  }\n\n  get [kBusy]() {\n    const socket = this[kSocket];\n    return socket && (socket[kReset] || socket[kWriting] || socket[kBlocking]) || this[kSize] >= (this[kPipelining] || 1) || this[kPending] > 0;\n  }\n  /* istanbul ignore: only used for test */\n\n\n  [kConnect](cb) {\n    connect(this);\n    this.once('connect', cb);\n  }\n\n  dispatch(opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object');\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.');\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError();\n      }\n\n      const {\n        maxRedirections = this[kMaxRedirections]\n      } = opts;\n\n      if (maxRedirections) {\n        handler = new RedirectHandler(this, maxRedirections, opts, handler);\n      }\n\n      const origin = opts.origin || this[kUrl].origin;\n      const request = new Request(origin, opts, handler);\n      this[kQueue].push(request);\n\n      if (this[kResuming]) {// Do nothing.\n      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n        // Wait a tick in case stream/iterator is ended in the same tick.\n        this[kResuming] = 1;\n        process.nextTick(resume, this);\n      } else {\n        resume(this, true);\n      }\n\n      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n        this[kNeedDrain] = 2;\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n      }\n\n      handler.onError(err);\n    }\n\n    return this[kNeedDrain] < 2;\n  }\n\n  close(callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data);\n        });\n      });\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback');\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null));\n      return;\n    }\n\n    this[kClosed] = true;\n\n    if (!this[kSize]) {\n      this.destroy(callback);\n    } else {\n      this[kOnDestroyed].push(callback);\n    }\n  }\n\n  destroy(err, callback) {\n    if (typeof err === 'function') {\n      callback = err;\n      err = null;\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ?\n          /* istanbul ignore next: should never error */\n          reject(err) : resolve(data);\n        });\n      });\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback');\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback);\n      } else {\n        queueMicrotask(() => callback(null, null));\n      }\n\n      return;\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError();\n    }\n\n    const requests = this[kQueue].splice(this[kPendingIdx]);\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(this, request, err);\n    }\n\n    this[kClosed] = true;\n    this[kDestroyed] = true;\n    this[kOnDestroyed].push(callback);\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed];\n      this[kOnDestroyed] = null;\n\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null);\n      }\n    };\n\n    if (!this[kSocket]) {\n      queueMicrotask(onDestroyed);\n    } else {\n      util.destroy(this[kSocket].on('close', onDestroyed), err);\n    }\n\n    resume(this);\n  }\n\n}\n\nconst constants = require('./llhttp/constants');\n\nconst EMPTY_BUF = Buffer.alloc(0);\n\nasync function lazyllhttp() {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined;\n  let mod;\n\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));\n  } catch (e) {\n    /* istanbul ignore next */\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'));\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0;\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_begin: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageBegin() || 0;\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0;\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p);\n        const start = at - currentBufferPtr;\n        const end = start + len;\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;\n      },\n      wasm_on_message_complete: p => {\n        assert.strictEqual(currentParser.ptr, p);\n        return currentParser.onMessageComplete() || 0;\n      }\n      /* eslint-enable camelcase */\n\n    }\n  });\n}\n\nlet llhttpInstance = null;\nlet llhttpPromise = lazyllhttp().catch(() => {// TODO: Emit warning?\n});\nlet currentParser = null;\nlet currentBufferRef = null;\nlet currentBufferSize = 0;\nlet currentBufferPtr = null;\nconst TIMEOUT_HEADERS = 1;\nconst TIMEOUT_BODY = 2;\nconst TIMEOUT_IDLE = 3;\n\nclass Parser {\n  constructor(client, socket, _ref) {\n    let {\n      exports\n    } = _ref;\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0);\n    this.llhttp = exports;\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);\n    this.client = client;\n    this.socket = socket;\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.statusCode = null;\n    this.statusText = '';\n    this.upgrade = false;\n    this.headers = [];\n    this.headersSize = 0;\n    this.headersMaxSize = client[kMaxHeadersSize];\n    this.shouldKeepAlive = false;\n    this.paused = false;\n    this.resume = this.resume.bind(this);\n    this.bytesRead = 0;\n    this.trailer = '';\n    this.keepAlive = '';\n    this.contentLength = '';\n  }\n\n  setTimeout(value, type) {\n    this.timeoutType = type;\n\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout);\n\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this); // istanbul ignore else: only for jest\n\n        if (this.timeout.unref) {\n          this.timeout.unref();\n        }\n      } else {\n        this.timeout = null;\n      }\n\n      this.timeoutValue = value;\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n  }\n\n  resume() {\n    if (this.socket.destroyed || !this.paused) {\n      return;\n    }\n\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_resume(this.ptr);\n    assert(this.timeoutType === TIMEOUT_BODY);\n\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    this.paused = false;\n    this.execute(this.socket.read() || EMPTY_BUF); // Flush parser.\n\n    this.readMore();\n  }\n\n  readMore() {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read();\n\n      if (chunk === null) {\n        break;\n      }\n\n      this.execute(chunk);\n    }\n  }\n\n  execute(data) {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    assert(!this.paused);\n    const {\n      socket,\n      llhttp\n    } = this;\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr);\n      }\n\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096;\n      currentBufferPtr = llhttp.malloc(currentBufferSize);\n    } // TODO (perf): Can we avoid this copy somehow?\n\n\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data); // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n\n    try {\n      let ret;\n\n      try {\n        currentBufferRef = data;\n        currentParser = this;\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length);\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err;\n      } finally {\n        currentParser = null;\n        currentBufferRef = null;\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset));\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true;\n        socket.unshift(data.slice(offset));\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr);\n        let message = '';\n        /* istanbul ignore else: difficult to make a test case for */\n\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();\n        }\n\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset));\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n  }\n\n  finish() {\n    try {\n      try {\n        currentParser = this;\n        this.llhttp.llhttp_finish(this.ptr); // TODO (fix): Check ret?\n      } finally {\n        currentParser = null;\n      }\n    } catch (err) {\n      // TODO (fix): What if socket is already destroyed? Error will be swallowed.\n\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err);\n    }\n  }\n\n  destroy() {\n    assert(this.ptr != null);\n    assert(currentParser == null);\n    this.llhttp.llhttp_free(this.ptr);\n    this.ptr = null;\n    clearTimeout(this.timeout);\n    this.timeout = null;\n    this.timeoutValue = null;\n    this.timeoutType = null;\n    this.paused = false;\n  }\n\n  onStatus(buf) {\n    this.statusText = buf.toString();\n  }\n\n  onMessageBegin() {\n    const {\n      socket,\n      client\n    } = this;\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n\n    if (!request) {\n      return -1;\n    }\n  }\n\n  onHeaderField(buf) {\n    const len = this.headers.length;\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf);\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n\n    this.trackHeader(buf.length);\n  }\n\n  onHeaderValue(buf) {\n    let len = this.headers.length;\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf);\n      len += 1;\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);\n    }\n\n    const key = this.headers[len - 2];\n\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString();\n    } else if (key.length === 7 && key.toString().toLowerCase() === 'trailer') {\n      this.trailer += buf.toString();\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString();\n    }\n\n    this.trackHeader(buf.length);\n  }\n\n  trackHeader(len) {\n    this.headersSize += len;\n\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError());\n    }\n  }\n\n  onUpgrade(head) {\n    const {\n      upgrade,\n      client,\n      socket,\n      headers,\n      statusCode\n    } = this;\n    assert(upgrade);\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(!socket.destroyed);\n    assert(socket === client[kSocket]);\n    assert(!this.paused);\n    assert(request.upgrade || request.method === 'CONNECT');\n    this.statusCode = null;\n    this.statusText = '';\n    this.shouldKeepAlive = null;\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n    socket.unshift(head);\n    socket[kParser].destroy();\n    socket[kParser] = null;\n    socket[kClient] = null;\n    socket[kError] = null;\n    socket.removeListener('error', onSocketError).removeListener('readable', onSocketReadable).removeListener('end', onSocketEnd).removeListener('close', onSocketClose);\n    client[kSocket] = null;\n    client[kQueue][client[kRunningIdx]++] = null;\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'));\n\n    try {\n      request.onUpgrade(statusCode, headers, socket);\n    } catch (err) {\n      util.destroy(socket, err);\n    }\n\n    resume(client);\n  }\n\n  onHeadersComplete(statusCode, upgrade, shouldKeepAlive) {\n    const {\n      client,\n      socket,\n      headers,\n      statusText\n    } = this;\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    /* istanbul ignore next: difficult to make a test case for */\n\n    if (!request) {\n      return -1;\n    } // TODO: Check for content-length mismatch from server?\n\n\n    assert(!this.upgrade);\n    assert(this.statusCode < 200); // TODO: More statusCode validation?\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)));\n      return -1;\n    }\n    /* this can only happen if server is misbehaving */\n\n\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)));\n      return -1;\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS);\n    this.statusCode = statusCode;\n    this.shouldKeepAlive = shouldKeepAlive;\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null ? request.bodyTimeout : client[kBodyTimeout];\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY);\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    if (request.method === 'CONNECT' && statusCode >= 200 && statusCode < 300) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1);\n      this.upgrade = true;\n      return 2;\n    }\n\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null;\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(keepAliveTimeout - client[kKeepAliveTimeoutThreshold], client[kKeepAliveMaxTimeout]);\n\n        if (timeout <= 0) {\n          socket[kReset] = true;\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout;\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout];\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true;\n    }\n\n    let pause;\n\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false;\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset]);\n      return 1;\n    }\n\n    if (statusCode < 200) {\n      return 1;\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false;\n      resume(client);\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0;\n  }\n\n  onBody(buf) {\n    const {\n      client,\n      socket,\n      statusCode\n    } = this;\n\n    if (socket.destroyed) {\n      return -1;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY);\n\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh();\n      }\n    }\n\n    assert(statusCode >= 200);\n    this.bytesRead += buf.length;\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED;\n      }\n    } catch (err) {\n      util.destroy(socket, err);\n      return -1;\n    }\n  }\n\n  onMessageComplete() {\n    const {\n      client,\n      socket,\n      statusCode,\n      upgrade,\n      trailer,\n      headers,\n      contentLength,\n      bytesRead,\n      shouldKeepAlive\n    } = this;\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1;\n    }\n\n    if (upgrade) {\n      return;\n    }\n\n    const request = client[kQueue][client[kRunningIdx]];\n    assert(request);\n    assert(statusCode >= 100);\n    this.statusCode = null;\n    this.statusText = '';\n    this.bytesRead = 0;\n    this.contentLength = '';\n    this.trailer = '';\n    this.keepAlive = '';\n    assert(this.headers.length % 2 === 0);\n    this.headers = [];\n    this.headersSize = 0;\n\n    if (statusCode < 200) {\n      return;\n    }\n\n    const trailers = trailer ? trailer.split(/,\\s*/) : [];\n\n    for (let i = 0; i < trailers.length; i++) {\n      const trailer = trailers[i];\n      let found = false;\n\n      for (let n = 0; n < headers.length; n += 2) {\n        const key = headers[n];\n\n        if (key.length === trailer.length && key.toString().toLowerCase() === trailer.toLowerCase()) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        util.destroy(socket, new TrailerMismatchError());\n        return -1;\n      }\n    }\n    /* istanbul ignore next: should be handled by llhttp? */\n\n\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError());\n      return -1;\n    }\n\n    try {\n      request.onComplete(headers);\n    } catch (err) {\n      errorRequest(client, request, err);\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null;\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0); // Response completed before request.\n\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (!shouldKeepAlive) {\n      // TODO: What if running > 0?\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'));\n      return constants.ERROR.PAUSED;\n    } else {\n      resume(client);\n    }\n  }\n\n}\n\nfunction onParserTimeout(parser) {\n  const {\n    socket,\n    timeoutType,\n    client\n  } = parser;\n  /* istanbul ignore else */\n\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting]) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers');\n      util.destroy(socket, new HeadersTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError());\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue]);\n    util.destroy(socket, new InformationalError('socket idle timeout'));\n  }\n}\n\nfunction onSocketReadable() {\n  const {\n    [kParser]: parser\n  } = this;\n  parser.readMore();\n}\n\nfunction onSocketError(err) {\n  const {\n    [kParser]: parser\n  } = this;\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID'); // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish();\n    return;\n  }\n\n  this[kError] = err;\n  onError(this[kClient], err);\n}\n\nfunction onError(client, err) {\n  if (client[kRunning] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n    assert(client[kPendingIdx] === client[kRunningIdx]);\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n\n    assert(client[kSize] === 0);\n  }\n}\n\nfunction onSocketEnd() {\n  const {\n    [kParser]: parser\n  } = this;\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish();\n    return;\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)));\n}\n\nfunction onSocketClose() {\n  const {\n    [kClient]: client\n  } = this;\n  this[kParser].destroy();\n  this[kParser] = null;\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this));\n  client[kSocket] = null;\n\n  if (client[kDestroyed]) {\n    assert(client[kPending] === 0); // Fail entire queue.\n\n    const requests = client[kQueue].splice(client[kRunningIdx]);\n\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i];\n      errorRequest(client, request, err);\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]];\n    client[kQueue][client[kRunningIdx]++] = null;\n    errorRequest(client, request, err);\n  }\n\n  client[kPendingIdx] = client[kRunningIdx];\n  assert(client[kRunning] === 0);\n  client.emit('disconnect', client[kUrl], [client], err);\n  resume(client);\n}\n\nasync function connect(client) {\n  assert(!client[kConnecting]);\n  assert(!client[kSocket]);\n  let {\n    host,\n    hostname,\n    protocol,\n    port\n  } = client[kUrl]; // Resolve ipv6\n\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']');\n    assert(idx !== -1);\n    const ip = hostname.substr(1, idx - 1);\n    assert(net.isIP(ip));\n    hostname = ip;\n  }\n\n  client[kConnecting] = true;\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    });\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(socket);\n        }\n      });\n    });\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise;\n      llhttpPromise = null;\n    }\n\n    client[kConnecting] = false;\n    assert(socket);\n    client[kSocket] = socket;\n    socket[kNoRef] = false;\n    socket[kWriting] = false;\n    socket[kReset] = false;\n    socket[kBlocking] = false;\n    socket[kError] = null;\n    socket[kParser] = new Parser(client, socket, llhttpInstance);\n    socket[kClient] = client;\n    socket[kCounter] = 0;\n    socket[kMaxRequests] = client[kMaxRequests];\n    socket.on('error', onSocketError).on('readable', onSocketReadable).on('end', onSocketEnd).on('close', onSocketClose);\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      });\n    }\n\n    client.emit('connect', client[kUrl], [client]);\n  } catch (err) {\n    client[kConnecting] = false;\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      });\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0);\n\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++];\n        errorRequest(client, request, err);\n      }\n    } else {\n      onError(client, err);\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err);\n  }\n\n  resume(client);\n}\n\nfunction emitDrain(client) {\n  client[kNeedDrain] = 0;\n  client.emit('drain', client[kUrl], [client]);\n}\n\nfunction resume(client, sync) {\n  if (client[kResuming] === 2) {\n    return;\n  }\n\n  client[kResuming] = 2;\n\n  _resume(client, sync);\n\n  client[kResuming] = 0;\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx]);\n    client[kPendingIdx] -= client[kRunningIdx];\n    client[kRunningIdx] = 0;\n  }\n}\n\nfunction _resume(client, sync) {\n  while (true) {\n    if (client[kDestroyed]) {\n      assert(client[kPending] === 0);\n      return;\n    }\n\n    if (client[kClosed] && !client[kSize]) {\n      client.destroy(util.nop);\n      continue;\n    }\n\n    const socket = client[kSocket];\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref();\n          socket[kNoRef] = true;\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref();\n        socket[kNoRef] = false;\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE);\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]];\n          const headersTimeout = request.headersTimeout != null ? request.headersTimeout : client[kHeadersTimeout];\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2;\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1;\n        process.nextTick(emitDrain, client);\n      } else {\n        emitDrain(client);\n      }\n\n      continue;\n    }\n\n    if (client[kPending] === 0) {\n      return;\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return;\n    }\n\n    const request = client[kQueue][client[kPendingIdx]];\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return;\n      }\n\n      client[kServerName] = request.servername;\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'));\n        return;\n      }\n    }\n\n    if (client[kConnecting]) {\n      return;\n    }\n\n    if (!socket) {\n      connect(client);\n      continue;\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return;\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return;\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body.on('data',\n      /* istanbul ignore next */\n      function () {\n        /* istanbul ignore next */\n        assert(false);\n      }).on('error', function (err) {\n        errorRequest(client, request, err);\n      }).on('end', function () {\n        util.destroy(this);\n      });\n      request.body = null;\n    }\n\n    if (client[kRunning] > 0 && (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return;\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++;\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1);\n    }\n  }\n}\n\nfunction write(client, request) {\n  const {\n    body,\n    method,\n    path,\n    host,\n    upgrade,\n    headers,\n    blocking\n  } = request; // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0);\n  }\n\n  let contentLength = util.bodyLength(body);\n\n  if (contentLength === null) {\n    contentLength = request.contentLength;\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n    contentLength = null;\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError());\n      return false;\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError());\n  }\n\n  const socket = client[kSocket];\n\n  try {\n    request.onConnect(err => {\n      if (request.aborted || request.completed) {\n        return;\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError());\n      util.destroy(socket, new InformationalError('aborted'));\n    });\n  } catch (err) {\n    errorRequest(client, request, err);\n  }\n\n  if (request.aborted) {\n    return false;\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n    socket[kReset] = true;\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n    socket[kReset] = true;\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true;\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true;\n  } // TODO: Expect: 100-continue\n\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`;\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`;\n  } else {\n    header += client[kHostHeader];\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`;\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n';\n  } else {\n    header += 'connection: close\\r\\n';\n  }\n\n  if (headers) {\n    header += headers;\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({\n      request,\n      headers: header,\n      socket\n    });\n  }\n  /* istanbul ignore else: assertion */\n\n\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n    } else {\n      assert(contentLength === null, 'no body must not have content length');\n      socket.write(`${header}\\r\\n`, 'ascii');\n    }\n\n    request.onRequestSent();\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length');\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(body);\n    socket.uncork();\n    request.onBodySent(body);\n    request.onRequestSent();\n\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({\n        body: body.stream(),\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    } else {\n      writeBlob({\n        body,\n        client,\n        request,\n        socket,\n        contentLength,\n        header,\n        expectsPayload\n      });\n    }\n  } else if (util.isStream(body)) {\n    writeStream({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else if (util.isIterable(body)) {\n    writeIterable({\n      body,\n      client,\n      request,\n      socket,\n      contentLength,\n      header,\n      expectsPayload\n    });\n  } else {\n    assert(false);\n  }\n\n  return true;\n}\n\nfunction writeStream(_ref2) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref2;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined');\n  let finished = false;\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished);\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause();\n      }\n    } catch (err) {\n      util.destroy(this, err);\n    }\n  };\n\n  const onDrain = function () {\n    assert(!finished);\n\n    if (body.resume) {\n      body.resume();\n    }\n  };\n\n  const onAbort = function () {\n    onFinished(new RequestAbortedError());\n  };\n\n  const onFinished = function (err) {\n    if (finished) {\n      return;\n    }\n\n    finished = true;\n    assert(socket.destroyed || socket[kWriting] && client[kRunning] <= 1);\n    socket.off('drain', onDrain).off('error', onFinished);\n    body.removeListener('data', onData).removeListener('end', onFinished).removeListener('error', onFinished).removeListener('close', onAbort);\n\n    if (!err) {\n      try {\n        writer.end();\n      } catch (er) {\n        err = er;\n      }\n    }\n\n    writer.destroy(err); // TODO (fix): Avoid using err.message for logic.\n\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err);\n    } else {\n      util.destroy(body);\n    }\n  };\n\n  body.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);\n\n  if (body.resume) {\n    body.resume();\n  }\n\n  socket.on('drain', onDrain).on('error', onFinished);\n}\n\nasync function writeBlob(_ref3) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref3;\n  assert(contentLength === body.size, 'blob body must have content length');\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError();\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer());\n    socket.cork();\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n    socket.write(buffer);\n    socket.uncork();\n    request.onBodySent(buffer);\n    request.onRequestSent();\n\n    if (!expectsPayload) {\n      socket[kReset] = true;\n    }\n\n    resume(client);\n  } catch (err) {\n    util.destroy(socket, err);\n  }\n}\n\nasync function writeIterable(_ref4) {\n  let {\n    body,\n    client,\n    request,\n    socket,\n    contentLength,\n    header,\n    expectsPayload\n  } = _ref4;\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined');\n  let callback = null;\n\n  function onDrain() {\n    if (callback) {\n      const cb = callback;\n      callback = null;\n      cb();\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null);\n\n    if (socket[kError]) {\n      reject(socket[kError]);\n    } else {\n      callback = resolve;\n    }\n  });\n\n  socket.on('close', onDrain).on('drain', onDrain);\n  const writer = new AsyncWriter({\n    socket,\n    request,\n    contentLength,\n    client,\n    expectsPayload,\n    header\n  });\n\n  try {\n    // TODO (fix): What if socket errors while waiting for body?\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError];\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain();\n      }\n    }\n\n    writer.end();\n  } catch (err) {\n    writer.destroy(err);\n  } finally {\n    socket.off('close', onDrain).off('drain', onDrain);\n  }\n}\n\nclass AsyncWriter {\n  constructor(_ref5) {\n    let {\n      socket,\n      request,\n      contentLength,\n      client,\n      expectsPayload,\n      header\n    } = _ref5;\n    this.socket = socket;\n    this.request = request;\n    this.contentLength = contentLength;\n    this.client = client;\n    this.bytesWritten = 0;\n    this.expectsPayload = expectsPayload;\n    this.header = header;\n    socket[kWriting] = true;\n  }\n\n  write(chunk) {\n    const {\n      socket,\n      request,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header\n    } = this;\n\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n\n    if (socket.destroyed) {\n      return false;\n    }\n\n    const len = Buffer.byteLength(chunk);\n\n    if (!len) {\n      return true;\n    } // TODO: What if not ended and bytesWritten === contentLength?\n    // We should defer writing chunks.\n\n\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError());\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true;\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii');\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii');\n    }\n\n    this.bytesWritten += len;\n    const ret = socket.write(chunk);\n    request.onBodySent(chunk);\n    return ret;\n  }\n\n  end() {\n    const {\n      socket,\n      contentLength,\n      client,\n      bytesWritten,\n      expectsPayload,\n      header,\n      request\n    } = this;\n    request.onRequestSent();\n    socket[kWriting] = false;\n\n    if (socket[kError]) {\n      throw socket[kError];\n    }\n\n    if (socket.destroyed) {\n      return;\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii');\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii');\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii');\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError();\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError());\n      }\n    } // TODO (fix): Add comment clarifying what this does?\n\n\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh();\n      }\n    }\n\n    resume(client);\n  }\n\n  destroy(err) {\n    const {\n      socket,\n      client\n    } = this;\n    socket[kWriting] = false;\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request');\n      util.destroy(socket, err);\n    }\n  }\n\n}\n\nfunction errorRequest(client, request, err) {\n  try {\n    request.onError(err);\n    assert(request.aborted);\n  } catch (err) {\n    client.emit('error', err);\n  }\n}\n\nmodule.exports = Client;","map":{"version":3,"names":["assert","require","net","util","Request","Dispatcher","RedirectHandler","RequestContentLengthMismatchError","ResponseContentLengthMismatchError","TrailerMismatchError","InvalidArgumentError","RequestAbortedError","HeadersTimeoutError","HeadersOverflowError","ClientDestroyedError","ClientClosedError","SocketError","InformationalError","BodyTimeoutError","HTTPParserError","buildConnector","kUrl","kReset","kServerName","kClient","kBusy","kParser","kConnect","kBlocking","kResuming","kRunning","kPending","kSize","kWriting","kQueue","kConnected","kConnecting","kNeedDrain","kNoRef","kKeepAliveDefaultTimeout","kHostHeader","kClosed","kDestroyed","kPendingIdx","kRunningIdx","kError","kOnDestroyed","kPipelining","kSocket","kKeepAliveTimeoutValue","kMaxHeadersSize","kKeepAliveMaxTimeout","kKeepAliveTimeoutThreshold","kHeadersTimeout","kBodyTimeout","kStrictContentLength","kConnector","kMaxRedirections","kMaxRequests","kCounter","channels","diagnosticsChannel","sendHeaders","channel","beforeConnect","connectError","connected","hasSubscribers","Client","constructor","url","maxHeaderSize","headersTimeout","socketTimeout","requestTimeout","connectTimeout","bodyTimeout","idleTimeout","keepAlive","keepAliveTimeout","maxKeepAliveTimeout","keepAliveMaxTimeout","keepAliveTimeoutThreshold","socketPath","pipelining","tls","strictContentLength","maxCachedSessions","maxRedirections","connect","maxRequestsPerClient","undefined","Number","isFinite","isInteger","timeout","parseOrigin","hostname","port","value","resume","destroyed","closed","length","socket","cb","once","dispatch","opts","handler","origin","request","push","bodyLength","body","isIterable","process","nextTick","err","onError","close","callback","Promise","resolve","reject","data","queueMicrotask","destroy","requests","splice","i","errorRequest","onDestroyed","callbacks","on","constants","EMPTY_BUF","Buffer","alloc","lazyllhttp","llhttpWasmData","env","JEST_WORKER_ID","mod","WebAssembly","compile","from","e","instantiate","wasm_on_url","p","at","len","wasm_on_status","strictEqual","currentParser","ptr","start","currentBufferPtr","end","onStatus","currentBufferRef","slice","wasm_on_message_begin","onMessageBegin","wasm_on_header_field","onHeaderField","wasm_on_header_value","onHeaderValue","wasm_on_headers_complete","statusCode","upgrade","shouldKeepAlive","onHeadersComplete","Boolean","wasm_on_body","onBody","wasm_on_message_complete","onMessageComplete","llhttpInstance","llhttpPromise","catch","currentBufferSize","TIMEOUT_HEADERS","TIMEOUT_BODY","TIMEOUT_IDLE","Parser","client","exports","llhttp","llhttp_alloc","TYPE","RESPONSE","timeoutValue","timeoutType","statusText","headers","headersSize","headersMaxSize","paused","bind","bytesRead","trailer","contentLength","setTimeout","type","clearTimeout","onParserTimeout","unref","refresh","llhttp_resume","execute","read","readMore","chunk","free","Math","ceil","malloc","Uint8Array","memory","buffer","set","ret","llhttp_execute","offset","llhttp_get_error_pos","ERROR","PAUSED_UPGRADE","onUpgrade","PAUSED","unshift","OK","llhttp_get_error_reason","message","indexOf","toString","finish","llhttp_finish","llhttp_free","buf","concat","trackHeader","key","toLowerCase","head","method","removeListener","onSocketError","onSocketReadable","onSocketEnd","onSocketClose","emit","getSocketInfo","parseKeepAliveTimeout","min","pause","onHeaders","onData","trailers","split","found","n","parseInt","onComplete","parser","code","host","protocol","idx","ip","substr","isIP","publish","connectParams","servername","connector","error","emitDrain","sync","_resume","nop","ref","idempotent","isStream","isAsyncIterable","aborted","write","path","blocking","expectsPayload","emitWarning","onConnect","completed","header","onRequestSent","isBuffer","byteLength","cork","uncork","onBodySent","isBlobLike","stream","writeIterable","writeBlob","writeStream","finished","writer","AsyncWriter","onDrain","onAbort","onFinished","off","er","size","arrayBuffer","waitForDrain","bytesWritten","module"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/client.js"],"sourcesContent":["'use strict'\n\n/* global WebAssembly */\n\nconst assert = require('assert')\nconst net = require('net')\nconst util = require('./core/util')\nconst Request = require('./core/request')\nconst Dispatcher = require('./dispatcher')\nconst RedirectHandler = require('./handler/redirect')\nconst {\n  RequestContentLengthMismatchError,\n  ResponseContentLengthMismatchError,\n  TrailerMismatchError,\n  InvalidArgumentError,\n  RequestAbortedError,\n  HeadersTimeoutError,\n  HeadersOverflowError,\n  ClientDestroyedError,\n  ClientClosedError,\n  SocketError,\n  InformationalError,\n  BodyTimeoutError,\n  HTTPParserError\n} = require('./core/errors')\nconst buildConnector = require('./core/connect')\nconst {\n  kUrl,\n  kReset,\n  kServerName,\n  kClient,\n  kBusy,\n  kParser,\n  kConnect,\n  kBlocking,\n  kResuming,\n  kRunning,\n  kPending,\n  kSize,\n  kWriting,\n  kQueue,\n  kConnected,\n  kConnecting,\n  kNeedDrain,\n  kNoRef,\n  kKeepAliveDefaultTimeout,\n  kHostHeader,\n  kClosed,\n  kDestroyed,\n  kPendingIdx,\n  kRunningIdx,\n  kError,\n  kOnDestroyed,\n  kPipelining,\n  kSocket,\n  kKeepAliveTimeoutValue,\n  kMaxHeadersSize,\n  kKeepAliveMaxTimeout,\n  kKeepAliveTimeoutThreshold,\n  kHeadersTimeout,\n  kBodyTimeout,\n  kStrictContentLength,\n  kConnector,\n  kMaxRedirections,\n  kMaxRequests,\n  kCounter\n} = require('./core/symbols')\n\nconst channels = {}\n\ntry {\n  const diagnosticsChannel = require('diagnostics_channel')\n  channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders')\n  channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect')\n  channels.connectError = diagnosticsChannel.channel('undici:client:connectError')\n  channels.connected = diagnosticsChannel.channel('undici:client:connected')\n} catch {\n  channels.sendHeaders = { hasSubscribers: false }\n  channels.beforeConnect = { hasSubscribers: false }\n  channels.connectError = { hasSubscribers: false }\n  channels.connected = { hasSubscribers: false }\n}\n\nclass Client extends Dispatcher {\n  constructor (url, {\n    maxHeaderSize,\n    headersTimeout,\n    socketTimeout,\n    requestTimeout,\n    connectTimeout,\n    bodyTimeout,\n    idleTimeout,\n    keepAlive,\n    keepAliveTimeout,\n    maxKeepAliveTimeout,\n    keepAliveMaxTimeout,\n    keepAliveTimeoutThreshold,\n    socketPath,\n    pipelining,\n    tls,\n    strictContentLength,\n    maxCachedSessions,\n    maxRedirections,\n    connect,\n    maxRequestsPerClient\n  } = {}) {\n    super()\n\n    if (keepAlive !== undefined) {\n      throw new InvalidArgumentError('unsupported keepAlive, use pipelining=0 instead')\n    }\n\n    if (socketTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported socketTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (requestTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported requestTimeout, use headersTimeout & bodyTimeout instead')\n    }\n\n    if (idleTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported idleTimeout, use keepAliveTimeout instead')\n    }\n\n    if (maxKeepAliveTimeout !== undefined) {\n      throw new InvalidArgumentError('unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead')\n    }\n\n    if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {\n      throw new InvalidArgumentError('invalid maxHeaderSize')\n    }\n\n    if (socketPath != null && typeof socketPath !== 'string') {\n      throw new InvalidArgumentError('invalid socketPath')\n    }\n\n    if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {\n      throw new InvalidArgumentError('invalid connectTimeout')\n    }\n\n    if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeout')\n    }\n\n    if (keepAliveMaxTimeout != null && (!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)) {\n      throw new InvalidArgumentError('invalid keepAliveMaxTimeout')\n    }\n\n    if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {\n      throw new InvalidArgumentError('invalid keepAliveTimeoutThreshold')\n    }\n\n    if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {\n      throw new InvalidArgumentError('headersTimeout must be a positive integer or zero')\n    }\n\n    if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {\n      throw new InvalidArgumentError('bodyTimeout must be a positive integer or zero')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (maxRequestsPerClient != null && (!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)) {\n      throw new InvalidArgumentError('maxRequestsPerClient must be a positive number')\n    }\n\n    if (typeof connect !== 'function') {\n      connect = buildConnector({\n        ...tls,\n        maxCachedSessions,\n        socketPath,\n        timeout: connectTimeout,\n        ...connect\n      })\n    }\n\n    this[kUrl] = util.parseOrigin(url)\n    this[kConnector] = connect\n    this[kSocket] = null\n    this[kPipelining] = pipelining != null ? pipelining : 1\n    this[kMaxHeadersSize] = maxHeaderSize || 16384\n    this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout\n    this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 600e3 : keepAliveMaxTimeout\n    this[kKeepAliveTimeoutThreshold] = keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold\n    this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout]\n    this[kClosed] = false\n    this[kDestroyed] = false\n    this[kServerName] = null\n    this[kOnDestroyed] = []\n    this[kResuming] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kNeedDrain] = 0 // 0, idle, 1, scheduled, 2 resuming\n    this[kHostHeader] = `host: ${this[kUrl].hostname}${this[kUrl].port ? `:${this[kUrl].port}` : ''}\\r\\n`\n    this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 30e3\n    this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 30e3\n    this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength\n    this[kMaxRedirections] = maxRedirections\n    this[kMaxRequests] = maxRequestsPerClient\n\n    // kQueue is built up of 3 sections separated by\n    // the kRunningIdx and kPendingIdx indices.\n    // |   complete   |   running   |   pending   |\n    //                ^ kRunningIdx ^ kPendingIdx ^ kQueue.length\n    // kRunningIdx points to the first running element.\n    // kPendingIdx points to the first pending element.\n    // This implements a fast queue with an amortized\n    // time of O(1).\n\n    this[kQueue] = []\n    this[kRunningIdx] = 0\n    this[kPendingIdx] = 0\n  }\n\n  // TODO: Make private?\n  get pipelining () {\n    return this[kPipelining]\n  }\n\n  // TODO: Make private?\n  set pipelining (value) {\n    this[kPipelining] = value\n    resume(this, true)\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get [kPending] () {\n    return this[kQueue].length - this[kPendingIdx]\n  }\n\n  get [kRunning] () {\n    return this[kPendingIdx] - this[kRunningIdx]\n  }\n\n  get [kSize] () {\n    return this[kQueue].length - this[kRunningIdx]\n  }\n\n  get [kConnected] () {\n    return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed\n  }\n\n  get [kBusy] () {\n    const socket = this[kSocket]\n    return (\n      (socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||\n      (this[kSize] >= (this[kPipelining] || 1)) ||\n      this[kPending] > 0\n    )\n  }\n\n  /* istanbul ignore: only used for test */\n  [kConnect] (cb) {\n    connect(this)\n    this.once('connect', cb)\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections) {\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      const origin = opts.origin || this[kUrl].origin\n\n      const request = new Request(origin, opts, handler)\n\n      this[kQueue].push(request)\n      if (this[kResuming]) {\n        // Do nothing.\n      } else if (util.bodyLength(request.body) == null && util.isIterable(request.body)) {\n        // Wait a tick in case stream/iterator is ended in the same tick.\n        this[kResuming] = 1\n        process.nextTick(resume, this)\n      } else {\n        resume(this, true)\n      }\n\n      if (this[kResuming] && this[kNeedDrain] !== 2 && this[kBusy]) {\n        this[kNeedDrain] = 2\n      }\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n\n    return this[kNeedDrain] < 2\n  }\n\n  close (callback) {\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.close((err, data) => {\n          return err ? reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      queueMicrotask(() => callback(new ClientDestroyedError(), null))\n      return\n    }\n\n    this[kClosed] = true\n\n    if (!this[kSize]) {\n      this.destroy(callback)\n    } else {\n      this[kOnDestroyed].push(callback)\n    }\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback === undefined) {\n      return new Promise((resolve, reject) => {\n        this.destroy(err, (err, data) => {\n          return err ? /* istanbul ignore next: should never error */ reject(err) : resolve(data)\n        })\n      })\n    }\n\n    if (typeof callback !== 'function') {\n      throw new InvalidArgumentError('invalid callback')\n    }\n\n    if (this[kDestroyed]) {\n      if (this[kOnDestroyed]) {\n        this[kOnDestroyed].push(callback)\n      } else {\n        queueMicrotask(() => callback(null, null))\n      }\n      return\n    }\n\n    if (!err) {\n      err = new ClientDestroyedError()\n    }\n\n    const requests = this[kQueue].splice(this[kPendingIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(this, request, err)\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n    this[kOnDestroyed].push(callback)\n\n    const onDestroyed = () => {\n      const callbacks = this[kOnDestroyed]\n      this[kOnDestroyed] = null\n      for (let i = 0; i < callbacks.length; i++) {\n        callbacks[i](null, null)\n      }\n    }\n\n    if (!this[kSocket]) {\n      queueMicrotask(onDestroyed)\n    } else {\n      util.destroy(this[kSocket].on('close', onDestroyed), err)\n    }\n\n    resume(this)\n  }\n}\n\nconst constants = require('./llhttp/constants')\nconst EMPTY_BUF = Buffer.alloc(0)\n\nasync function lazyllhttp () {\n  const llhttpWasmData = process.env.JEST_WORKER_ID ? require('./llhttp/llhttp.wasm.js') : undefined\n\n  let mod\n  try {\n    mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'))\n  } catch (e) {\n    /* istanbul ignore next */\n\n    // We could check if the error was caused by the simd option not\n    // being enabled, but the occurring of this other error\n    // * https://github.com/emscripten-core/emscripten/issues/11495\n    // got me to remove that check to avoid breaking Node 12.\n    mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || require('./llhttp/llhttp.wasm.js'), 'base64'))\n  }\n\n  return await WebAssembly.instantiate(mod, {\n    env: {\n      /* eslint-disable camelcase */\n\n      wasm_on_url: (p, at, len) => {\n        /* istanbul ignore next */\n        return 0\n      },\n      wasm_on_status: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_begin: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageBegin() || 0\n      },\n      wasm_on_header_field: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_header_value: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_headers_complete: (p, statusCode, upgrade, shouldKeepAlive) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onHeadersComplete(statusCode, Boolean(upgrade), Boolean(shouldKeepAlive)) || 0\n      },\n      wasm_on_body: (p, at, len) => {\n        assert.strictEqual(currentParser.ptr, p)\n        const start = at - currentBufferPtr\n        const end = start + len\n        return currentParser.onBody(currentBufferRef.slice(start, end)) || 0\n      },\n      wasm_on_message_complete: (p) => {\n        assert.strictEqual(currentParser.ptr, p)\n        return currentParser.onMessageComplete() || 0\n      }\n\n      /* eslint-enable camelcase */\n    }\n  })\n}\n\nlet llhttpInstance = null\nlet llhttpPromise = lazyllhttp()\n  .catch(() => {\n    // TODO: Emit warning?\n  })\n\nlet currentParser = null\nlet currentBufferRef = null\nlet currentBufferSize = 0\nlet currentBufferPtr = null\n\nconst TIMEOUT_HEADERS = 1\nconst TIMEOUT_BODY = 2\nconst TIMEOUT_IDLE = 3\n\nclass Parser {\n  constructor (client, socket, { exports }) {\n    assert(Number.isFinite(client[kMaxHeadersSize]) && client[kMaxHeadersSize] > 0)\n\n    this.llhttp = exports\n    this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE)\n    this.client = client\n    this.socket = socket\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n    this.statusCode = null\n    this.statusText = ''\n    this.upgrade = false\n    this.headers = []\n    this.headersSize = 0\n    this.headersMaxSize = client[kMaxHeadersSize]\n    this.shouldKeepAlive = false\n    this.paused = false\n    this.resume = this.resume.bind(this)\n\n    this.bytesRead = 0\n\n    this.trailer = ''\n    this.keepAlive = ''\n    this.contentLength = ''\n  }\n\n  setTimeout (value, type) {\n    this.timeoutType = type\n    if (value !== this.timeoutValue) {\n      clearTimeout(this.timeout)\n      if (value) {\n        this.timeout = setTimeout(onParserTimeout, value, this)\n        // istanbul ignore else: only for jest\n        if (this.timeout.unref) {\n          this.timeout.unref()\n        }\n      } else {\n        this.timeout = null\n      }\n      this.timeoutValue = value\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n  }\n\n  resume () {\n    if (this.socket.destroyed || !this.paused) {\n      return\n    }\n\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_resume(this.ptr)\n\n    assert(this.timeoutType === TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    this.paused = false\n    this.execute(this.socket.read() || EMPTY_BUF) // Flush parser.\n    this.readMore()\n  }\n\n  readMore () {\n    while (!this.paused && this.ptr) {\n      const chunk = this.socket.read()\n      if (chunk === null) {\n        break\n      }\n      this.execute(chunk)\n    }\n  }\n\n  execute (data) {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n    assert(!this.paused)\n\n    const { socket, llhttp } = this\n\n    if (data.length > currentBufferSize) {\n      if (currentBufferPtr) {\n        llhttp.free(currentBufferPtr)\n      }\n      currentBufferSize = Math.ceil(data.length / 4096) * 4096\n      currentBufferPtr = llhttp.malloc(currentBufferSize)\n    }\n\n    // TODO (perf): Can we avoid this copy somehow?\n    new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data)\n\n    // Call `execute` on the wasm parser.\n    // We pass the `llhttp_parser` pointer address, the pointer address of buffer view data,\n    // and finally the length of bytes to parse.\n    // The return value is an error code or `constants.ERROR.OK`.\n    try {\n      let ret\n\n      try {\n        currentBufferRef = data\n        currentParser = this\n        ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data.length)\n        /* eslint-disable-next-line no-useless-catch */\n      } catch (err) {\n        /* istanbul ignore next: difficult to make a test case for */\n        throw err\n      } finally {\n        currentParser = null\n        currentBufferRef = null\n      }\n\n      const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr\n\n      if (ret === constants.ERROR.PAUSED_UPGRADE) {\n        this.onUpgrade(data.slice(offset))\n      } else if (ret === constants.ERROR.PAUSED) {\n        this.paused = true\n        socket.unshift(data.slice(offset))\n      } else if (ret !== constants.ERROR.OK) {\n        const ptr = llhttp.llhttp_get_error_reason(this.ptr)\n        let message = ''\n        /* istanbul ignore else: difficult to make a test case for */\n        if (ptr) {\n          const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0)\n          message = Buffer.from(llhttp.memory.buffer, ptr, len).toString()\n        }\n        throw new HTTPParserError(message, constants.ERROR[ret], data.slice(offset))\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n  }\n\n  finish () {\n    try {\n      try {\n        currentParser = this\n        this.llhttp.llhttp_finish(this.ptr) // TODO (fix): Check ret?\n      } finally {\n        currentParser = null\n      }\n    } catch (err) {\n      // TODO (fix): What if socket is already destroyed? Error will be swallowed.\n      /* istanbul ignore next: difficult to make a test case for */\n      util.destroy(this.socket, err)\n    }\n  }\n\n  destroy () {\n    assert(this.ptr != null)\n    assert(currentParser == null)\n\n    this.llhttp.llhttp_free(this.ptr)\n    this.ptr = null\n\n    clearTimeout(this.timeout)\n    this.timeout = null\n    this.timeoutValue = null\n    this.timeoutType = null\n\n    this.paused = false\n  }\n\n  onStatus (buf) {\n    this.statusText = buf.toString()\n  }\n\n  onMessageBegin () {\n    const { socket, client } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    if (!request) {\n      return -1\n    }\n  }\n\n  onHeaderField (buf) {\n    const len = this.headers.length\n\n    if ((len & 1) === 0) {\n      this.headers.push(buf)\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  onHeaderValue (buf) {\n    let len = this.headers.length\n\n    if ((len & 1) === 1) {\n      this.headers.push(buf)\n      len += 1\n    } else {\n      this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf])\n    }\n\n    const key = this.headers[len - 2]\n    if (key.length === 10 && key.toString().toLowerCase() === 'keep-alive') {\n      this.keepAlive += buf.toString()\n    } else if (key.length === 7 && key.toString().toLowerCase() === 'trailer') {\n      this.trailer += buf.toString()\n    } else if (key.length === 14 && key.toString().toLowerCase() === 'content-length') {\n      this.contentLength += buf.toString()\n    }\n\n    this.trackHeader(buf.length)\n  }\n\n  trackHeader (len) {\n    this.headersSize += len\n    if (this.headersSize >= this.headersMaxSize) {\n      util.destroy(this.socket, new HeadersOverflowError())\n    }\n  }\n\n  onUpgrade (head) {\n    const { upgrade, client, socket, headers, statusCode } = this\n\n    assert(upgrade)\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(!socket.destroyed)\n    assert(socket === client[kSocket])\n    assert(!this.paused)\n    assert(request.upgrade || request.method === 'CONNECT')\n\n    this.statusCode = null\n    this.statusText = ''\n    this.shouldKeepAlive = null\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    socket.unshift(head)\n\n    socket[kParser].destroy()\n    socket[kParser] = null\n\n    socket[kClient] = null\n    socket[kError] = null\n    socket\n      .removeListener('error', onSocketError)\n      .removeListener('readable', onSocketReadable)\n      .removeListener('end', onSocketEnd)\n      .removeListener('close', onSocketClose)\n\n    client[kSocket] = null\n    client[kQueue][client[kRunningIdx]++] = null\n    client.emit('disconnect', client[kUrl], [client], new InformationalError('upgrade'))\n\n    try {\n      request.onUpgrade(statusCode, headers, socket)\n    } catch (err) {\n      util.destroy(socket, err)\n    }\n\n    resume(client)\n  }\n\n  onHeadersComplete (statusCode, upgrade, shouldKeepAlive) {\n    const { client, socket, headers, statusText } = this\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n\n    /* istanbul ignore next: difficult to make a test case for */\n    if (!request) {\n      return -1\n    }\n\n    // TODO: Check for content-length mismatch from server?\n\n    assert(!this.upgrade)\n    assert(this.statusCode < 200)\n\n    // TODO: More statusCode validation?\n\n    if (statusCode === 100) {\n      util.destroy(socket, new SocketError('bad response', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    /* this can only happen if server is misbehaving */\n    if (upgrade && !request.upgrade) {\n      util.destroy(socket, new SocketError('bad upgrade', util.getSocketInfo(socket)))\n      return -1\n    }\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_HEADERS)\n\n    this.statusCode = statusCode\n    this.shouldKeepAlive = shouldKeepAlive\n\n    if (this.statusCode >= 200) {\n      const bodyTimeout = request.bodyTimeout != null\n        ? request.bodyTimeout\n        : client[kBodyTimeout]\n      this.setTimeout(bodyTimeout, TIMEOUT_BODY)\n    } else if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    if (request.method === 'CONNECT' && statusCode >= 200 && statusCode < 300) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    if (upgrade) {\n      assert(client[kRunning] === 1)\n      this.upgrade = true\n      return 2\n    }\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (shouldKeepAlive && client[kPipelining]) {\n      const keepAliveTimeout = this.keepAlive ? util.parseKeepAliveTimeout(this.keepAlive) : null\n\n      if (keepAliveTimeout != null) {\n        const timeout = Math.min(\n          keepAliveTimeout - client[kKeepAliveTimeoutThreshold],\n          client[kKeepAliveMaxTimeout]\n        )\n        if (timeout <= 0) {\n          socket[kReset] = true\n        } else {\n          client[kKeepAliveTimeoutValue] = timeout\n        }\n      } else {\n        client[kKeepAliveTimeoutValue] = client[kKeepAliveDefaultTimeout]\n      }\n    } else {\n      // Stop more requests from being dispatched.\n      socket[kReset] = true\n    }\n\n    let pause\n    try {\n      pause = request.onHeaders(statusCode, headers, this.resume, statusText) === false\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n\n    if (request.method === 'HEAD') {\n      assert(socket[kReset])\n      return 1\n    }\n\n    if (statusCode < 200) {\n      return 1\n    }\n\n    if (socket[kBlocking]) {\n      socket[kBlocking] = false\n      resume(client)\n    }\n\n    return pause ? constants.ERROR.PAUSED : 0\n  }\n\n  onBody (buf) {\n    const { client, socket, statusCode } = this\n\n    if (socket.destroyed) {\n      return -1\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert.strictEqual(this.timeoutType, TIMEOUT_BODY)\n    if (this.timeout) {\n      // istanbul ignore else: only for jest\n      if (this.timeout.refresh) {\n        this.timeout.refresh()\n      }\n    }\n\n    assert(statusCode >= 200)\n\n    this.bytesRead += buf.length\n\n    try {\n      if (request.onData(buf) === false) {\n        return constants.ERROR.PAUSED\n      }\n    } catch (err) {\n      util.destroy(socket, err)\n      return -1\n    }\n  }\n\n  onMessageComplete () {\n    const { client, socket, statusCode, upgrade, trailer, headers, contentLength, bytesRead, shouldKeepAlive } = this\n\n    if (socket.destroyed && (!statusCode || shouldKeepAlive)) {\n      return -1\n    }\n\n    if (upgrade) {\n      return\n    }\n\n    const request = client[kQueue][client[kRunningIdx]]\n    assert(request)\n\n    assert(statusCode >= 100)\n\n    this.statusCode = null\n    this.statusText = ''\n    this.bytesRead = 0\n    this.contentLength = ''\n    this.trailer = ''\n    this.keepAlive = ''\n\n    assert(this.headers.length % 2 === 0)\n    this.headers = []\n    this.headersSize = 0\n\n    if (statusCode < 200) {\n      return\n    }\n\n    const trailers = trailer ? trailer.split(/,\\s*/) : []\n    for (let i = 0; i < trailers.length; i++) {\n      const trailer = trailers[i]\n      let found = false\n      for (let n = 0; n < headers.length; n += 2) {\n        const key = headers[n]\n        if (key.length === trailer.length && key.toString().toLowerCase() === trailer.toLowerCase()) {\n          found = true\n          break\n        }\n      }\n      if (!found) {\n        util.destroy(socket, new TrailerMismatchError())\n        return -1\n      }\n    }\n\n    /* istanbul ignore next: should be handled by llhttp? */\n    if (request.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {\n      util.destroy(socket, new ResponseContentLengthMismatchError())\n      return -1\n    }\n\n    try {\n      request.onComplete(headers)\n    } catch (err) {\n      errorRequest(client, request, err)\n    }\n\n    client[kQueue][client[kRunningIdx]++] = null\n\n    if (socket[kWriting]) {\n      assert.strictEqual(client[kRunning], 0)\n      // Response completed before request.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (!shouldKeepAlive) {\n      // TODO: What if running > 0?\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else if (socket[kReset] && client[kRunning] === 0) {\n      // Destroy socket once all requests have completed.\n      // The request at the tail of the pipeline is the one\n      // that requested reset and no further requests should\n      // have been queued since then.\n      util.destroy(socket, new InformationalError('reset'))\n      return constants.ERROR.PAUSED\n    } else {\n      resume(client)\n    }\n  }\n}\n\nfunction onParserTimeout (parser) {\n  const { socket, timeoutType, client } = parser\n\n  /* istanbul ignore else */\n  if (timeoutType === TIMEOUT_HEADERS) {\n    if (!socket[kWriting]) {\n      assert(!parser.paused, 'cannot be paused while waiting for headers')\n      util.destroy(socket, new HeadersTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_BODY) {\n    if (!parser.paused) {\n      util.destroy(socket, new BodyTimeoutError())\n    }\n  } else if (timeoutType === TIMEOUT_IDLE) {\n    assert(client[kRunning] === 0 && client[kKeepAliveTimeoutValue])\n    util.destroy(socket, new InformationalError('socket idle timeout'))\n  }\n}\n\nfunction onSocketReadable () {\n  const { [kParser]: parser } = this\n  parser.readMore()\n}\n\nfunction onSocketError (err) {\n  const { [kParser]: parser } = this\n\n  assert(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID')\n\n  // On Mac OS, we get an ECONNRESET even if there is a full body to be forwarded\n  // to the user.\n  if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so for as a valid response.\n    parser.finish()\n    return\n  }\n\n  this[kError] = err\n\n  onError(this[kClient], err)\n}\n\nfunction onError (client, err) {\n  if (\n    client[kRunning] === 0 &&\n    err.code !== 'UND_ERR_INFO' &&\n    err.code !== 'UND_ERR_SOCKET'\n  ) {\n    // Error is not caused by running request and not a recoverable\n    // socket error.\n\n    assert(client[kPendingIdx] === client[kRunningIdx])\n\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n    assert(client[kSize] === 0)\n  }\n}\n\nfunction onSocketEnd () {\n  const { [kParser]: parser } = this\n\n  if (parser.statusCode && !parser.shouldKeepAlive) {\n    // We treat all incoming data so far as a valid response.\n    parser.finish()\n    return\n  }\n\n  util.destroy(this, new SocketError('other side closed', util.getSocketInfo(this)))\n}\n\nfunction onSocketClose () {\n  const { [kClient]: client } = this\n\n  this[kParser].destroy()\n  this[kParser] = null\n\n  const err = this[kError] || new SocketError('closed', util.getSocketInfo(this))\n\n  client[kSocket] = null\n\n  if (client[kDestroyed]) {\n    assert(client[kPending] === 0)\n\n    // Fail entire queue.\n    const requests = client[kQueue].splice(client[kRunningIdx])\n    for (let i = 0; i < requests.length; i++) {\n      const request = requests[i]\n      errorRequest(client, request, err)\n    }\n  } else if (client[kRunning] > 0 && err.code !== 'UND_ERR_INFO') {\n    // Fail head of pipeline.\n    const request = client[kQueue][client[kRunningIdx]]\n    client[kQueue][client[kRunningIdx]++] = null\n\n    errorRequest(client, request, err)\n  }\n\n  client[kPendingIdx] = client[kRunningIdx]\n\n  assert(client[kRunning] === 0)\n\n  client.emit('disconnect', client[kUrl], [client], err)\n\n  resume(client)\n}\n\nasync function connect (client) {\n  assert(!client[kConnecting])\n  assert(!client[kSocket])\n\n  let { host, hostname, protocol, port } = client[kUrl]\n\n  // Resolve ipv6\n  if (hostname[0] === '[') {\n    const idx = hostname.indexOf(']')\n\n    assert(idx !== -1)\n    const ip = hostname.substr(1, idx - 1)\n\n    assert(net.isIP(ip))\n    hostname = ip\n  }\n\n  client[kConnecting] = true\n\n  if (channels.beforeConnect.hasSubscribers) {\n    channels.beforeConnect.publish({\n      connectParams: {\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      },\n      connector: client[kConnector]\n    })\n  }\n\n  try {\n    const socket = await new Promise((resolve, reject) => {\n      client[kConnector]({\n        host,\n        hostname,\n        protocol,\n        port,\n        servername: client[kServerName]\n      }, (err, socket) => {\n        if (err) {\n          reject(err)\n        } else {\n          resolve(socket)\n        }\n      })\n    })\n\n    if (!llhttpInstance) {\n      llhttpInstance = await llhttpPromise\n      llhttpPromise = null\n    }\n\n    client[kConnecting] = false\n\n    assert(socket)\n\n    client[kSocket] = socket\n\n    socket[kNoRef] = false\n    socket[kWriting] = false\n    socket[kReset] = false\n    socket[kBlocking] = false\n    socket[kError] = null\n    socket[kParser] = new Parser(client, socket, llhttpInstance)\n    socket[kClient] = client\n    socket[kCounter] = 0\n    socket[kMaxRequests] = client[kMaxRequests]\n    socket\n      .on('error', onSocketError)\n      .on('readable', onSocketReadable)\n      .on('end', onSocketEnd)\n      .on('close', onSocketClose)\n\n    if (channels.connected.hasSubscribers) {\n      channels.connected.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        socket\n      })\n    }\n    client.emit('connect', client[kUrl], [client])\n  } catch (err) {\n    client[kConnecting] = false\n\n    if (channels.connectError.hasSubscribers) {\n      channels.connectError.publish({\n        connectParams: {\n          host,\n          hostname,\n          protocol,\n          port,\n          servername: client[kServerName]\n        },\n        connector: client[kConnector],\n        error: err\n      })\n    }\n\n    if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {\n      assert(client[kRunning] === 0)\n      while (client[kPending] > 0 && client[kQueue][client[kPendingIdx]].servername === client[kServerName]) {\n        const request = client[kQueue][client[kPendingIdx]++]\n        errorRequest(client, request, err)\n      }\n    } else {\n      onError(client, err)\n    }\n\n    client.emit('connectionError', client[kUrl], [client], err)\n  }\n\n  resume(client)\n}\n\nfunction emitDrain (client) {\n  client[kNeedDrain] = 0\n  client.emit('drain', client[kUrl], [client])\n}\n\nfunction resume (client, sync) {\n  if (client[kResuming] === 2) {\n    return\n  }\n\n  client[kResuming] = 2\n\n  _resume(client, sync)\n  client[kResuming] = 0\n\n  if (client[kRunningIdx] > 256) {\n    client[kQueue].splice(0, client[kRunningIdx])\n    client[kPendingIdx] -= client[kRunningIdx]\n    client[kRunningIdx] = 0\n  }\n}\n\nfunction _resume (client, sync) {\n  while (true) {\n    if (client[kDestroyed]) {\n      assert(client[kPending] === 0)\n      return\n    }\n\n    if (client[kClosed] && !client[kSize]) {\n      client.destroy(util.nop)\n      continue\n    }\n\n    const socket = client[kSocket]\n\n    if (socket) {\n      if (client[kSize] === 0) {\n        if (!socket[kNoRef] && socket.unref) {\n          socket.unref()\n          socket[kNoRef] = true\n        }\n      } else if (socket[kNoRef] && socket.ref) {\n        socket.ref()\n        socket[kNoRef] = false\n      }\n\n      if (client[kSize] === 0) {\n        if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {\n          socket[kParser].setTimeout(client[kKeepAliveTimeoutValue], TIMEOUT_IDLE)\n        }\n      } else if (client[kRunning] > 0 && socket[kParser].statusCode < 200) {\n        if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {\n          const request = client[kQueue][client[kRunningIdx]]\n          const headersTimeout = request.headersTimeout != null\n            ? request.headersTimeout\n            : client[kHeadersTimeout]\n          socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS)\n        }\n      }\n    }\n\n    if (client[kBusy]) {\n      client[kNeedDrain] = 2\n    } else if (client[kNeedDrain] === 2) {\n      if (sync) {\n        client[kNeedDrain] = 1\n        process.nextTick(emitDrain, client)\n      } else {\n        emitDrain(client)\n      }\n      continue\n    }\n\n    if (client[kPending] === 0) {\n      return\n    }\n\n    if (client[kRunning] >= (client[kPipelining] || 1)) {\n      return\n    }\n\n    const request = client[kQueue][client[kPendingIdx]]\n\n    if (client[kUrl].protocol === 'https:' && client[kServerName] !== request.servername) {\n      if (client[kRunning] > 0) {\n        return\n      }\n\n      client[kServerName] = request.servername\n\n      if (socket && socket.servername !== request.servername) {\n        util.destroy(socket, new InformationalError('servername changed'))\n        return\n      }\n    }\n\n    if (client[kConnecting]) {\n      return\n    }\n\n    if (!socket) {\n      connect(client)\n      continue\n    }\n\n    if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {\n      return\n    }\n\n    if (client[kRunning] > 0 && !request.idempotent) {\n      // Non-idempotent request cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (client[kRunning] > 0 && (request.upgrade || request.method === 'CONNECT')) {\n      // Don't dispatch an upgrade until all preceding requests have completed.\n      // A misbehaving server might upgrade the connection before all pipelined\n      // request has completed.\n      return\n    }\n\n    if (util.isStream(request.body) && util.bodyLength(request.body) === 0) {\n      request.body\n        .on('data', /* istanbul ignore next */ function () {\n          /* istanbul ignore next */\n          assert(false)\n        })\n        .on('error', function (err) {\n          errorRequest(client, request, err)\n        })\n        .on('end', function () {\n          util.destroy(this)\n        })\n\n      request.body = null\n    }\n\n    if (client[kRunning] > 0 &&\n      (util.isStream(request.body) || util.isAsyncIterable(request.body))) {\n      // Request with stream or iterator body can error while other requests\n      // are inflight and indirectly error those as well.\n      // Ensure this doesn't happen by waiting for inflight\n      // to complete before dispatching.\n\n      // Request with stream or iterator body cannot be retried.\n      // Ensure that no other requests are inflight and\n      // could cause failure.\n      return\n    }\n\n    if (!request.aborted && write(client, request)) {\n      client[kPendingIdx]++\n    } else {\n      client[kQueue].splice(client[kPendingIdx], 1)\n    }\n  }\n}\n\nfunction write (client, request) {\n  const { body, method, path, host, upgrade, headers, blocking } = request\n\n  // https://tools.ietf.org/html/rfc7231#section-4.3.1\n  // https://tools.ietf.org/html/rfc7231#section-4.3.2\n  // https://tools.ietf.org/html/rfc7231#section-4.3.5\n\n  // Sending a payload body on a request that does not\n  // expect it can cause undefined behavior on some\n  // servers and corrupt connection state. Do not\n  // re-use the connection for further requests.\n\n  const expectsPayload = (\n    method === 'PUT' ||\n    method === 'POST' ||\n    method === 'PATCH'\n  )\n\n  if (body && typeof body.read === 'function') {\n    // Try to read EOF in order to get length.\n    body.read(0)\n  }\n\n  let contentLength = util.bodyLength(body)\n\n  if (contentLength === null) {\n    contentLength = request.contentLength\n  }\n\n  if (contentLength === 0 && !expectsPayload) {\n    // https://tools.ietf.org/html/rfc7230#section-3.3.2\n    // A user agent SHOULD NOT send a Content-Length header field when\n    // the request message does not contain a payload body and the method\n    // semantics do not anticipate such a body.\n\n    contentLength = null\n  }\n\n  if (request.contentLength !== null && request.contentLength !== contentLength) {\n    if (client[kStrictContentLength]) {\n      errorRequest(client, request, new RequestContentLengthMismatchError())\n      return false\n    }\n\n    process.emitWarning(new RequestContentLengthMismatchError())\n  }\n\n  const socket = client[kSocket]\n\n  try {\n    request.onConnect((err) => {\n      if (request.aborted || request.completed) {\n        return\n      }\n\n      errorRequest(client, request, err || new RequestAbortedError())\n\n      util.destroy(socket, new InformationalError('aborted'))\n    })\n  } catch (err) {\n    errorRequest(client, request, err)\n  }\n\n  if (request.aborted) {\n    return false\n  }\n\n  if (method === 'HEAD') {\n    // https://github.com/mcollina/undici/issues/258\n\n    // Close after a HEAD request to interop with misbehaving servers\n    // that may send a body in the response.\n\n    socket[kReset] = true\n  }\n\n  if (upgrade || method === 'CONNECT') {\n    // On CONNECT or upgrade, block pipeline from dispatching further\n    // requests on this connection.\n\n    socket[kReset] = true\n  }\n\n  if (client[kMaxRequests] && socket[kCounter]++ >= client[kMaxRequests]) {\n    socket[kReset] = true\n  }\n\n  if (blocking) {\n    socket[kBlocking] = true\n  }\n\n  // TODO: Expect: 100-continue\n\n  let header = `${method} ${path} HTTP/1.1\\r\\n`\n\n  if (typeof host === 'string') {\n    header += `host: ${host}\\r\\n`\n  } else {\n    header += client[kHostHeader]\n  }\n\n  if (upgrade) {\n    header += `connection: upgrade\\r\\nupgrade: ${upgrade}\\r\\n`\n  } else if (client[kPipelining]) {\n    header += 'connection: keep-alive\\r\\n'\n  } else {\n    header += 'connection: close\\r\\n'\n  }\n\n  if (headers) {\n    header += headers\n  }\n\n  if (channels.sendHeaders.hasSubscribers) {\n    channels.sendHeaders.publish({ request, headers: header, socket })\n  }\n\n  /* istanbul ignore else: assertion */\n  if (!body) {\n    if (contentLength === 0) {\n      socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n    } else {\n      assert(contentLength === null, 'no body must not have content length')\n      socket.write(`${header}\\r\\n`, 'ascii')\n    }\n    request.onRequestSent()\n  } else if (util.isBuffer(body)) {\n    assert(contentLength === body.byteLength, 'buffer body must have content length')\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(body)\n    socket.uncork()\n    request.onBodySent(body)\n    request.onRequestSent()\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n  } else if (util.isBlobLike(body)) {\n    if (typeof body.stream === 'function') {\n      writeIterable({ body: body.stream(), client, request, socket, contentLength, header, expectsPayload })\n    } else {\n      writeBlob({ body, client, request, socket, contentLength, header, expectsPayload })\n    }\n  } else if (util.isStream(body)) {\n    writeStream({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else if (util.isIterable(body)) {\n    writeIterable({ body, client, request, socket, contentLength, header, expectsPayload })\n  } else {\n    assert(false)\n  }\n\n  return true\n}\n\nfunction writeStream ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'stream body cannot be pipelined')\n\n  let finished = false\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n\n  const onData = function (chunk) {\n    try {\n      assert(!finished)\n\n      if (!writer.write(chunk) && this.pause) {\n        this.pause()\n      }\n    } catch (err) {\n      util.destroy(this, err)\n    }\n  }\n  const onDrain = function () {\n    assert(!finished)\n\n    if (body.resume) {\n      body.resume()\n    }\n  }\n  const onAbort = function () {\n    onFinished(new RequestAbortedError())\n  }\n  const onFinished = function (err) {\n    if (finished) {\n      return\n    }\n\n    finished = true\n\n    assert(socket.destroyed || (socket[kWriting] && client[kRunning] <= 1))\n\n    socket\n      .off('drain', onDrain)\n      .off('error', onFinished)\n\n    body\n      .removeListener('data', onData)\n      .removeListener('end', onFinished)\n      .removeListener('error', onFinished)\n      .removeListener('close', onAbort)\n\n    if (!err) {\n      try {\n        writer.end()\n      } catch (er) {\n        err = er\n      }\n    }\n\n    writer.destroy(err)\n\n    // TODO (fix): Avoid using err.message for logic.\n    if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {\n      util.destroy(body, err)\n    } else {\n      util.destroy(body)\n    }\n  }\n\n  body\n    .on('data', onData)\n    .on('end', onFinished)\n    .on('error', onFinished)\n    .on('close', onAbort)\n\n  if (body.resume) {\n    body.resume()\n  }\n\n  socket\n    .on('drain', onDrain)\n    .on('error', onFinished)\n}\n\nasync function writeBlob ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength === body.size, 'blob body must have content length')\n\n  try {\n    if (contentLength != null && contentLength !== body.size) {\n      throw new RequestContentLengthMismatchError()\n    }\n\n    const buffer = Buffer.from(await body.arrayBuffer())\n\n    socket.cork()\n    socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n    socket.write(buffer)\n    socket.uncork()\n\n    request.onBodySent(buffer)\n    request.onRequestSent()\n\n    if (!expectsPayload) {\n      socket[kReset] = true\n    }\n\n    resume(client)\n  } catch (err) {\n    util.destroy(socket, err)\n  }\n}\n\nasync function writeIterable ({ body, client, request, socket, contentLength, header, expectsPayload }) {\n  assert(contentLength !== 0 || client[kRunning] === 0, 'iterator body cannot be pipelined')\n\n  let callback = null\n  function onDrain () {\n    if (callback) {\n      const cb = callback\n      callback = null\n      cb()\n    }\n  }\n\n  const waitForDrain = () => new Promise((resolve, reject) => {\n    assert(callback === null)\n\n    if (socket[kError]) {\n      reject(socket[kError])\n    } else {\n      callback = resolve\n    }\n  })\n\n  socket\n    .on('close', onDrain)\n    .on('drain', onDrain)\n\n  const writer = new AsyncWriter({ socket, request, contentLength, client, expectsPayload, header })\n  try {\n    // TODO (fix): What if socket errors while waiting for body?\n    // It's up to the user to somehow abort the async iterable.\n    for await (const chunk of body) {\n      if (socket[kError]) {\n        throw socket[kError]\n      }\n\n      if (!writer.write(chunk)) {\n        await waitForDrain()\n      }\n    }\n\n    writer.end()\n  } catch (err) {\n    writer.destroy(err)\n  } finally {\n    socket\n      .off('close', onDrain)\n      .off('drain', onDrain)\n  }\n}\n\nclass AsyncWriter {\n  constructor ({ socket, request, contentLength, client, expectsPayload, header }) {\n    this.socket = socket\n    this.request = request\n    this.contentLength = contentLength\n    this.client = client\n    this.bytesWritten = 0\n    this.expectsPayload = expectsPayload\n    this.header = header\n\n    socket[kWriting] = true\n  }\n\n  write (chunk) {\n    const { socket, request, contentLength, client, bytesWritten, expectsPayload, header } = this\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return false\n    }\n\n    const len = Buffer.byteLength(chunk)\n    if (!len) {\n      return true\n    }\n\n    // TODO: What if not ended and bytesWritten === contentLength?\n    // We should defer writing chunks.\n    if (contentLength !== null && bytesWritten + len > contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      }\n\n      process.emitWarning(new RequestContentLengthMismatchError())\n    }\n\n    if (bytesWritten === 0) {\n      if (!expectsPayload) {\n        socket[kReset] = true\n      }\n\n      if (contentLength === null) {\n        socket.write(`${header}transfer-encoding: chunked\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}content-length: ${contentLength}\\r\\n\\r\\n`, 'ascii')\n      }\n    }\n\n    if (contentLength === null) {\n      socket.write(`\\r\\n${len.toString(16)}\\r\\n`, 'ascii')\n    }\n\n    this.bytesWritten += len\n\n    const ret = socket.write(chunk)\n    request.onBodySent(chunk)\n    return ret\n  }\n\n  end () {\n    const { socket, contentLength, client, bytesWritten, expectsPayload, header, request } = this\n    request.onRequestSent()\n\n    socket[kWriting] = false\n\n    if (socket[kError]) {\n      throw socket[kError]\n    }\n\n    if (socket.destroyed) {\n      return\n    }\n\n    if (bytesWritten === 0) {\n      if (expectsPayload) {\n        // https://tools.ietf.org/html/rfc7230#section-3.3.2\n        // A user agent SHOULD send a Content-Length in a request message when\n        // no Transfer-Encoding is sent and the request method defines a meaning\n        // for an enclosed payload body.\n\n        socket.write(`${header}content-length: 0\\r\\n\\r\\n`, 'ascii')\n      } else {\n        socket.write(`${header}\\r\\n`, 'ascii')\n      }\n    } else if (contentLength === null) {\n      socket.write('\\r\\n0\\r\\n\\r\\n', 'ascii')\n    }\n\n    if (contentLength !== null && bytesWritten !== contentLength) {\n      if (client[kStrictContentLength]) {\n        throw new RequestContentLengthMismatchError()\n      } else {\n        process.emitWarning(new RequestContentLengthMismatchError())\n      }\n    }\n\n    // TODO (fix): Add comment clarifying what this does?\n    if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {\n      // istanbul ignore else: only for jest\n      if (socket[kParser].timeout.refresh) {\n        socket[kParser].timeout.refresh()\n      }\n    }\n\n    resume(client)\n  }\n\n  destroy (err) {\n    const { socket, client } = this\n\n    socket[kWriting] = false\n\n    if (err) {\n      assert(client[kRunning] <= 1, 'pipeline should only contain this request')\n      util.destroy(socket, err)\n    }\n  }\n}\n\nfunction errorRequest (client, request, err) {\n  try {\n    request.onError(err)\n    assert(request.aborted)\n  } catch (err) {\n    client.emit('error', err)\n  }\n}\n\nmodule.exports = Client\n"],"mappings":"AAAA;AAEA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,MAAMC,GAAG,GAAGD,OAAO,CAAC,KAAD,CAAnB;;AACA,MAAME,IAAI,GAAGF,OAAO,CAAC,aAAD,CAApB;;AACA,MAAMG,OAAO,GAAGH,OAAO,CAAC,gBAAD,CAAvB;;AACA,MAAMI,UAAU,GAAGJ,OAAO,CAAC,cAAD,CAA1B;;AACA,MAAMK,eAAe,GAAGL,OAAO,CAAC,oBAAD,CAA/B;;AACA,MAAM;EACJM,iCADI;EAEJC,kCAFI;EAGJC,oBAHI;EAIJC,oBAJI;EAKJC,mBALI;EAMJC,mBANI;EAOJC,oBAPI;EAQJC,oBARI;EASJC,iBATI;EAUJC,WAVI;EAWJC,kBAXI;EAYJC,gBAZI;EAaJC;AAbI,IAcFlB,OAAO,CAAC,eAAD,CAdX;;AAeA,MAAMmB,cAAc,GAAGnB,OAAO,CAAC,gBAAD,CAA9B;;AACA,MAAM;EACJoB,IADI;EAEJC,MAFI;EAGJC,WAHI;EAIJC,OAJI;EAKJC,KALI;EAMJC,OANI;EAOJC,QAPI;EAQJC,SARI;EASJC,SATI;EAUJC,QAVI;EAWJC,QAXI;EAYJC,KAZI;EAaJC,QAbI;EAcJC,MAdI;EAeJC,UAfI;EAgBJC,WAhBI;EAiBJC,UAjBI;EAkBJC,MAlBI;EAmBJC,wBAnBI;EAoBJC,WApBI;EAqBJC,OArBI;EAsBJC,UAtBI;EAuBJC,WAvBI;EAwBJC,WAxBI;EAyBJC,MAzBI;EA0BJC,YA1BI;EA2BJC,WA3BI;EA4BJC,OA5BI;EA6BJC,sBA7BI;EA8BJC,eA9BI;EA+BJC,oBA/BI;EAgCJC,0BAhCI;EAiCJC,eAjCI;EAkCJC,YAlCI;EAmCJC,oBAnCI;EAoCJC,UApCI;EAqCJC,gBArCI;EAsCJC,YAtCI;EAuCJC;AAvCI,IAwCF1D,OAAO,CAAC,gBAAD,CAxCX;;AA0CA,MAAM2D,QAAQ,GAAG,EAAjB;;AAEA,IAAI;EACF,MAAMC,kBAAkB,GAAG5D,OAAO,CAAC,qBAAD,CAAlC;;EACA2D,QAAQ,CAACE,WAAT,GAAuBD,kBAAkB,CAACE,OAAnB,CAA2B,2BAA3B,CAAvB;EACAH,QAAQ,CAACI,aAAT,GAAyBH,kBAAkB,CAACE,OAAnB,CAA2B,6BAA3B,CAAzB;EACAH,QAAQ,CAACK,YAAT,GAAwBJ,kBAAkB,CAACE,OAAnB,CAA2B,4BAA3B,CAAxB;EACAH,QAAQ,CAACM,SAAT,GAAqBL,kBAAkB,CAACE,OAAnB,CAA2B,yBAA3B,CAArB;AACD,CAND,CAME,MAAM;EACNH,QAAQ,CAACE,WAAT,GAAuB;IAAEK,cAAc,EAAE;EAAlB,CAAvB;EACAP,QAAQ,CAACI,aAAT,GAAyB;IAAEG,cAAc,EAAE;EAAlB,CAAzB;EACAP,QAAQ,CAACK,YAAT,GAAwB;IAAEE,cAAc,EAAE;EAAlB,CAAxB;EACAP,QAAQ,CAACM,SAAT,GAAqB;IAAEC,cAAc,EAAE;EAAlB,CAArB;AACD;;AAED,MAAMC,MAAN,SAAqB/D,UAArB,CAAgC;EAC9BgE,WAAW,CAAEC,GAAF,EAqBH;IAAA,IArBU;MAChBC,aADgB;MAEhBC,cAFgB;MAGhBC,aAHgB;MAIhBC,cAJgB;MAKhBC,cALgB;MAMhBC,WANgB;MAOhBC,WAPgB;MAQhBC,SARgB;MAShBC,gBATgB;MAUhBC,mBAVgB;MAWhBC,mBAXgB;MAYhBC,yBAZgB;MAahBC,UAbgB;MAchBC,UAdgB;MAehBC,GAfgB;MAgBhBC,mBAhBgB;MAiBhBC,iBAjBgB;MAkBhBC,eAlBgB;MAmBhBC,OAnBgB;MAoBhBC;IApBgB,CAqBV,uEAAJ,EAAI;IACN;;IAEA,IAAIZ,SAAS,KAAKa,SAAlB,EAA6B;MAC3B,MAAM,IAAIjF,oBAAJ,CAAyB,iDAAzB,CAAN;IACD;;IAED,IAAI+D,aAAa,KAAKkB,SAAtB,EAAiC;MAC/B,MAAM,IAAIjF,oBAAJ,CAAyB,qEAAzB,CAAN;IACD;;IAED,IAAIgE,cAAc,KAAKiB,SAAvB,EAAkC;MAChC,MAAM,IAAIjF,oBAAJ,CAAyB,sEAAzB,CAAN;IACD;;IAED,IAAImE,WAAW,KAAKc,SAApB,EAA+B;MAC7B,MAAM,IAAIjF,oBAAJ,CAAyB,uDAAzB,CAAN;IACD;;IAED,IAAIsE,mBAAmB,KAAKW,SAA5B,EAAuC;MACrC,MAAM,IAAIjF,oBAAJ,CAAyB,kEAAzB,CAAN;IACD;;IAED,IAAI6D,aAAa,IAAI,IAAjB,IAAyB,CAACqB,MAAM,CAACC,QAAP,CAAgBtB,aAAhB,CAA9B,EAA8D;MAC5D,MAAM,IAAI7D,oBAAJ,CAAyB,uBAAzB,CAAN;IACD;;IAED,IAAIyE,UAAU,IAAI,IAAd,IAAsB,OAAOA,UAAP,KAAsB,QAAhD,EAA0D;MACxD,MAAM,IAAIzE,oBAAJ,CAAyB,oBAAzB,CAAN;IACD;;IAED,IAAIiE,cAAc,IAAI,IAAlB,KAA2B,CAACiB,MAAM,CAACC,QAAP,CAAgBlB,cAAhB,CAAD,IAAoCA,cAAc,GAAG,CAAhF,CAAJ,EAAwF;MACtF,MAAM,IAAIjE,oBAAJ,CAAyB,wBAAzB,CAAN;IACD;;IAED,IAAIqE,gBAAgB,IAAI,IAApB,KAA6B,CAACa,MAAM,CAACC,QAAP,CAAgBd,gBAAhB,CAAD,IAAsCA,gBAAgB,IAAI,CAAvF,CAAJ,EAA+F;MAC7F,MAAM,IAAIrE,oBAAJ,CAAyB,0BAAzB,CAAN;IACD;;IAED,IAAIuE,mBAAmB,IAAI,IAAvB,KAAgC,CAACW,MAAM,CAACC,QAAP,CAAgBZ,mBAAhB,CAAD,IAAyCA,mBAAmB,IAAI,CAAhG,CAAJ,EAAwG;MACtG,MAAM,IAAIvE,oBAAJ,CAAyB,6BAAzB,CAAN;IACD;;IAED,IAAIwE,yBAAyB,IAAI,IAA7B,IAAqC,CAACU,MAAM,CAACC,QAAP,CAAgBX,yBAAhB,CAA1C,EAAsF;MACpF,MAAM,IAAIxE,oBAAJ,CAAyB,mCAAzB,CAAN;IACD;;IAED,IAAI8D,cAAc,IAAI,IAAlB,KAA2B,CAACoB,MAAM,CAACE,SAAP,CAAiBtB,cAAjB,CAAD,IAAqCA,cAAc,GAAG,CAAjF,CAAJ,EAAyF;MACvF,MAAM,IAAI9D,oBAAJ,CAAyB,mDAAzB,CAAN;IACD;;IAED,IAAIkE,WAAW,IAAI,IAAf,KAAwB,CAACgB,MAAM,CAACE,SAAP,CAAiBlB,WAAjB,CAAD,IAAkCA,WAAW,GAAG,CAAxE,CAAJ,EAAgF;MAC9E,MAAM,IAAIlE,oBAAJ,CAAyB,gDAAzB,CAAN;IACD;;IAED,IAAI+E,OAAO,IAAI,IAAX,IAAmB,OAAOA,OAAP,KAAmB,UAAtC,IAAoD,OAAOA,OAAP,KAAmB,QAA3E,EAAqF;MACnF,MAAM,IAAI/E,oBAAJ,CAAyB,yCAAzB,CAAN;IACD;;IAED,IAAI8E,eAAe,IAAI,IAAnB,KAA4B,CAACI,MAAM,CAACE,SAAP,CAAiBN,eAAjB,CAAD,IAAsCA,eAAe,GAAG,CAApF,CAAJ,EAA4F;MAC1F,MAAM,IAAI9E,oBAAJ,CAAyB,2CAAzB,CAAN;IACD;;IAED,IAAIgF,oBAAoB,IAAI,IAAxB,KAAiC,CAACE,MAAM,CAACE,SAAP,CAAiBJ,oBAAjB,CAAD,IAA2CA,oBAAoB,GAAG,CAAnG,CAAJ,EAA2G;MACzG,MAAM,IAAIhF,oBAAJ,CAAyB,gDAAzB,CAAN;IACD;;IAED,IAAI,OAAO+E,OAAP,KAAmB,UAAvB,EAAmC;MACjCA,OAAO,GAAGrE,cAAc,CAAC,EACvB,GAAGiE,GADoB;QAEvBE,iBAFuB;QAGvBJ,UAHuB;QAIvBY,OAAO,EAAEpB,cAJc;QAKvB,GAAGc;MALoB,CAAD,CAAxB;IAOD;;IAED,KAAKpE,IAAL,IAAalB,IAAI,CAAC6F,WAAL,CAAiB1B,GAAjB,CAAb;IACA,KAAKd,UAAL,IAAmBiC,OAAnB;IACA,KAAKzC,OAAL,IAAgB,IAAhB;IACA,KAAKD,WAAL,IAAoBqC,UAAU,IAAI,IAAd,GAAqBA,UAArB,GAAkC,CAAtD;IACA,KAAKlC,eAAL,IAAwBqB,aAAa,IAAI,KAAzC;IACA,KAAKhC,wBAAL,IAAiCwC,gBAAgB,IAAI,IAApB,GAA2B,GAA3B,GAAiCA,gBAAlE;IACA,KAAK5B,oBAAL,IAA6B8B,mBAAmB,IAAI,IAAvB,GAA8B,KAA9B,GAAsCA,mBAAnE;IACA,KAAK7B,0BAAL,IAAmC8B,yBAAyB,IAAI,IAA7B,GAAoC,GAApC,GAA0CA,yBAA7E;IACA,KAAKjC,sBAAL,IAA+B,KAAKV,wBAAL,CAA/B;IACA,KAAKE,OAAL,IAAgB,KAAhB;IACA,KAAKC,UAAL,IAAmB,KAAnB;IACA,KAAKnB,WAAL,IAAoB,IAApB;IACA,KAAKuB,YAAL,IAAqB,EAArB;IACA,KAAKjB,SAAL,IAAkB,CAAlB,CA1FM,CA0Fc;;IACpB,KAAKQ,UAAL,IAAmB,CAAnB,CA3FM,CA2Fe;;IACrB,KAAKG,WAAL,IAAqB,SAAQ,KAAKnB,IAAL,EAAW4E,QAAS,GAAE,KAAK5E,IAAL,EAAW6E,IAAX,GAAmB,IAAG,KAAK7E,IAAL,EAAW6E,IAAK,EAAtC,GAA0C,EAAG,MAAhG;IACA,KAAK5C,YAAL,IAAqBsB,WAAW,IAAI,IAAf,GAAsBA,WAAtB,GAAoC,IAAzD;IACA,KAAKvB,eAAL,IAAwBmB,cAAc,IAAI,IAAlB,GAAyBA,cAAzB,GAA0C,IAAlE;IACA,KAAKjB,oBAAL,IAA6B+B,mBAAmB,IAAI,IAAvB,GAA8B,IAA9B,GAAqCA,mBAAlE;IACA,KAAK7B,gBAAL,IAAyB+B,eAAzB;IACA,KAAK9B,YAAL,IAAqBgC,oBAArB,CAjGM,CAmGN;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA,KAAKxD,MAAL,IAAe,EAAf;IACA,KAAKU,WAAL,IAAoB,CAApB;IACA,KAAKD,WAAL,IAAoB,CAApB;EACD,CArI6B,CAuI9B;;;EACc,IAAVyC,UAAU,GAAI;IAChB,OAAO,KAAKrC,WAAL,CAAP;EACD,CA1I6B,CA4I9B;;;EACc,IAAVqC,UAAU,CAAEe,KAAF,EAAS;IACrB,KAAKpD,WAAL,IAAoBoD,KAApB;IACAC,MAAM,CAAC,IAAD,EAAO,IAAP,CAAN;EACD;;EAEY,IAATC,SAAS,GAAI;IACf,OAAO,KAAK3D,UAAL,CAAP;EACD;;EAES,IAAN4D,MAAM,GAAI;IACZ,OAAO,KAAK7D,OAAL,CAAP;EACD;;EAEY,KAARV,QAAQ,IAAK;IAChB,OAAO,KAAKG,MAAL,EAAaqE,MAAb,GAAsB,KAAK5D,WAAL,CAA7B;EACD;;EAEY,KAARb,QAAQ,IAAK;IAChB,OAAO,KAAKa,WAAL,IAAoB,KAAKC,WAAL,CAA3B;EACD;;EAES,KAALZ,KAAK,IAAK;IACb,OAAO,KAAKE,MAAL,EAAaqE,MAAb,GAAsB,KAAK3D,WAAL,CAA7B;EACD;;EAEc,KAAVT,UAAU,IAAK;IAClB,OAAO,CAAC,CAAC,KAAKa,OAAL,CAAF,IAAmB,CAAC,KAAKZ,WAAL,CAApB,IAAyC,CAAC,KAAKY,OAAL,EAAcqD,SAA/D;EACD;;EAES,KAAL5E,KAAK,IAAK;IACb,MAAM+E,MAAM,GAAG,KAAKxD,OAAL,CAAf;IACA,OACGwD,MAAM,KAAKA,MAAM,CAAClF,MAAD,CAAN,IAAkBkF,MAAM,CAACvE,QAAD,CAAxB,IAAsCuE,MAAM,CAAC5E,SAAD,CAAjD,CAAP,IACC,KAAKI,KAAL,MAAgB,KAAKe,WAAL,KAAqB,CAArC,CADD,IAEA,KAAKhB,QAAL,IAAiB,CAHnB;EAKD;EAED;;;EACS,CAARJ,QAAQ,EAAG8E,EAAH,EAAO;IACdhB,OAAO,CAAC,IAAD,CAAP;IACA,KAAKiB,IAAL,CAAU,SAAV,EAAqBD,EAArB;EACD;;EAEDE,QAAQ,CAAEC,IAAF,EAAQC,OAAR,EAAiB;IACvB,IAAI,CAACA,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAnC,EAA6C;MAC3C,MAAM,IAAInG,oBAAJ,CAAyB,2BAAzB,CAAN;IACD;;IAED,IAAI;MACF,IAAI,CAACkG,IAAD,IAAS,OAAOA,IAAP,KAAgB,QAA7B,EAAuC;QACrC,MAAM,IAAIlG,oBAAJ,CAAyB,yBAAzB,CAAN;MACD;;MAED,IAAI,KAAKgC,UAAL,CAAJ,EAAsB;QACpB,MAAM,IAAI5B,oBAAJ,EAAN;MACD;;MAED,IAAI,KAAK2B,OAAL,CAAJ,EAAmB;QACjB,MAAM,IAAI1B,iBAAJ,EAAN;MACD;;MAED,MAAM;QAAEyE,eAAe,GAAG,KAAK/B,gBAAL;MAApB,IAA+CmD,IAArD;;MACA,IAAIpB,eAAJ,EAAqB;QACnBqB,OAAO,GAAG,IAAIvG,eAAJ,CAAoB,IAApB,EAA0BkF,eAA1B,EAA2CoB,IAA3C,EAAiDC,OAAjD,CAAV;MACD;;MAED,MAAMC,MAAM,GAAGF,IAAI,CAACE,MAAL,IAAe,KAAKzF,IAAL,EAAWyF,MAAzC;MAEA,MAAMC,OAAO,GAAG,IAAI3G,OAAJ,CAAY0G,MAAZ,EAAoBF,IAApB,EAA0BC,OAA1B,CAAhB;MAEA,KAAK3E,MAAL,EAAa8E,IAAb,CAAkBD,OAAlB;;MACA,IAAI,KAAKlF,SAAL,CAAJ,EAAqB,CACnB;MACD,CAFD,MAEO,IAAI1B,IAAI,CAAC8G,UAAL,CAAgBF,OAAO,CAACG,IAAxB,KAAiC,IAAjC,IAAyC/G,IAAI,CAACgH,UAAL,CAAgBJ,OAAO,CAACG,IAAxB,CAA7C,EAA4E;QACjF;QACA,KAAKrF,SAAL,IAAkB,CAAlB;QACAuF,OAAO,CAACC,QAAR,CAAiBjB,MAAjB,EAAyB,IAAzB;MACD,CAJM,MAIA;QACLA,MAAM,CAAC,IAAD,EAAO,IAAP,CAAN;MACD;;MAED,IAAI,KAAKvE,SAAL,KAAmB,KAAKQ,UAAL,MAAqB,CAAxC,IAA6C,KAAKZ,KAAL,CAAjD,EAA8D;QAC5D,KAAKY,UAAL,IAAmB,CAAnB;MACD;IACF,CApCD,CAoCE,OAAOiF,GAAP,EAAY;MACZ,IAAI,OAAOT,OAAO,CAACU,OAAf,KAA2B,UAA/B,EAA2C;QACzC,MAAM,IAAI7G,oBAAJ,CAAyB,wBAAzB,CAAN;MACD;;MAEDmG,OAAO,CAACU,OAAR,CAAgBD,GAAhB;IACD;;IAED,OAAO,KAAKjF,UAAL,IAAmB,CAA1B;EACD;;EAEDmF,KAAK,CAAEC,QAAF,EAAY;IACf,IAAIA,QAAQ,KAAK9B,SAAjB,EAA4B;MAC1B,OAAO,IAAI+B,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;QACtC,KAAKJ,KAAL,CAAW,CAACF,GAAD,EAAMO,IAAN,KAAe;UACxB,OAAOP,GAAG,GAAGM,MAAM,CAACN,GAAD,CAAT,GAAiBK,OAAO,CAACE,IAAD,CAAlC;QACD,CAFD;MAGD,CAJM,CAAP;IAKD;;IAED,IAAI,OAAOJ,QAAP,KAAoB,UAAxB,EAAoC;MAClC,MAAM,IAAI/G,oBAAJ,CAAyB,kBAAzB,CAAN;IACD;;IAED,IAAI,KAAKgC,UAAL,CAAJ,EAAsB;MACpBoF,cAAc,CAAC,MAAML,QAAQ,CAAC,IAAI3G,oBAAJ,EAAD,EAA6B,IAA7B,CAAf,CAAd;MACA;IACD;;IAED,KAAK2B,OAAL,IAAgB,IAAhB;;IAEA,IAAI,CAAC,KAAKT,KAAL,CAAL,EAAkB;MAChB,KAAK+F,OAAL,CAAaN,QAAb;IACD,CAFD,MAEO;MACL,KAAK3E,YAAL,EAAmBkE,IAAnB,CAAwBS,QAAxB;IACD;EACF;;EAEDM,OAAO,CAAET,GAAF,EAAOG,QAAP,EAAiB;IACtB,IAAI,OAAOH,GAAP,KAAe,UAAnB,EAA+B;MAC7BG,QAAQ,GAAGH,GAAX;MACAA,GAAG,GAAG,IAAN;IACD;;IAED,IAAIG,QAAQ,KAAK9B,SAAjB,EAA4B;MAC1B,OAAO,IAAI+B,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;QACtC,KAAKG,OAAL,CAAaT,GAAb,EAAkB,CAACA,GAAD,EAAMO,IAAN,KAAe;UAC/B,OAAOP,GAAG;UAAG;UAA+CM,MAAM,CAACN,GAAD,CAAxD,GAAgEK,OAAO,CAACE,IAAD,CAAjF;QACD,CAFD;MAGD,CAJM,CAAP;IAKD;;IAED,IAAI,OAAOJ,QAAP,KAAoB,UAAxB,EAAoC;MAClC,MAAM,IAAI/G,oBAAJ,CAAyB,kBAAzB,CAAN;IACD;;IAED,IAAI,KAAKgC,UAAL,CAAJ,EAAsB;MACpB,IAAI,KAAKI,YAAL,CAAJ,EAAwB;QACtB,KAAKA,YAAL,EAAmBkE,IAAnB,CAAwBS,QAAxB;MACD,CAFD,MAEO;QACLK,cAAc,CAAC,MAAML,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf,CAAd;MACD;;MACD;IACD;;IAED,IAAI,CAACH,GAAL,EAAU;MACRA,GAAG,GAAG,IAAIxG,oBAAJ,EAAN;IACD;;IAED,MAAMkH,QAAQ,GAAG,KAAK9F,MAAL,EAAa+F,MAAb,CAAoB,KAAKtF,WAAL,CAApB,CAAjB;;IACA,KAAK,IAAIuF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACzB,MAA7B,EAAqC2B,CAAC,EAAtC,EAA0C;MACxC,MAAMnB,OAAO,GAAGiB,QAAQ,CAACE,CAAD,CAAxB;MACAC,YAAY,CAAC,IAAD,EAAOpB,OAAP,EAAgBO,GAAhB,CAAZ;IACD;;IAED,KAAK7E,OAAL,IAAgB,IAAhB;IACA,KAAKC,UAAL,IAAmB,IAAnB;IACA,KAAKI,YAAL,EAAmBkE,IAAnB,CAAwBS,QAAxB;;IAEA,MAAMW,WAAW,GAAG,MAAM;MACxB,MAAMC,SAAS,GAAG,KAAKvF,YAAL,CAAlB;MACA,KAAKA,YAAL,IAAqB,IAArB;;MACA,KAAK,IAAIoF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGG,SAAS,CAAC9B,MAA9B,EAAsC2B,CAAC,EAAvC,EAA2C;QACzCG,SAAS,CAACH,CAAD,CAAT,CAAa,IAAb,EAAmB,IAAnB;MACD;IACF,CAND;;IAQA,IAAI,CAAC,KAAKlF,OAAL,CAAL,EAAoB;MAClB8E,cAAc,CAACM,WAAD,CAAd;IACD,CAFD,MAEO;MACLjI,IAAI,CAAC4H,OAAL,CAAa,KAAK/E,OAAL,EAAcsF,EAAd,CAAiB,OAAjB,EAA0BF,WAA1B,CAAb,EAAqDd,GAArD;IACD;;IAEDlB,MAAM,CAAC,IAAD,CAAN;EACD;;AAhU6B;;AAmUhC,MAAMmC,SAAS,GAAGtI,OAAO,CAAC,oBAAD,CAAzB;;AACA,MAAMuI,SAAS,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAlB;;AAEA,eAAeC,UAAf,GAA6B;EAC3B,MAAMC,cAAc,GAAGxB,OAAO,CAACyB,GAAR,CAAYC,cAAZ,GAA6B7I,OAAO,CAAC,yBAAD,CAApC,GAAkE0F,SAAzF;EAEA,IAAIoD,GAAJ;;EACA,IAAI;IACFA,GAAG,GAAG,MAAMC,WAAW,CAACC,OAAZ,CAAoBR,MAAM,CAACS,IAAP,CAAYjJ,OAAO,CAAC,8BAAD,CAAnB,EAAqD,QAArD,CAApB,CAAZ;EACD,CAFD,CAEE,OAAOkJ,CAAP,EAAU;IACV;IAEA;IACA;IACA;IACA;IACAJ,GAAG,GAAG,MAAMC,WAAW,CAACC,OAAZ,CAAoBR,MAAM,CAACS,IAAP,CAAYN,cAAc,IAAI3I,OAAO,CAAC,yBAAD,CAArC,EAAkE,QAAlE,CAApB,CAAZ;EACD;;EAED,OAAO,MAAM+I,WAAW,CAACI,WAAZ,CAAwBL,GAAxB,EAA6B;IACxCF,GAAG,EAAE;MACH;MAEAQ,WAAW,EAAE,CAACC,CAAD,EAAIC,EAAJ,EAAQC,GAAR,KAAgB;QAC3B;QACA,OAAO,CAAP;MACD,CANE;MAOHC,cAAc,EAAE,CAACH,CAAD,EAAIC,EAAJ,EAAQC,GAAR,KAAgB;QAC9BxJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,MAAMO,KAAK,GAAGN,EAAE,GAAGO,gBAAnB;QACA,MAAMC,GAAG,GAAGF,KAAK,GAAGL,GAApB;QACA,OAAOG,aAAa,CAACK,QAAd,CAAuBC,gBAAgB,CAACC,KAAjB,CAAuBL,KAAvB,EAA8BE,GAA9B,CAAvB,KAA8D,CAArE;MACD,CAZE;MAaHI,qBAAqB,EAAGb,CAAD,IAAO;QAC5BtJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,OAAOK,aAAa,CAACS,cAAd,MAAkC,CAAzC;MACD,CAhBE;MAiBHC,oBAAoB,EAAE,CAACf,CAAD,EAAIC,EAAJ,EAAQC,GAAR,KAAgB;QACpCxJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,MAAMO,KAAK,GAAGN,EAAE,GAAGO,gBAAnB;QACA,MAAMC,GAAG,GAAGF,KAAK,GAAGL,GAApB;QACA,OAAOG,aAAa,CAACW,aAAd,CAA4BL,gBAAgB,CAACC,KAAjB,CAAuBL,KAAvB,EAA8BE,GAA9B,CAA5B,KAAmE,CAA1E;MACD,CAtBE;MAuBHQ,oBAAoB,EAAE,CAACjB,CAAD,EAAIC,EAAJ,EAAQC,GAAR,KAAgB;QACpCxJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,MAAMO,KAAK,GAAGN,EAAE,GAAGO,gBAAnB;QACA,MAAMC,GAAG,GAAGF,KAAK,GAAGL,GAApB;QACA,OAAOG,aAAa,CAACa,aAAd,CAA4BP,gBAAgB,CAACC,KAAjB,CAAuBL,KAAvB,EAA8BE,GAA9B,CAA5B,KAAmE,CAA1E;MACD,CA5BE;MA6BHU,wBAAwB,EAAE,CAACnB,CAAD,EAAIoB,UAAJ,EAAgBC,OAAhB,EAAyBC,eAAzB,KAA6C;QACrE5K,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,OAAOK,aAAa,CAACkB,iBAAd,CAAgCH,UAAhC,EAA4CI,OAAO,CAACH,OAAD,CAAnD,EAA8DG,OAAO,CAACF,eAAD,CAArE,KAA2F,CAAlG;MACD,CAhCE;MAiCHG,YAAY,EAAE,CAACzB,CAAD,EAAIC,EAAJ,EAAQC,GAAR,KAAgB;QAC5BxJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,MAAMO,KAAK,GAAGN,EAAE,GAAGO,gBAAnB;QACA,MAAMC,GAAG,GAAGF,KAAK,GAAGL,GAApB;QACA,OAAOG,aAAa,CAACqB,MAAd,CAAqBf,gBAAgB,CAACC,KAAjB,CAAuBL,KAAvB,EAA8BE,GAA9B,CAArB,KAA4D,CAAnE;MACD,CAtCE;MAuCHkB,wBAAwB,EAAG3B,CAAD,IAAO;QAC/BtJ,MAAM,CAAC0J,WAAP,CAAmBC,aAAa,CAACC,GAAjC,EAAsCN,CAAtC;QACA,OAAOK,aAAa,CAACuB,iBAAd,MAAqC,CAA5C;MACD;MAED;;IA5CG;EADmC,CAA7B,CAAb;AAgDD;;AAED,IAAIC,cAAc,GAAG,IAArB;AACA,IAAIC,aAAa,GAAGzC,UAAU,GAC3B0C,KADiB,CACX,MAAM,CACX;AACD,CAHiB,CAApB;AAKA,IAAI1B,aAAa,GAAG,IAApB;AACA,IAAIM,gBAAgB,GAAG,IAAvB;AACA,IAAIqB,iBAAiB,GAAG,CAAxB;AACA,IAAIxB,gBAAgB,GAAG,IAAvB;AAEA,MAAMyB,eAAe,GAAG,CAAxB;AACA,MAAMC,YAAY,GAAG,CAArB;AACA,MAAMC,YAAY,GAAG,CAArB;;AAEA,MAAMC,MAAN,CAAa;EACXrH,WAAW,CAAEsH,MAAF,EAAUnF,MAAV,QAA+B;IAAA,IAAb;MAAEoF;IAAF,CAAa;IACxC5L,MAAM,CAAC4F,MAAM,CAACC,QAAP,CAAgB8F,MAAM,CAACzI,eAAD,CAAtB,KAA4CyI,MAAM,CAACzI,eAAD,CAAN,GAA0B,CAAvE,CAAN;IAEA,KAAK2I,MAAL,GAAcD,OAAd;IACA,KAAKhC,GAAL,GAAW,KAAKiC,MAAL,CAAYC,YAAZ,CAAyBvD,SAAS,CAACwD,IAAV,CAAeC,QAAxC,CAAX;IACA,KAAKL,MAAL,GAAcA,MAAd;IACA,KAAKnF,MAAL,GAAcA,MAAd;IACA,KAAKT,OAAL,GAAe,IAAf;IACA,KAAKkG,YAAL,GAAoB,IAApB;IACA,KAAKC,WAAL,GAAmB,IAAnB;IACA,KAAKxB,UAAL,GAAkB,IAAlB;IACA,KAAKyB,UAAL,GAAkB,EAAlB;IACA,KAAKxB,OAAL,GAAe,KAAf;IACA,KAAKyB,OAAL,GAAe,EAAf;IACA,KAAKC,WAAL,GAAmB,CAAnB;IACA,KAAKC,cAAL,GAAsBX,MAAM,CAACzI,eAAD,CAA5B;IACA,KAAK0H,eAAL,GAAuB,KAAvB;IACA,KAAK2B,MAAL,GAAc,KAAd;IACA,KAAKnG,MAAL,GAAc,KAAKA,MAAL,CAAYoG,IAAZ,CAAiB,IAAjB,CAAd;IAEA,KAAKC,SAAL,GAAiB,CAAjB;IAEA,KAAKC,OAAL,GAAe,EAAf;IACA,KAAK5H,SAAL,GAAiB,EAAjB;IACA,KAAK6H,aAAL,GAAqB,EAArB;EACD;;EAEDC,UAAU,CAAEzG,KAAF,EAAS0G,IAAT,EAAe;IACvB,KAAKX,WAAL,GAAmBW,IAAnB;;IACA,IAAI1G,KAAK,KAAK,KAAK8F,YAAnB,EAAiC;MAC/Ba,YAAY,CAAC,KAAK/G,OAAN,CAAZ;;MACA,IAAII,KAAJ,EAAW;QACT,KAAKJ,OAAL,GAAe6G,UAAU,CAACG,eAAD,EAAkB5G,KAAlB,EAAyB,IAAzB,CAAzB,CADS,CAET;;QACA,IAAI,KAAKJ,OAAL,CAAaiH,KAAjB,EAAwB;UACtB,KAAKjH,OAAL,CAAaiH,KAAb;QACD;MACF,CAND,MAMO;QACL,KAAKjH,OAAL,GAAe,IAAf;MACD;;MACD,KAAKkG,YAAL,GAAoB9F,KAApB;IACD,CAZD,MAYO,IAAI,KAAKJ,OAAT,EAAkB;MACvB;MACA,IAAI,KAAKA,OAAL,CAAakH,OAAjB,EAA0B;QACxB,KAAKlH,OAAL,CAAakH,OAAb;MACD;IACF;EACF;;EAED7G,MAAM,GAAI;IACR,IAAI,KAAKI,MAAL,CAAYH,SAAZ,IAAyB,CAAC,KAAKkG,MAAnC,EAA2C;MACzC;IACD;;IAEDvM,MAAM,CAAC,KAAK4J,GAAL,IAAY,IAAb,CAAN;IACA5J,MAAM,CAAC2J,aAAa,IAAI,IAAlB,CAAN;IAEA,KAAKkC,MAAL,CAAYqB,aAAZ,CAA0B,KAAKtD,GAA/B;IAEA5J,MAAM,CAAC,KAAKkM,WAAL,KAAqBV,YAAtB,CAAN;;IACA,IAAI,KAAKzF,OAAT,EAAkB;MAChB;MACA,IAAI,KAAKA,OAAL,CAAakH,OAAjB,EAA0B;QACxB,KAAKlH,OAAL,CAAakH,OAAb;MACD;IACF;;IAED,KAAKV,MAAL,GAAc,KAAd;IACA,KAAKY,OAAL,CAAa,KAAK3G,MAAL,CAAY4G,IAAZ,MAAsB5E,SAAnC,EAnBQ,CAmBsC;;IAC9C,KAAK6E,QAAL;EACD;;EAEDA,QAAQ,GAAI;IACV,OAAO,CAAC,KAAKd,MAAN,IAAgB,KAAK3C,GAA5B,EAAiC;MAC/B,MAAM0D,KAAK,GAAG,KAAK9G,MAAL,CAAY4G,IAAZ,EAAd;;MACA,IAAIE,KAAK,KAAK,IAAd,EAAoB;QAClB;MACD;;MACD,KAAKH,OAAL,CAAaG,KAAb;IACD;EACF;;EAEDH,OAAO,CAAEtF,IAAF,EAAQ;IACb7H,MAAM,CAAC,KAAK4J,GAAL,IAAY,IAAb,CAAN;IACA5J,MAAM,CAAC2J,aAAa,IAAI,IAAlB,CAAN;IACA3J,MAAM,CAAC,CAAC,KAAKuM,MAAP,CAAN;IAEA,MAAM;MAAE/F,MAAF;MAAUqF;IAAV,IAAqB,IAA3B;;IAEA,IAAIhE,IAAI,CAACtB,MAAL,GAAc+E,iBAAlB,EAAqC;MACnC,IAAIxB,gBAAJ,EAAsB;QACpB+B,MAAM,CAAC0B,IAAP,CAAYzD,gBAAZ;MACD;;MACDwB,iBAAiB,GAAGkC,IAAI,CAACC,IAAL,CAAU5F,IAAI,CAACtB,MAAL,GAAc,IAAxB,IAAgC,IAApD;MACAuD,gBAAgB,GAAG+B,MAAM,CAAC6B,MAAP,CAAcpC,iBAAd,CAAnB;IACD,CAbY,CAeb;;;IACA,IAAIqC,UAAJ,CAAe9B,MAAM,CAAC+B,MAAP,CAAcC,MAA7B,EAAqC/D,gBAArC,EAAuDwB,iBAAvD,EAA0EwC,GAA1E,CAA8EjG,IAA9E,EAhBa,CAkBb;IACA;IACA;IACA;;IACA,IAAI;MACF,IAAIkG,GAAJ;;MAEA,IAAI;QACF9D,gBAAgB,GAAGpC,IAAnB;QACA8B,aAAa,GAAG,IAAhB;QACAoE,GAAG,GAAGlC,MAAM,CAACmC,cAAP,CAAsB,KAAKpE,GAA3B,EAAgCE,gBAAhC,EAAkDjC,IAAI,CAACtB,MAAvD,CAAN;QACA;MACD,CALD,CAKE,OAAOe,GAAP,EAAY;QACZ;QACA,MAAMA,GAAN;MACD,CARD,SAQU;QACRqC,aAAa,GAAG,IAAhB;QACAM,gBAAgB,GAAG,IAAnB;MACD;;MAED,MAAMgE,MAAM,GAAGpC,MAAM,CAACqC,oBAAP,CAA4B,KAAKtE,GAAjC,IAAwCE,gBAAvD;;MAEA,IAAIiE,GAAG,KAAKxF,SAAS,CAAC4F,KAAV,CAAgBC,cAA5B,EAA4C;QAC1C,KAAKC,SAAL,CAAexG,IAAI,CAACqC,KAAL,CAAW+D,MAAX,CAAf;MACD,CAFD,MAEO,IAAIF,GAAG,KAAKxF,SAAS,CAAC4F,KAAV,CAAgBG,MAA5B,EAAoC;QACzC,KAAK/B,MAAL,GAAc,IAAd;QACA/F,MAAM,CAAC+H,OAAP,CAAe1G,IAAI,CAACqC,KAAL,CAAW+D,MAAX,CAAf;MACD,CAHM,MAGA,IAAIF,GAAG,KAAKxF,SAAS,CAAC4F,KAAV,CAAgBK,EAA5B,EAAgC;QACrC,MAAM5E,GAAG,GAAGiC,MAAM,CAAC4C,uBAAP,CAA+B,KAAK7E,GAApC,CAAZ;QACA,IAAI8E,OAAO,GAAG,EAAd;QACA;;QACA,IAAI9E,GAAJ,EAAS;UACP,MAAMJ,GAAG,GAAG,IAAImE,UAAJ,CAAe9B,MAAM,CAAC+B,MAAP,CAAcC,MAA7B,EAAqCjE,GAArC,EAA0C+E,OAA1C,CAAkD,CAAlD,CAAZ;UACAD,OAAO,GAAGjG,MAAM,CAACS,IAAP,CAAY2C,MAAM,CAAC+B,MAAP,CAAcC,MAA1B,EAAkCjE,GAAlC,EAAuCJ,GAAvC,EAA4CoF,QAA5C,EAAV;QACD;;QACD,MAAM,IAAIzN,eAAJ,CAAoBuN,OAApB,EAA6BnG,SAAS,CAAC4F,KAAV,CAAgBJ,GAAhB,CAA7B,EAAmDlG,IAAI,CAACqC,KAAL,CAAW+D,MAAX,CAAnD,CAAN;MACD;IACF,CAjCD,CAiCE,OAAO3G,GAAP,EAAY;MACZnH,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;IACD;EACF;;EAEDuH,MAAM,GAAI;IACR,IAAI;MACF,IAAI;QACFlF,aAAa,GAAG,IAAhB;QACA,KAAKkC,MAAL,CAAYiD,aAAZ,CAA0B,KAAKlF,GAA/B,EAFE,CAEkC;MACrC,CAHD,SAGU;QACRD,aAAa,GAAG,IAAhB;MACD;IACF,CAPD,CAOE,OAAOrC,GAAP,EAAY;MACZ;;MACA;MACAnH,IAAI,CAAC4H,OAAL,CAAa,KAAKvB,MAAlB,EAA0Bc,GAA1B;IACD;EACF;;EAEDS,OAAO,GAAI;IACT/H,MAAM,CAAC,KAAK4J,GAAL,IAAY,IAAb,CAAN;IACA5J,MAAM,CAAC2J,aAAa,IAAI,IAAlB,CAAN;IAEA,KAAKkC,MAAL,CAAYkD,WAAZ,CAAwB,KAAKnF,GAA7B;IACA,KAAKA,GAAL,GAAW,IAAX;IAEAkD,YAAY,CAAC,KAAK/G,OAAN,CAAZ;IACA,KAAKA,OAAL,GAAe,IAAf;IACA,KAAKkG,YAAL,GAAoB,IAApB;IACA,KAAKC,WAAL,GAAmB,IAAnB;IAEA,KAAKK,MAAL,GAAc,KAAd;EACD;;EAEDvC,QAAQ,CAAEgF,GAAF,EAAO;IACb,KAAK7C,UAAL,GAAkB6C,GAAG,CAACJ,QAAJ,EAAlB;EACD;;EAEDxE,cAAc,GAAI;IAChB,MAAM;MAAE5D,MAAF;MAAUmF;IAAV,IAAqB,IAA3B;IAEA;;IACA,IAAInF,MAAM,CAACH,SAAX,EAAsB;MACpB,OAAO,CAAC,CAAR;IACD;;IAED,MAAMU,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;;IACA,IAAI,CAACmE,OAAL,EAAc;MACZ,OAAO,CAAC,CAAR;IACD;EACF;;EAEDuD,aAAa,CAAE0E,GAAF,EAAO;IAClB,MAAMxF,GAAG,GAAG,KAAK4C,OAAL,CAAa7F,MAAzB;;IAEA,IAAI,CAACiD,GAAG,GAAG,CAAP,MAAc,CAAlB,EAAqB;MACnB,KAAK4C,OAAL,CAAapF,IAAb,CAAkBgI,GAAlB;IACD,CAFD,MAEO;MACL,KAAK5C,OAAL,CAAa5C,GAAG,GAAG,CAAnB,IAAwBf,MAAM,CAACwG,MAAP,CAAc,CAAC,KAAK7C,OAAL,CAAa5C,GAAG,GAAG,CAAnB,CAAD,EAAwBwF,GAAxB,CAAd,CAAxB;IACD;;IAED,KAAKE,WAAL,CAAiBF,GAAG,CAACzI,MAArB;EACD;;EAEDiE,aAAa,CAAEwE,GAAF,EAAO;IAClB,IAAIxF,GAAG,GAAG,KAAK4C,OAAL,CAAa7F,MAAvB;;IAEA,IAAI,CAACiD,GAAG,GAAG,CAAP,MAAc,CAAlB,EAAqB;MACnB,KAAK4C,OAAL,CAAapF,IAAb,CAAkBgI,GAAlB;MACAxF,GAAG,IAAI,CAAP;IACD,CAHD,MAGO;MACL,KAAK4C,OAAL,CAAa5C,GAAG,GAAG,CAAnB,IAAwBf,MAAM,CAACwG,MAAP,CAAc,CAAC,KAAK7C,OAAL,CAAa5C,GAAG,GAAG,CAAnB,CAAD,EAAwBwF,GAAxB,CAAd,CAAxB;IACD;;IAED,MAAMG,GAAG,GAAG,KAAK/C,OAAL,CAAa5C,GAAG,GAAG,CAAnB,CAAZ;;IACA,IAAI2F,GAAG,CAAC5I,MAAJ,KAAe,EAAf,IAAqB4I,GAAG,CAACP,QAAJ,GAAeQ,WAAf,OAAiC,YAA1D,EAAwE;MACtE,KAAKtK,SAAL,IAAkBkK,GAAG,CAACJ,QAAJ,EAAlB;IACD,CAFD,MAEO,IAAIO,GAAG,CAAC5I,MAAJ,KAAe,CAAf,IAAoB4I,GAAG,CAACP,QAAJ,GAAeQ,WAAf,OAAiC,SAAzD,EAAoE;MACzE,KAAK1C,OAAL,IAAgBsC,GAAG,CAACJ,QAAJ,EAAhB;IACD,CAFM,MAEA,IAAIO,GAAG,CAAC5I,MAAJ,KAAe,EAAf,IAAqB4I,GAAG,CAACP,QAAJ,GAAeQ,WAAf,OAAiC,gBAA1D,EAA4E;MACjF,KAAKzC,aAAL,IAAsBqC,GAAG,CAACJ,QAAJ,EAAtB;IACD;;IAED,KAAKM,WAAL,CAAiBF,GAAG,CAACzI,MAArB;EACD;;EAED2I,WAAW,CAAE1F,GAAF,EAAO;IAChB,KAAK6C,WAAL,IAAoB7C,GAApB;;IACA,IAAI,KAAK6C,WAAL,IAAoB,KAAKC,cAA7B,EAA6C;MAC3CnM,IAAI,CAAC4H,OAAL,CAAa,KAAKvB,MAAlB,EAA0B,IAAI3F,oBAAJ,EAA1B;IACD;EACF;;EAEDwN,SAAS,CAAEgB,IAAF,EAAQ;IACf,MAAM;MAAE1E,OAAF;MAAWgB,MAAX;MAAmBnF,MAAnB;MAA2B4F,OAA3B;MAAoC1B;IAApC,IAAmD,IAAzD;IAEA1K,MAAM,CAAC2K,OAAD,CAAN;IAEA,MAAM5D,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;IACA5C,MAAM,CAAC+G,OAAD,CAAN;IAEA/G,MAAM,CAAC,CAACwG,MAAM,CAACH,SAAT,CAAN;IACArG,MAAM,CAACwG,MAAM,KAAKmF,MAAM,CAAC3I,OAAD,CAAlB,CAAN;IACAhD,MAAM,CAAC,CAAC,KAAKuM,MAAP,CAAN;IACAvM,MAAM,CAAC+G,OAAO,CAAC4D,OAAR,IAAmB5D,OAAO,CAACuI,MAAR,KAAmB,SAAvC,CAAN;IAEA,KAAK5E,UAAL,GAAkB,IAAlB;IACA,KAAKyB,UAAL,GAAkB,EAAlB;IACA,KAAKvB,eAAL,GAAuB,IAAvB;IAEA5K,MAAM,CAAC,KAAKoM,OAAL,CAAa7F,MAAb,GAAsB,CAAtB,KAA4B,CAA7B,CAAN;IACA,KAAK6F,OAAL,GAAe,EAAf;IACA,KAAKC,WAAL,GAAmB,CAAnB;IAEA7F,MAAM,CAAC+H,OAAP,CAAec,IAAf;IAEA7I,MAAM,CAAC9E,OAAD,CAAN,CAAgBqG,OAAhB;IACAvB,MAAM,CAAC9E,OAAD,CAAN,GAAkB,IAAlB;IAEA8E,MAAM,CAAChF,OAAD,CAAN,GAAkB,IAAlB;IACAgF,MAAM,CAAC3D,MAAD,CAAN,GAAiB,IAAjB;IACA2D,MAAM,CACH+I,cADH,CACkB,OADlB,EAC2BC,aAD3B,EAEGD,cAFH,CAEkB,UAFlB,EAE8BE,gBAF9B,EAGGF,cAHH,CAGkB,KAHlB,EAGyBG,WAHzB,EAIGH,cAJH,CAIkB,OAJlB,EAI2BI,aAJ3B;IAMAhE,MAAM,CAAC3I,OAAD,CAAN,GAAkB,IAAlB;IACA2I,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAAN,EAAf,IAAwC,IAAxC;IACA+I,MAAM,CAACiE,IAAP,CAAY,YAAZ,EAA0BjE,MAAM,CAACtK,IAAD,CAAhC,EAAwC,CAACsK,MAAD,CAAxC,EAAkD,IAAI1K,kBAAJ,CAAuB,SAAvB,CAAlD;;IAEA,IAAI;MACF8F,OAAO,CAACsH,SAAR,CAAkB3D,UAAlB,EAA8B0B,OAA9B,EAAuC5F,MAAvC;IACD,CAFD,CAEE,OAAOc,GAAP,EAAY;MACZnH,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;IACD;;IAEDlB,MAAM,CAACuF,MAAD,CAAN;EACD;;EAEDd,iBAAiB,CAAEH,UAAF,EAAcC,OAAd,EAAuBC,eAAvB,EAAwC;IACvD,MAAM;MAAEe,MAAF;MAAUnF,MAAV;MAAkB4F,OAAlB;MAA2BD;IAA3B,IAA0C,IAAhD;IAEA;;IACA,IAAI3F,MAAM,CAACH,SAAX,EAAsB;MACpB,OAAO,CAAC,CAAR;IACD;;IAED,MAAMU,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;IAEA;;IACA,IAAI,CAACmE,OAAL,EAAc;MACZ,OAAO,CAAC,CAAR;IACD,CAbsD,CAevD;;;IAEA/G,MAAM,CAAC,CAAC,KAAK2K,OAAP,CAAN;IACA3K,MAAM,CAAC,KAAK0K,UAAL,GAAkB,GAAnB,CAAN,CAlBuD,CAoBvD;;IAEA,IAAIA,UAAU,KAAK,GAAnB,EAAwB;MACtBvK,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIxF,WAAJ,CAAgB,cAAhB,EAAgCb,IAAI,CAAC0P,aAAL,CAAmBrJ,MAAnB,CAAhC,CAArB;MACA,OAAO,CAAC,CAAR;IACD;IAED;;;IACA,IAAImE,OAAO,IAAI,CAAC5D,OAAO,CAAC4D,OAAxB,EAAiC;MAC/BxK,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIxF,WAAJ,CAAgB,aAAhB,EAA+Bb,IAAI,CAAC0P,aAAL,CAAmBrJ,MAAnB,CAA/B,CAArB;MACA,OAAO,CAAC,CAAR;IACD;;IAEDxG,MAAM,CAAC0J,WAAP,CAAmB,KAAKwC,WAAxB,EAAqCX,eAArC;IAEA,KAAKb,UAAL,GAAkBA,UAAlB;IACA,KAAKE,eAAL,GAAuBA,eAAvB;;IAEA,IAAI,KAAKF,UAAL,IAAmB,GAAvB,EAA4B;MAC1B,MAAM9F,WAAW,GAAGmC,OAAO,CAACnC,WAAR,IAAuB,IAAvB,GAChBmC,OAAO,CAACnC,WADQ,GAEhB+G,MAAM,CAACrI,YAAD,CAFV;MAGA,KAAKsJ,UAAL,CAAgBhI,WAAhB,EAA6B4G,YAA7B;IACD,CALD,MAKO,IAAI,KAAKzF,OAAT,EAAkB;MACvB;MACA,IAAI,KAAKA,OAAL,CAAakH,OAAjB,EAA0B;QACxB,KAAKlH,OAAL,CAAakH,OAAb;MACD;IACF;;IAED,IAAIlG,OAAO,CAACuI,MAAR,KAAmB,SAAnB,IAAgC5E,UAAU,IAAI,GAA9C,IAAqDA,UAAU,GAAG,GAAtE,EAA2E;MACzE1K,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAAtB,CAAN;MACA,KAAK6I,OAAL,GAAe,IAAf;MACA,OAAO,CAAP;IACD;;IAED,IAAIA,OAAJ,EAAa;MACX3K,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAAtB,CAAN;MACA,KAAK6I,OAAL,GAAe,IAAf;MACA,OAAO,CAAP;IACD;;IAED3K,MAAM,CAAC,KAAKoM,OAAL,CAAa7F,MAAb,GAAsB,CAAtB,KAA4B,CAA7B,CAAN;IACA,KAAK6F,OAAL,GAAe,EAAf;IACA,KAAKC,WAAL,GAAmB,CAAnB;;IAEA,IAAIzB,eAAe,IAAIe,MAAM,CAAC5I,WAAD,CAA7B,EAA4C;MAC1C,MAAMgC,gBAAgB,GAAG,KAAKD,SAAL,GAAiB3E,IAAI,CAAC2P,qBAAL,CAA2B,KAAKhL,SAAhC,CAAjB,GAA8D,IAAvF;;MAEA,IAAIC,gBAAgB,IAAI,IAAxB,EAA8B;QAC5B,MAAMgB,OAAO,GAAGyH,IAAI,CAACuC,GAAL,CACdhL,gBAAgB,GAAG4G,MAAM,CAACvI,0BAAD,CADX,EAEduI,MAAM,CAACxI,oBAAD,CAFQ,CAAhB;;QAIA,IAAI4C,OAAO,IAAI,CAAf,EAAkB;UAChBS,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;QACD,CAFD,MAEO;UACLqK,MAAM,CAAC1I,sBAAD,CAAN,GAAiC8C,OAAjC;QACD;MACF,CAVD,MAUO;QACL4F,MAAM,CAAC1I,sBAAD,CAAN,GAAiC0I,MAAM,CAACpJ,wBAAD,CAAvC;MACD;IACF,CAhBD,MAgBO;MACL;MACAiE,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;IACD;;IAED,IAAI0O,KAAJ;;IACA,IAAI;MACFA,KAAK,GAAGjJ,OAAO,CAACkJ,SAAR,CAAkBvF,UAAlB,EAA8B0B,OAA9B,EAAuC,KAAKhG,MAA5C,EAAoD+F,UAApD,MAAoE,KAA5E;IACD,CAFD,CAEE,OAAO7E,GAAP,EAAY;MACZnH,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;MACA,OAAO,CAAC,CAAR;IACD;;IAED,IAAIP,OAAO,CAACuI,MAAR,KAAmB,MAAvB,EAA+B;MAC7BtP,MAAM,CAACwG,MAAM,CAAClF,MAAD,CAAP,CAAN;MACA,OAAO,CAAP;IACD;;IAED,IAAIoJ,UAAU,GAAG,GAAjB,EAAsB;MACpB,OAAO,CAAP;IACD;;IAED,IAAIlE,MAAM,CAAC5E,SAAD,CAAV,EAAuB;MACrB4E,MAAM,CAAC5E,SAAD,CAAN,GAAoB,KAApB;MACAwE,MAAM,CAACuF,MAAD,CAAN;IACD;;IAED,OAAOqE,KAAK,GAAGzH,SAAS,CAAC4F,KAAV,CAAgBG,MAAnB,GAA4B,CAAxC;EACD;;EAEDtD,MAAM,CAAEgE,GAAF,EAAO;IACX,MAAM;MAAErD,MAAF;MAAUnF,MAAV;MAAkBkE;IAAlB,IAAiC,IAAvC;;IAEA,IAAIlE,MAAM,CAACH,SAAX,EAAsB;MACpB,OAAO,CAAC,CAAR;IACD;;IAED,MAAMU,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;IACA5C,MAAM,CAAC+G,OAAD,CAAN;IAEA/G,MAAM,CAAC0J,WAAP,CAAmB,KAAKwC,WAAxB,EAAqCV,YAArC;;IACA,IAAI,KAAKzF,OAAT,EAAkB;MAChB;MACA,IAAI,KAAKA,OAAL,CAAakH,OAAjB,EAA0B;QACxB,KAAKlH,OAAL,CAAakH,OAAb;MACD;IACF;;IAEDjN,MAAM,CAAC0K,UAAU,IAAI,GAAf,CAAN;IAEA,KAAK+B,SAAL,IAAkBuC,GAAG,CAACzI,MAAtB;;IAEA,IAAI;MACF,IAAIQ,OAAO,CAACmJ,MAAR,CAAelB,GAAf,MAAwB,KAA5B,EAAmC;QACjC,OAAOzG,SAAS,CAAC4F,KAAV,CAAgBG,MAAvB;MACD;IACF,CAJD,CAIE,OAAOhH,GAAP,EAAY;MACZnH,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;MACA,OAAO,CAAC,CAAR;IACD;EACF;;EAED4D,iBAAiB,GAAI;IACnB,MAAM;MAAES,MAAF;MAAUnF,MAAV;MAAkBkE,UAAlB;MAA8BC,OAA9B;MAAuC+B,OAAvC;MAAgDN,OAAhD;MAAyDO,aAAzD;MAAwEF,SAAxE;MAAmF7B;IAAnF,IAAuG,IAA7G;;IAEA,IAAIpE,MAAM,CAACH,SAAP,KAAqB,CAACqE,UAAD,IAAeE,eAApC,CAAJ,EAA0D;MACxD,OAAO,CAAC,CAAR;IACD;;IAED,IAAID,OAAJ,EAAa;MACX;IACD;;IAED,MAAM5D,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;IACA5C,MAAM,CAAC+G,OAAD,CAAN;IAEA/G,MAAM,CAAC0K,UAAU,IAAI,GAAf,CAAN;IAEA,KAAKA,UAAL,GAAkB,IAAlB;IACA,KAAKyB,UAAL,GAAkB,EAAlB;IACA,KAAKM,SAAL,GAAiB,CAAjB;IACA,KAAKE,aAAL,GAAqB,EAArB;IACA,KAAKD,OAAL,GAAe,EAAf;IACA,KAAK5H,SAAL,GAAiB,EAAjB;IAEA9E,MAAM,CAAC,KAAKoM,OAAL,CAAa7F,MAAb,GAAsB,CAAtB,KAA4B,CAA7B,CAAN;IACA,KAAK6F,OAAL,GAAe,EAAf;IACA,KAAKC,WAAL,GAAmB,CAAnB;;IAEA,IAAI3B,UAAU,GAAG,GAAjB,EAAsB;MACpB;IACD;;IAED,MAAMyF,QAAQ,GAAGzD,OAAO,GAAGA,OAAO,CAAC0D,KAAR,CAAc,MAAd,CAAH,GAA2B,EAAnD;;IACA,KAAK,IAAIlI,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGiI,QAAQ,CAAC5J,MAA7B,EAAqC2B,CAAC,EAAtC,EAA0C;MACxC,MAAMwE,OAAO,GAAGyD,QAAQ,CAACjI,CAAD,CAAxB;MACA,IAAImI,KAAK,GAAG,KAAZ;;MACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGlE,OAAO,CAAC7F,MAA5B,EAAoC+J,CAAC,IAAI,CAAzC,EAA4C;QAC1C,MAAMnB,GAAG,GAAG/C,OAAO,CAACkE,CAAD,CAAnB;;QACA,IAAInB,GAAG,CAAC5I,MAAJ,KAAemG,OAAO,CAACnG,MAAvB,IAAiC4I,GAAG,CAACP,QAAJ,GAAeQ,WAAf,OAAiC1C,OAAO,CAAC0C,WAAR,EAAtE,EAA6F;UAC3FiB,KAAK,GAAG,IAAR;UACA;QACD;MACF;;MACD,IAAI,CAACA,KAAL,EAAY;QACVlQ,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAI/F,oBAAJ,EAArB;QACA,OAAO,CAAC,CAAR;MACD;IACF;IAED;;;IACA,IAAIsG,OAAO,CAACuI,MAAR,KAAmB,MAAnB,IAA6B3C,aAA7B,IAA8CF,SAAS,KAAK8D,QAAQ,CAAC5D,aAAD,EAAgB,EAAhB,CAAxE,EAA6F;MAC3FxM,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIhG,kCAAJ,EAArB;MACA,OAAO,CAAC,CAAR;IACD;;IAED,IAAI;MACFuG,OAAO,CAACyJ,UAAR,CAAmBpE,OAAnB;IACD,CAFD,CAEE,OAAO9E,GAAP,EAAY;MACZa,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;IACD;;IAEDqE,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAAN,EAAf,IAAwC,IAAxC;;IAEA,IAAI4D,MAAM,CAACvE,QAAD,CAAV,EAAsB;MACpBjC,MAAM,CAAC0J,WAAP,CAAmBiC,MAAM,CAAC7J,QAAD,CAAzB,EAAqC,CAArC,EADoB,CAEpB;;MACA3B,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,OAAvB,CAArB;MACA,OAAOsH,SAAS,CAAC4F,KAAV,CAAgBG,MAAvB;IACD,CALD,MAKO,IAAI,CAAC1D,eAAL,EAAsB;MAC3B;MACAzK,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,OAAvB,CAArB;MACA,OAAOsH,SAAS,CAAC4F,KAAV,CAAgBG,MAAvB;IACD,CAJM,MAIA,IAAI9H,MAAM,CAAClF,MAAD,CAAN,IAAkBqK,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAA3C,EAA8C;MACnD;MACA;MACA;MACA;MACA3B,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,OAAvB,CAArB;MACA,OAAOsH,SAAS,CAAC4F,KAAV,CAAgBG,MAAvB;IACD,CAPM,MAOA;MACLlI,MAAM,CAACuF,MAAD,CAAN;IACD;EACF;;AAxfU;;AA2fb,SAASoB,eAAT,CAA0B0D,MAA1B,EAAkC;EAChC,MAAM;IAAEjK,MAAF;IAAU0F,WAAV;IAAuBP;EAAvB,IAAkC8E,MAAxC;EAEA;;EACA,IAAIvE,WAAW,KAAKX,eAApB,EAAqC;IACnC,IAAI,CAAC/E,MAAM,CAACvE,QAAD,CAAX,EAAuB;MACrBjC,MAAM,CAAC,CAACyQ,MAAM,CAAClE,MAAT,EAAiB,4CAAjB,CAAN;MACApM,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAI5F,mBAAJ,EAArB;IACD;EACF,CALD,MAKO,IAAIsL,WAAW,KAAKV,YAApB,EAAkC;IACvC,IAAI,CAACiF,MAAM,CAAClE,MAAZ,EAAoB;MAClBpM,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAItF,gBAAJ,EAArB;IACD;EACF,CAJM,MAIA,IAAIgL,WAAW,KAAKT,YAApB,EAAkC;IACvCzL,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAArB,IAA0B6J,MAAM,CAAC1I,sBAAD,CAAjC,CAAN;IACA9C,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,qBAAvB,CAArB;EACD;AACF;;AAED,SAASwO,gBAAT,GAA6B;EAC3B,MAAM;IAAE,CAAC/N,OAAD,GAAW+O;EAAb,IAAwB,IAA9B;EACAA,MAAM,CAACpD,QAAP;AACD;;AAED,SAASmC,aAAT,CAAwBlI,GAAxB,EAA6B;EAC3B,MAAM;IAAE,CAAC5F,OAAD,GAAW+O;EAAb,IAAwB,IAA9B;EAEAzQ,MAAM,CAACsH,GAAG,CAACoJ,IAAJ,KAAa,8BAAd,CAAN,CAH2B,CAK3B;EACA;;EACA,IAAIpJ,GAAG,CAACoJ,IAAJ,KAAa,YAAb,IAA6BD,MAAM,CAAC/F,UAApC,IAAkD,CAAC+F,MAAM,CAAC7F,eAA9D,EAA+E;IAC7E;IACA6F,MAAM,CAAC5B,MAAP;IACA;EACD;;EAED,KAAKhM,MAAL,IAAeyE,GAAf;EAEAC,OAAO,CAAC,KAAK/F,OAAL,CAAD,EAAgB8F,GAAhB,CAAP;AACD;;AAED,SAASC,OAAT,CAAkBoE,MAAlB,EAA0BrE,GAA1B,EAA+B;EAC7B,IACEqE,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAArB,IACAwF,GAAG,CAACoJ,IAAJ,KAAa,cADb,IAEApJ,GAAG,CAACoJ,IAAJ,KAAa,gBAHf,EAIE;IACA;IACA;IAEA1Q,MAAM,CAAC2L,MAAM,CAAChJ,WAAD,CAAN,KAAwBgJ,MAAM,CAAC/I,WAAD,CAA/B,CAAN;IAEA,MAAMoF,QAAQ,GAAG2D,MAAM,CAACzJ,MAAD,CAAN,CAAe+F,MAAf,CAAsB0D,MAAM,CAAC/I,WAAD,CAA5B,CAAjB;;IACA,KAAK,IAAIsF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACzB,MAA7B,EAAqC2B,CAAC,EAAtC,EAA0C;MACxC,MAAMnB,OAAO,GAAGiB,QAAQ,CAACE,CAAD,CAAxB;MACAC,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;IACD;;IACDtH,MAAM,CAAC2L,MAAM,CAAC3J,KAAD,CAAN,KAAkB,CAAnB,CAAN;EACD;AACF;;AAED,SAAS0N,WAAT,GAAwB;EACtB,MAAM;IAAE,CAAChO,OAAD,GAAW+O;EAAb,IAAwB,IAA9B;;EAEA,IAAIA,MAAM,CAAC/F,UAAP,IAAqB,CAAC+F,MAAM,CAAC7F,eAAjC,EAAkD;IAChD;IACA6F,MAAM,CAAC5B,MAAP;IACA;EACD;;EAED1O,IAAI,CAAC4H,OAAL,CAAa,IAAb,EAAmB,IAAI/G,WAAJ,CAAgB,mBAAhB,EAAqCb,IAAI,CAAC0P,aAAL,CAAmB,IAAnB,CAArC,CAAnB;AACD;;AAED,SAASF,aAAT,GAA0B;EACxB,MAAM;IAAE,CAACnO,OAAD,GAAWmK;EAAb,IAAwB,IAA9B;EAEA,KAAKjK,OAAL,EAAcqG,OAAd;EACA,KAAKrG,OAAL,IAAgB,IAAhB;EAEA,MAAM4F,GAAG,GAAG,KAAKzE,MAAL,KAAgB,IAAI7B,WAAJ,CAAgB,QAAhB,EAA0Bb,IAAI,CAAC0P,aAAL,CAAmB,IAAnB,CAA1B,CAA5B;EAEAlE,MAAM,CAAC3I,OAAD,CAAN,GAAkB,IAAlB;;EAEA,IAAI2I,MAAM,CAACjJ,UAAD,CAAV,EAAwB;IACtB1C,MAAM,CAAC2L,MAAM,CAAC5J,QAAD,CAAN,KAAqB,CAAtB,CAAN,CADsB,CAGtB;;IACA,MAAMiG,QAAQ,GAAG2D,MAAM,CAACzJ,MAAD,CAAN,CAAe+F,MAAf,CAAsB0D,MAAM,CAAC/I,WAAD,CAA5B,CAAjB;;IACA,KAAK,IAAIsF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,QAAQ,CAACzB,MAA7B,EAAqC2B,CAAC,EAAtC,EAA0C;MACxC,MAAMnB,OAAO,GAAGiB,QAAQ,CAACE,CAAD,CAAxB;MACAC,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;IACD;EACF,CATD,MASO,IAAIqE,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAnB,IAAwBwF,GAAG,CAACoJ,IAAJ,KAAa,cAAzC,EAAyD;IAC9D;IACA,MAAM3J,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;IACA+I,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAAN,EAAf,IAAwC,IAAxC;IAEAuF,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;EACD;;EAEDqE,MAAM,CAAChJ,WAAD,CAAN,GAAsBgJ,MAAM,CAAC/I,WAAD,CAA5B;EAEA5C,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAAtB,CAAN;EAEA6J,MAAM,CAACiE,IAAP,CAAY,YAAZ,EAA0BjE,MAAM,CAACtK,IAAD,CAAhC,EAAwC,CAACsK,MAAD,CAAxC,EAAkDrE,GAAlD;EAEAlB,MAAM,CAACuF,MAAD,CAAN;AACD;;AAED,eAAelG,OAAf,CAAwBkG,MAAxB,EAAgC;EAC9B3L,MAAM,CAAC,CAAC2L,MAAM,CAACvJ,WAAD,CAAR,CAAN;EACApC,MAAM,CAAC,CAAC2L,MAAM,CAAC3I,OAAD,CAAR,CAAN;EAEA,IAAI;IAAE2N,IAAF;IAAQ1K,QAAR;IAAkB2K,QAAlB;IAA4B1K;EAA5B,IAAqCyF,MAAM,CAACtK,IAAD,CAA/C,CAJ8B,CAM9B;;EACA,IAAI4E,QAAQ,CAAC,CAAD,CAAR,KAAgB,GAApB,EAAyB;IACvB,MAAM4K,GAAG,GAAG5K,QAAQ,CAAC0I,OAAT,CAAiB,GAAjB,CAAZ;IAEA3O,MAAM,CAAC6Q,GAAG,KAAK,CAAC,CAAV,CAAN;IACA,MAAMC,EAAE,GAAG7K,QAAQ,CAAC8K,MAAT,CAAgB,CAAhB,EAAmBF,GAAG,GAAG,CAAzB,CAAX;IAEA7Q,MAAM,CAACE,GAAG,CAAC8Q,IAAJ,CAASF,EAAT,CAAD,CAAN;IACA7K,QAAQ,GAAG6K,EAAX;EACD;;EAEDnF,MAAM,CAACvJ,WAAD,CAAN,GAAsB,IAAtB;;EAEA,IAAIwB,QAAQ,CAACI,aAAT,CAAuBG,cAA3B,EAA2C;IACzCP,QAAQ,CAACI,aAAT,CAAuBiN,OAAvB,CAA+B;MAC7BC,aAAa,EAAE;QACbP,IADa;QAEb1K,QAFa;QAGb2K,QAHa;QAIb1K,IAJa;QAKbiL,UAAU,EAAExF,MAAM,CAACpK,WAAD;MALL,CADc;MAQ7B6P,SAAS,EAAEzF,MAAM,CAACnI,UAAD;IARY,CAA/B;EAUD;;EAED,IAAI;IACF,MAAMgD,MAAM,GAAG,MAAM,IAAIkB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;MACpD+D,MAAM,CAACnI,UAAD,CAAN,CAAmB;QACjBmN,IADiB;QAEjB1K,QAFiB;QAGjB2K,QAHiB;QAIjB1K,IAJiB;QAKjBiL,UAAU,EAAExF,MAAM,CAACpK,WAAD;MALD,CAAnB,EAMG,CAAC+F,GAAD,EAAMd,MAAN,KAAiB;QAClB,IAAIc,GAAJ,EAAS;UACPM,MAAM,CAACN,GAAD,CAAN;QACD,CAFD,MAEO;UACLK,OAAO,CAACnB,MAAD,CAAP;QACD;MACF,CAZD;IAaD,CAdoB,CAArB;;IAgBA,IAAI,CAAC2E,cAAL,EAAqB;MACnBA,cAAc,GAAG,MAAMC,aAAvB;MACAA,aAAa,GAAG,IAAhB;IACD;;IAEDO,MAAM,CAACvJ,WAAD,CAAN,GAAsB,KAAtB;IAEApC,MAAM,CAACwG,MAAD,CAAN;IAEAmF,MAAM,CAAC3I,OAAD,CAAN,GAAkBwD,MAAlB;IAEAA,MAAM,CAAClE,MAAD,CAAN,GAAiB,KAAjB;IACAkE,MAAM,CAACvE,QAAD,CAAN,GAAmB,KAAnB;IACAuE,MAAM,CAAClF,MAAD,CAAN,GAAiB,KAAjB;IACAkF,MAAM,CAAC5E,SAAD,CAAN,GAAoB,KAApB;IACA4E,MAAM,CAAC3D,MAAD,CAAN,GAAiB,IAAjB;IACA2D,MAAM,CAAC9E,OAAD,CAAN,GAAkB,IAAIgK,MAAJ,CAAWC,MAAX,EAAmBnF,MAAnB,EAA2B2E,cAA3B,CAAlB;IACA3E,MAAM,CAAChF,OAAD,CAAN,GAAkBmK,MAAlB;IACAnF,MAAM,CAAC7C,QAAD,CAAN,GAAmB,CAAnB;IACA6C,MAAM,CAAC9C,YAAD,CAAN,GAAuBiI,MAAM,CAACjI,YAAD,CAA7B;IACA8C,MAAM,CACH8B,EADH,CACM,OADN,EACekH,aADf,EAEGlH,EAFH,CAEM,UAFN,EAEkBmH,gBAFlB,EAGGnH,EAHH,CAGM,KAHN,EAGaoH,WAHb,EAIGpH,EAJH,CAIM,OAJN,EAIeqH,aAJf;;IAMA,IAAI/L,QAAQ,CAACM,SAAT,CAAmBC,cAAvB,EAAuC;MACrCP,QAAQ,CAACM,SAAT,CAAmB+M,OAAnB,CAA2B;QACzBC,aAAa,EAAE;UACbP,IADa;UAEb1K,QAFa;UAGb2K,QAHa;UAIb1K,IAJa;UAKbiL,UAAU,EAAExF,MAAM,CAACpK,WAAD;QALL,CADU;QAQzB6P,SAAS,EAAEzF,MAAM,CAACnI,UAAD,CARQ;QASzBgD;MATyB,CAA3B;IAWD;;IACDmF,MAAM,CAACiE,IAAP,CAAY,SAAZ,EAAuBjE,MAAM,CAACtK,IAAD,CAA7B,EAAqC,CAACsK,MAAD,CAArC;EACD,CAzDD,CAyDE,OAAOrE,GAAP,EAAY;IACZqE,MAAM,CAACvJ,WAAD,CAAN,GAAsB,KAAtB;;IAEA,IAAIwB,QAAQ,CAACK,YAAT,CAAsBE,cAA1B,EAA0C;MACxCP,QAAQ,CAACK,YAAT,CAAsBgN,OAAtB,CAA8B;QAC5BC,aAAa,EAAE;UACbP,IADa;UAEb1K,QAFa;UAGb2K,QAHa;UAIb1K,IAJa;UAKbiL,UAAU,EAAExF,MAAM,CAACpK,WAAD;QALL,CADa;QAQ5B6P,SAAS,EAAEzF,MAAM,CAACnI,UAAD,CARW;QAS5B6N,KAAK,EAAE/J;MATqB,CAA9B;IAWD;;IAED,IAAIA,GAAG,CAACoJ,IAAJ,KAAa,8BAAjB,EAAiD;MAC/C1Q,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAAtB,CAAN;;MACA,OAAO6J,MAAM,CAAC5J,QAAD,CAAN,GAAmB,CAAnB,IAAwB4J,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAChJ,WAAD,CAArB,EAAoCwO,UAApC,KAAmDxF,MAAM,CAACpK,WAAD,CAAxF,EAAuG;QACrG,MAAMwF,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAChJ,WAAD,CAAN,EAAf,CAAhB;QACAwF,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;MACD;IACF,CAND,MAMO;MACLC,OAAO,CAACoE,MAAD,EAASrE,GAAT,CAAP;IACD;;IAEDqE,MAAM,CAACiE,IAAP,CAAY,iBAAZ,EAA+BjE,MAAM,CAACtK,IAAD,CAArC,EAA6C,CAACsK,MAAD,CAA7C,EAAuDrE,GAAvD;EACD;;EAEDlB,MAAM,CAACuF,MAAD,CAAN;AACD;;AAED,SAAS2F,SAAT,CAAoB3F,MAApB,EAA4B;EAC1BA,MAAM,CAACtJ,UAAD,CAAN,GAAqB,CAArB;EACAsJ,MAAM,CAACiE,IAAP,CAAY,OAAZ,EAAqBjE,MAAM,CAACtK,IAAD,CAA3B,EAAmC,CAACsK,MAAD,CAAnC;AACD;;AAED,SAASvF,MAAT,CAAiBuF,MAAjB,EAAyB4F,IAAzB,EAA+B;EAC7B,IAAI5F,MAAM,CAAC9J,SAAD,CAAN,KAAsB,CAA1B,EAA6B;IAC3B;EACD;;EAED8J,MAAM,CAAC9J,SAAD,CAAN,GAAoB,CAApB;;EAEA2P,OAAO,CAAC7F,MAAD,EAAS4F,IAAT,CAAP;;EACA5F,MAAM,CAAC9J,SAAD,CAAN,GAAoB,CAApB;;EAEA,IAAI8J,MAAM,CAAC/I,WAAD,CAAN,GAAsB,GAA1B,EAA+B;IAC7B+I,MAAM,CAACzJ,MAAD,CAAN,CAAe+F,MAAf,CAAsB,CAAtB,EAAyB0D,MAAM,CAAC/I,WAAD,CAA/B;IACA+I,MAAM,CAAChJ,WAAD,CAAN,IAAuBgJ,MAAM,CAAC/I,WAAD,CAA7B;IACA+I,MAAM,CAAC/I,WAAD,CAAN,GAAsB,CAAtB;EACD;AACF;;AAED,SAAS4O,OAAT,CAAkB7F,MAAlB,EAA0B4F,IAA1B,EAAgC;EAC9B,OAAO,IAAP,EAAa;IACX,IAAI5F,MAAM,CAACjJ,UAAD,CAAV,EAAwB;MACtB1C,MAAM,CAAC2L,MAAM,CAAC5J,QAAD,CAAN,KAAqB,CAAtB,CAAN;MACA;IACD;;IAED,IAAI4J,MAAM,CAAClJ,OAAD,CAAN,IAAmB,CAACkJ,MAAM,CAAC3J,KAAD,CAA9B,EAAuC;MACrC2J,MAAM,CAAC5D,OAAP,CAAe5H,IAAI,CAACsR,GAApB;MACA;IACD;;IAED,MAAMjL,MAAM,GAAGmF,MAAM,CAAC3I,OAAD,CAArB;;IAEA,IAAIwD,MAAJ,EAAY;MACV,IAAImF,MAAM,CAAC3J,KAAD,CAAN,KAAkB,CAAtB,EAAyB;QACvB,IAAI,CAACwE,MAAM,CAAClE,MAAD,CAAP,IAAmBkE,MAAM,CAACwG,KAA9B,EAAqC;UACnCxG,MAAM,CAACwG,KAAP;UACAxG,MAAM,CAAClE,MAAD,CAAN,GAAiB,IAAjB;QACD;MACF,CALD,MAKO,IAAIkE,MAAM,CAAClE,MAAD,CAAN,IAAkBkE,MAAM,CAACkL,GAA7B,EAAkC;QACvClL,MAAM,CAACkL,GAAP;QACAlL,MAAM,CAAClE,MAAD,CAAN,GAAiB,KAAjB;MACD;;MAED,IAAIqJ,MAAM,CAAC3J,KAAD,CAAN,KAAkB,CAAtB,EAAyB;QACvB,IAAIwE,MAAM,CAAC9E,OAAD,CAAN,CAAgBwK,WAAhB,KAAgCT,YAApC,EAAkD;UAChDjF,MAAM,CAAC9E,OAAD,CAAN,CAAgBkL,UAAhB,CAA2BjB,MAAM,CAAC1I,sBAAD,CAAjC,EAA2DwI,YAA3D;QACD;MACF,CAJD,MAIO,IAAIE,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAnB,IAAwB0E,MAAM,CAAC9E,OAAD,CAAN,CAAgBgJ,UAAhB,GAA6B,GAAzD,EAA8D;QACnE,IAAIlE,MAAM,CAAC9E,OAAD,CAAN,CAAgBwK,WAAhB,KAAgCX,eAApC,EAAqD;UACnD,MAAMxE,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAC/I,WAAD,CAArB,CAAhB;UACA,MAAM4B,cAAc,GAAGuC,OAAO,CAACvC,cAAR,IAA0B,IAA1B,GACnBuC,OAAO,CAACvC,cADW,GAEnBmH,MAAM,CAACtI,eAAD,CAFV;UAGAmD,MAAM,CAAC9E,OAAD,CAAN,CAAgBkL,UAAhB,CAA2BpI,cAA3B,EAA2C+G,eAA3C;QACD;MACF;IACF;;IAED,IAAII,MAAM,CAAClK,KAAD,CAAV,EAAmB;MACjBkK,MAAM,CAACtJ,UAAD,CAAN,GAAqB,CAArB;IACD,CAFD,MAEO,IAAIsJ,MAAM,CAACtJ,UAAD,CAAN,KAAuB,CAA3B,EAA8B;MACnC,IAAIkP,IAAJ,EAAU;QACR5F,MAAM,CAACtJ,UAAD,CAAN,GAAqB,CAArB;QACA+E,OAAO,CAACC,QAAR,CAAiBiK,SAAjB,EAA4B3F,MAA5B;MACD,CAHD,MAGO;QACL2F,SAAS,CAAC3F,MAAD,CAAT;MACD;;MACD;IACD;;IAED,IAAIA,MAAM,CAAC5J,QAAD,CAAN,KAAqB,CAAzB,EAA4B;MAC1B;IACD;;IAED,IAAI4J,MAAM,CAAC7J,QAAD,CAAN,KAAqB6J,MAAM,CAAC5I,WAAD,CAAN,IAAuB,CAA5C,CAAJ,EAAoD;MAClD;IACD;;IAED,MAAMgE,OAAO,GAAG4E,MAAM,CAACzJ,MAAD,CAAN,CAAeyJ,MAAM,CAAChJ,WAAD,CAArB,CAAhB;;IAEA,IAAIgJ,MAAM,CAACtK,IAAD,CAAN,CAAauP,QAAb,KAA0B,QAA1B,IAAsCjF,MAAM,CAACpK,WAAD,CAAN,KAAwBwF,OAAO,CAACoK,UAA1E,EAAsF;MACpF,IAAIxF,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAvB,EAA0B;QACxB;MACD;;MAED6J,MAAM,CAACpK,WAAD,CAAN,GAAsBwF,OAAO,CAACoK,UAA9B;;MAEA,IAAI3K,MAAM,IAAIA,MAAM,CAAC2K,UAAP,KAAsBpK,OAAO,CAACoK,UAA5C,EAAwD;QACtDhR,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,oBAAvB,CAArB;QACA;MACD;IACF;;IAED,IAAI0K,MAAM,CAACvJ,WAAD,CAAV,EAAyB;MACvB;IACD;;IAED,IAAI,CAACoE,MAAL,EAAa;MACXf,OAAO,CAACkG,MAAD,CAAP;MACA;IACD;;IAED,IAAInF,MAAM,CAACH,SAAP,IAAoBG,MAAM,CAACvE,QAAD,CAA1B,IAAwCuE,MAAM,CAAClF,MAAD,CAA9C,IAA0DkF,MAAM,CAAC5E,SAAD,CAApE,EAAiF;MAC/E;IACD;;IAED,IAAI+J,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAnB,IAAwB,CAACiF,OAAO,CAAC4K,UAArC,EAAiD;MAC/C;MACA;MACA;MACA;IACD;;IAED,IAAIhG,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAnB,KAAyBiF,OAAO,CAAC4D,OAAR,IAAmB5D,OAAO,CAACuI,MAAR,KAAmB,SAA/D,CAAJ,EAA+E;MAC7E;MACA;MACA;MACA;IACD;;IAED,IAAInP,IAAI,CAACyR,QAAL,CAAc7K,OAAO,CAACG,IAAtB,KAA+B/G,IAAI,CAAC8G,UAAL,CAAgBF,OAAO,CAACG,IAAxB,MAAkC,CAArE,EAAwE;MACtEH,OAAO,CAACG,IAAR,CACGoB,EADH,CACM,MADN;MACc;MAA2B,YAAY;QACjD;QACAtI,MAAM,CAAC,KAAD,CAAN;MACD,CAJH,EAKGsI,EALH,CAKM,OALN,EAKe,UAAUhB,GAAV,EAAe;QAC1Ba,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;MACD,CAPH,EAQGgB,EARH,CAQM,KARN,EAQa,YAAY;QACrBnI,IAAI,CAAC4H,OAAL,CAAa,IAAb;MACD,CAVH;MAYAhB,OAAO,CAACG,IAAR,GAAe,IAAf;IACD;;IAED,IAAIyE,MAAM,CAAC7J,QAAD,CAAN,GAAmB,CAAnB,KACD3B,IAAI,CAACyR,QAAL,CAAc7K,OAAO,CAACG,IAAtB,KAA+B/G,IAAI,CAAC0R,eAAL,CAAqB9K,OAAO,CAACG,IAA7B,CAD9B,CAAJ,EACuE;MACrE;MACA;MACA;MACA;MAEA;MACA;MACA;MACA;IACD;;IAED,IAAI,CAACH,OAAO,CAAC+K,OAAT,IAAoBC,KAAK,CAACpG,MAAD,EAAS5E,OAAT,CAA7B,EAAgD;MAC9C4E,MAAM,CAAChJ,WAAD,CAAN;IACD,CAFD,MAEO;MACLgJ,MAAM,CAACzJ,MAAD,CAAN,CAAe+F,MAAf,CAAsB0D,MAAM,CAAChJ,WAAD,CAA5B,EAA2C,CAA3C;IACD;EACF;AACF;;AAED,SAASoP,KAAT,CAAgBpG,MAAhB,EAAwB5E,OAAxB,EAAiC;EAC/B,MAAM;IAAEG,IAAF;IAAQoI,MAAR;IAAgB0C,IAAhB;IAAsBrB,IAAtB;IAA4BhG,OAA5B;IAAqCyB,OAArC;IAA8C6F;EAA9C,IAA2DlL,OAAjE,CAD+B,CAG/B;EACA;EACA;EAEA;EACA;EACA;EACA;;EAEA,MAAMmL,cAAc,GAClB5C,MAAM,KAAK,KAAX,IACAA,MAAM,KAAK,MADX,IAEAA,MAAM,KAAK,OAHb;;EAMA,IAAIpI,IAAI,IAAI,OAAOA,IAAI,CAACkG,IAAZ,KAAqB,UAAjC,EAA6C;IAC3C;IACAlG,IAAI,CAACkG,IAAL,CAAU,CAAV;EACD;;EAED,IAAIT,aAAa,GAAGxM,IAAI,CAAC8G,UAAL,CAAgBC,IAAhB,CAApB;;EAEA,IAAIyF,aAAa,KAAK,IAAtB,EAA4B;IAC1BA,aAAa,GAAG5F,OAAO,CAAC4F,aAAxB;EACD;;EAED,IAAIA,aAAa,KAAK,CAAlB,IAAuB,CAACuF,cAA5B,EAA4C;IAC1C;IACA;IACA;IACA;IAEAvF,aAAa,GAAG,IAAhB;EACD;;EAED,IAAI5F,OAAO,CAAC4F,aAAR,KAA0B,IAA1B,IAAkC5F,OAAO,CAAC4F,aAAR,KAA0BA,aAAhE,EAA+E;IAC7E,IAAIhB,MAAM,CAACpI,oBAAD,CAAV,EAAkC;MAChC4E,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkB,IAAIxG,iCAAJ,EAAlB,CAAZ;MACA,OAAO,KAAP;IACD;;IAED6G,OAAO,CAAC+K,WAAR,CAAoB,IAAI5R,iCAAJ,EAApB;EACD;;EAED,MAAMiG,MAAM,GAAGmF,MAAM,CAAC3I,OAAD,CAArB;;EAEA,IAAI;IACF+D,OAAO,CAACqL,SAAR,CAAmB9K,GAAD,IAAS;MACzB,IAAIP,OAAO,CAAC+K,OAAR,IAAmB/K,OAAO,CAACsL,SAA/B,EAA0C;QACxC;MACD;;MAEDlK,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAG,IAAI,IAAI3G,mBAAJ,EAAzB,CAAZ;MAEAR,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqB,IAAIvF,kBAAJ,CAAuB,SAAvB,CAArB;IACD,CARD;EASD,CAVD,CAUE,OAAOqG,GAAP,EAAY;IACZa,YAAY,CAACwD,MAAD,EAAS5E,OAAT,EAAkBO,GAAlB,CAAZ;EACD;;EAED,IAAIP,OAAO,CAAC+K,OAAZ,EAAqB;IACnB,OAAO,KAAP;EACD;;EAED,IAAIxC,MAAM,KAAK,MAAf,EAAuB;IACrB;IAEA;IACA;IAEA9I,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;EACD;;EAED,IAAIqJ,OAAO,IAAI2E,MAAM,KAAK,SAA1B,EAAqC;IACnC;IACA;IAEA9I,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;EACD;;EAED,IAAIqK,MAAM,CAACjI,YAAD,CAAN,IAAwB8C,MAAM,CAAC7C,QAAD,CAAN,MAAsBgI,MAAM,CAACjI,YAAD,CAAxD,EAAwE;IACtE8C,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;EACD;;EAED,IAAI2Q,QAAJ,EAAc;IACZzL,MAAM,CAAC5E,SAAD,CAAN,GAAoB,IAApB;EACD,CAzF8B,CA2F/B;;;EAEA,IAAI0Q,MAAM,GAAI,GAAEhD,MAAO,IAAG0C,IAAK,eAA/B;;EAEA,IAAI,OAAOrB,IAAP,KAAgB,QAApB,EAA8B;IAC5B2B,MAAM,IAAK,SAAQ3B,IAAK,MAAxB;EACD,CAFD,MAEO;IACL2B,MAAM,IAAI3G,MAAM,CAACnJ,WAAD,CAAhB;EACD;;EAED,IAAImI,OAAJ,EAAa;IACX2H,MAAM,IAAK,mCAAkC3H,OAAQ,MAArD;EACD,CAFD,MAEO,IAAIgB,MAAM,CAAC5I,WAAD,CAAV,EAAyB;IAC9BuP,MAAM,IAAI,4BAAV;EACD,CAFM,MAEA;IACLA,MAAM,IAAI,uBAAV;EACD;;EAED,IAAIlG,OAAJ,EAAa;IACXkG,MAAM,IAAIlG,OAAV;EACD;;EAED,IAAIxI,QAAQ,CAACE,WAAT,CAAqBK,cAAzB,EAAyC;IACvCP,QAAQ,CAACE,WAAT,CAAqBmN,OAArB,CAA6B;MAAElK,OAAF;MAAWqF,OAAO,EAAEkG,MAApB;MAA4B9L;IAA5B,CAA7B;EACD;EAED;;;EACA,IAAI,CAACU,IAAL,EAAW;IACT,IAAIyF,aAAa,KAAK,CAAtB,EAAyB;MACvBnG,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,2BAAvB,EAAmD,OAAnD;IACD,CAFD,MAEO;MACLtS,MAAM,CAAC2M,aAAa,KAAK,IAAnB,EAAyB,sCAAzB,CAAN;MACAnG,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,MAAvB,EAA8B,OAA9B;IACD;;IACDvL,OAAO,CAACwL,aAAR;EACD,CARD,MAQO,IAAIpS,IAAI,CAACqS,QAAL,CAActL,IAAd,CAAJ,EAAyB;IAC9BlH,MAAM,CAAC2M,aAAa,KAAKzF,IAAI,CAACuL,UAAxB,EAAoC,sCAApC,CAAN;IAEAjM,MAAM,CAACkM,IAAP;IACAlM,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,mBAAkB3F,aAAc,UAAvD,EAAkE,OAAlE;IACAnG,MAAM,CAACuL,KAAP,CAAa7K,IAAb;IACAV,MAAM,CAACmM,MAAP;IACA5L,OAAO,CAAC6L,UAAR,CAAmB1L,IAAnB;IACAH,OAAO,CAACwL,aAAR;;IACA,IAAI,CAACL,cAAL,EAAqB;MACnB1L,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;IACD;EACF,CAZM,MAYA,IAAInB,IAAI,CAAC0S,UAAL,CAAgB3L,IAAhB,CAAJ,EAA2B;IAChC,IAAI,OAAOA,IAAI,CAAC4L,MAAZ,KAAuB,UAA3B,EAAuC;MACrCC,aAAa,CAAC;QAAE7L,IAAI,EAAEA,IAAI,CAAC4L,MAAL,EAAR;QAAuBnH,MAAvB;QAA+B5E,OAA/B;QAAwCP,MAAxC;QAAgDmG,aAAhD;QAA+D2F,MAA/D;QAAuEJ;MAAvE,CAAD,CAAb;IACD,CAFD,MAEO;MACLc,SAAS,CAAC;QAAE9L,IAAF;QAAQyE,MAAR;QAAgB5E,OAAhB;QAAyBP,MAAzB;QAAiCmG,aAAjC;QAAgD2F,MAAhD;QAAwDJ;MAAxD,CAAD,CAAT;IACD;EACF,CANM,MAMA,IAAI/R,IAAI,CAACyR,QAAL,CAAc1K,IAAd,CAAJ,EAAyB;IAC9B+L,WAAW,CAAC;MAAE/L,IAAF;MAAQyE,MAAR;MAAgB5E,OAAhB;MAAyBP,MAAzB;MAAiCmG,aAAjC;MAAgD2F,MAAhD;MAAwDJ;IAAxD,CAAD,CAAX;EACD,CAFM,MAEA,IAAI/R,IAAI,CAACgH,UAAL,CAAgBD,IAAhB,CAAJ,EAA2B;IAChC6L,aAAa,CAAC;MAAE7L,IAAF;MAAQyE,MAAR;MAAgB5E,OAAhB;MAAyBP,MAAzB;MAAiCmG,aAAjC;MAAgD2F,MAAhD;MAAwDJ;IAAxD,CAAD,CAAb;EACD,CAFM,MAEA;IACLlS,MAAM,CAAC,KAAD,CAAN;EACD;;EAED,OAAO,IAAP;AACD;;AAED,SAASiT,WAAT,QAAgG;EAAA,IAA1E;IAAE/L,IAAF;IAAQyE,MAAR;IAAgB5E,OAAhB;IAAyBP,MAAzB;IAAiCmG,aAAjC;IAAgD2F,MAAhD;IAAwDJ;EAAxD,CAA0E;EAC9FlS,MAAM,CAAC2M,aAAa,KAAK,CAAlB,IAAuBhB,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAA7C,EAAgD,iCAAhD,CAAN;EAEA,IAAIoR,QAAQ,GAAG,KAAf;EAEA,MAAMC,MAAM,GAAG,IAAIC,WAAJ,CAAgB;IAAE5M,MAAF;IAAUO,OAAV;IAAmB4F,aAAnB;IAAkChB,MAAlC;IAA0CuG,cAA1C;IAA0DI;EAA1D,CAAhB,CAAf;;EAEA,MAAMpC,MAAM,GAAG,UAAU5C,KAAV,EAAiB;IAC9B,IAAI;MACFtN,MAAM,CAAC,CAACkT,QAAF,CAAN;;MAEA,IAAI,CAACC,MAAM,CAACpB,KAAP,CAAazE,KAAb,CAAD,IAAwB,KAAK0C,KAAjC,EAAwC;QACtC,KAAKA,KAAL;MACD;IACF,CAND,CAME,OAAO1I,GAAP,EAAY;MACZnH,IAAI,CAAC4H,OAAL,CAAa,IAAb,EAAmBT,GAAnB;IACD;EACF,CAVD;;EAWA,MAAM+L,OAAO,GAAG,YAAY;IAC1BrT,MAAM,CAAC,CAACkT,QAAF,CAAN;;IAEA,IAAIhM,IAAI,CAACd,MAAT,EAAiB;MACfc,IAAI,CAACd,MAAL;IACD;EACF,CAND;;EAOA,MAAMkN,OAAO,GAAG,YAAY;IAC1BC,UAAU,CAAC,IAAI5S,mBAAJ,EAAD,CAAV;EACD,CAFD;;EAGA,MAAM4S,UAAU,GAAG,UAAUjM,GAAV,EAAe;IAChC,IAAI4L,QAAJ,EAAc;MACZ;IACD;;IAEDA,QAAQ,GAAG,IAAX;IAEAlT,MAAM,CAACwG,MAAM,CAACH,SAAP,IAAqBG,MAAM,CAACvE,QAAD,CAAN,IAAoB0J,MAAM,CAAC7J,QAAD,CAAN,IAAoB,CAA9D,CAAN;IAEA0E,MAAM,CACHgN,GADH,CACO,OADP,EACgBH,OADhB,EAEGG,GAFH,CAEO,OAFP,EAEgBD,UAFhB;IAIArM,IAAI,CACDqI,cADH,CACkB,MADlB,EAC0BW,MAD1B,EAEGX,cAFH,CAEkB,KAFlB,EAEyBgE,UAFzB,EAGGhE,cAHH,CAGkB,OAHlB,EAG2BgE,UAH3B,EAIGhE,cAJH,CAIkB,OAJlB,EAI2B+D,OAJ3B;;IAMA,IAAI,CAAChM,GAAL,EAAU;MACR,IAAI;QACF6L,MAAM,CAACpJ,GAAP;MACD,CAFD,CAEE,OAAO0J,EAAP,EAAW;QACXnM,GAAG,GAAGmM,EAAN;MACD;IACF;;IAEDN,MAAM,CAACpL,OAAP,CAAeT,GAAf,EA3BgC,CA6BhC;;IACA,IAAIA,GAAG,KAAKA,GAAG,CAACoJ,IAAJ,KAAa,cAAb,IAA+BpJ,GAAG,CAACoH,OAAJ,KAAgB,OAApD,CAAP,EAAqE;MACnEvO,IAAI,CAAC4H,OAAL,CAAab,IAAb,EAAmBI,GAAnB;IACD,CAFD,MAEO;MACLnH,IAAI,CAAC4H,OAAL,CAAab,IAAb;IACD;EACF,CAnCD;;EAqCAA,IAAI,CACDoB,EADH,CACM,MADN,EACc4H,MADd,EAEG5H,EAFH,CAEM,KAFN,EAEaiL,UAFb,EAGGjL,EAHH,CAGM,OAHN,EAGeiL,UAHf,EAIGjL,EAJH,CAIM,OAJN,EAIegL,OAJf;;EAMA,IAAIpM,IAAI,CAACd,MAAT,EAAiB;IACfc,IAAI,CAACd,MAAL;EACD;;EAEDI,MAAM,CACH8B,EADH,CACM,OADN,EACe+K,OADf,EAEG/K,EAFH,CAEM,OAFN,EAEeiL,UAFf;AAGD;;AAED,eAAeP,SAAf,QAAoG;EAAA,IAA1E;IAAE9L,IAAF;IAAQyE,MAAR;IAAgB5E,OAAhB;IAAyBP,MAAzB;IAAiCmG,aAAjC;IAAgD2F,MAAhD;IAAwDJ;EAAxD,CAA0E;EAClGlS,MAAM,CAAC2M,aAAa,KAAKzF,IAAI,CAACwM,IAAxB,EAA8B,oCAA9B,CAAN;;EAEA,IAAI;IACF,IAAI/G,aAAa,IAAI,IAAjB,IAAyBA,aAAa,KAAKzF,IAAI,CAACwM,IAApD,EAA0D;MACxD,MAAM,IAAInT,iCAAJ,EAAN;IACD;;IAED,MAAMsN,MAAM,GAAGpF,MAAM,CAACS,IAAP,CAAY,MAAMhC,IAAI,CAACyM,WAAL,EAAlB,CAAf;IAEAnN,MAAM,CAACkM,IAAP;IACAlM,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,mBAAkB3F,aAAc,UAAvD,EAAkE,OAAlE;IACAnG,MAAM,CAACuL,KAAP,CAAalE,MAAb;IACArH,MAAM,CAACmM,MAAP;IAEA5L,OAAO,CAAC6L,UAAR,CAAmB/E,MAAnB;IACA9G,OAAO,CAACwL,aAAR;;IAEA,IAAI,CAACL,cAAL,EAAqB;MACnB1L,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;IACD;;IAED8E,MAAM,CAACuF,MAAD,CAAN;EACD,CApBD,CAoBE,OAAOrE,GAAP,EAAY;IACZnH,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;EACD;AACF;;AAED,eAAeyL,aAAf,QAAwG;EAAA,IAA1E;IAAE7L,IAAF;IAAQyE,MAAR;IAAgB5E,OAAhB;IAAyBP,MAAzB;IAAiCmG,aAAjC;IAAgD2F,MAAhD;IAAwDJ;EAAxD,CAA0E;EACtGlS,MAAM,CAAC2M,aAAa,KAAK,CAAlB,IAAuBhB,MAAM,CAAC7J,QAAD,CAAN,KAAqB,CAA7C,EAAgD,mCAAhD,CAAN;EAEA,IAAI2F,QAAQ,GAAG,IAAf;;EACA,SAAS4L,OAAT,GAAoB;IAClB,IAAI5L,QAAJ,EAAc;MACZ,MAAMhB,EAAE,GAAGgB,QAAX;MACAA,QAAQ,GAAG,IAAX;MACAhB,EAAE;IACH;EACF;;EAED,MAAMmN,YAAY,GAAG,MAAM,IAAIlM,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;IAC1D5H,MAAM,CAACyH,QAAQ,KAAK,IAAd,CAAN;;IAEA,IAAIjB,MAAM,CAAC3D,MAAD,CAAV,EAAoB;MAClB+E,MAAM,CAACpB,MAAM,CAAC3D,MAAD,CAAP,CAAN;IACD,CAFD,MAEO;MACL4E,QAAQ,GAAGE,OAAX;IACD;EACF,CAR0B,CAA3B;;EAUAnB,MAAM,CACH8B,EADH,CACM,OADN,EACe+K,OADf,EAEG/K,EAFH,CAEM,OAFN,EAEe+K,OAFf;EAIA,MAAMF,MAAM,GAAG,IAAIC,WAAJ,CAAgB;IAAE5M,MAAF;IAAUO,OAAV;IAAmB4F,aAAnB;IAAkChB,MAAlC;IAA0CuG,cAA1C;IAA0DI;EAA1D,CAAhB,CAAf;;EACA,IAAI;IACF;IACA;IACA,WAAW,MAAMhF,KAAjB,IAA0BpG,IAA1B,EAAgC;MAC9B,IAAIV,MAAM,CAAC3D,MAAD,CAAV,EAAoB;QAClB,MAAM2D,MAAM,CAAC3D,MAAD,CAAZ;MACD;;MAED,IAAI,CAACsQ,MAAM,CAACpB,KAAP,CAAazE,KAAb,CAAL,EAA0B;QACxB,MAAMsG,YAAY,EAAlB;MACD;IACF;;IAEDT,MAAM,CAACpJ,GAAP;EACD,CAdD,CAcE,OAAOzC,GAAP,EAAY;IACZ6L,MAAM,CAACpL,OAAP,CAAeT,GAAf;EACD,CAhBD,SAgBU;IACRd,MAAM,CACHgN,GADH,CACO,OADP,EACgBH,OADhB,EAEGG,GAFH,CAEO,OAFP,EAEgBH,OAFhB;EAGD;AACF;;AAED,MAAMD,WAAN,CAAkB;EAChB/O,WAAW,QAAsE;IAAA,IAApE;MAAEmC,MAAF;MAAUO,OAAV;MAAmB4F,aAAnB;MAAkChB,MAAlC;MAA0CuG,cAA1C;MAA0DI;IAA1D,CAAoE;IAC/E,KAAK9L,MAAL,GAAcA,MAAd;IACA,KAAKO,OAAL,GAAeA,OAAf;IACA,KAAK4F,aAAL,GAAqBA,aAArB;IACA,KAAKhB,MAAL,GAAcA,MAAd;IACA,KAAKkI,YAAL,GAAoB,CAApB;IACA,KAAK3B,cAAL,GAAsBA,cAAtB;IACA,KAAKI,MAAL,GAAcA,MAAd;IAEA9L,MAAM,CAACvE,QAAD,CAAN,GAAmB,IAAnB;EACD;;EAED8P,KAAK,CAAEzE,KAAF,EAAS;IACZ,MAAM;MAAE9G,MAAF;MAAUO,OAAV;MAAmB4F,aAAnB;MAAkChB,MAAlC;MAA0CkI,YAA1C;MAAwD3B,cAAxD;MAAwEI;IAAxE,IAAmF,IAAzF;;IAEA,IAAI9L,MAAM,CAAC3D,MAAD,CAAV,EAAoB;MAClB,MAAM2D,MAAM,CAAC3D,MAAD,CAAZ;IACD;;IAED,IAAI2D,MAAM,CAACH,SAAX,EAAsB;MACpB,OAAO,KAAP;IACD;;IAED,MAAMmD,GAAG,GAAGf,MAAM,CAACgK,UAAP,CAAkBnF,KAAlB,CAAZ;;IACA,IAAI,CAAC9D,GAAL,EAAU;MACR,OAAO,IAAP;IACD,CAdW,CAgBZ;IACA;;;IACA,IAAImD,aAAa,KAAK,IAAlB,IAA0BkH,YAAY,GAAGrK,GAAf,GAAqBmD,aAAnD,EAAkE;MAChE,IAAIhB,MAAM,CAACpI,oBAAD,CAAV,EAAkC;QAChC,MAAM,IAAIhD,iCAAJ,EAAN;MACD;;MAED6G,OAAO,CAAC+K,WAAR,CAAoB,IAAI5R,iCAAJ,EAApB;IACD;;IAED,IAAIsT,YAAY,KAAK,CAArB,EAAwB;MACtB,IAAI,CAAC3B,cAAL,EAAqB;QACnB1L,MAAM,CAAClF,MAAD,CAAN,GAAiB,IAAjB;MACD;;MAED,IAAIqL,aAAa,KAAK,IAAtB,EAA4B;QAC1BnG,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,gCAAvB,EAAwD,OAAxD;MACD,CAFD,MAEO;QACL9L,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,mBAAkB3F,aAAc,UAAvD,EAAkE,OAAlE;MACD;IACF;;IAED,IAAIA,aAAa,KAAK,IAAtB,EAA4B;MAC1BnG,MAAM,CAACuL,KAAP,CAAc,OAAMvI,GAAG,CAACoF,QAAJ,CAAa,EAAb,CAAiB,MAArC,EAA4C,OAA5C;IACD;;IAED,KAAKiF,YAAL,IAAqBrK,GAArB;IAEA,MAAMuE,GAAG,GAAGvH,MAAM,CAACuL,KAAP,CAAazE,KAAb,CAAZ;IACAvG,OAAO,CAAC6L,UAAR,CAAmBtF,KAAnB;IACA,OAAOS,GAAP;EACD;;EAEDhE,GAAG,GAAI;IACL,MAAM;MAAEvD,MAAF;MAAUmG,aAAV;MAAyBhB,MAAzB;MAAiCkI,YAAjC;MAA+C3B,cAA/C;MAA+DI,MAA/D;MAAuEvL;IAAvE,IAAmF,IAAzF;IACAA,OAAO,CAACwL,aAAR;IAEA/L,MAAM,CAACvE,QAAD,CAAN,GAAmB,KAAnB;;IAEA,IAAIuE,MAAM,CAAC3D,MAAD,CAAV,EAAoB;MAClB,MAAM2D,MAAM,CAAC3D,MAAD,CAAZ;IACD;;IAED,IAAI2D,MAAM,CAACH,SAAX,EAAsB;MACpB;IACD;;IAED,IAAIwN,YAAY,KAAK,CAArB,EAAwB;MACtB,IAAI3B,cAAJ,EAAoB;QAClB;QACA;QACA;QACA;QAEA1L,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,2BAAvB,EAAmD,OAAnD;MACD,CAPD,MAOO;QACL9L,MAAM,CAACuL,KAAP,CAAc,GAAEO,MAAO,MAAvB,EAA8B,OAA9B;MACD;IACF,CAXD,MAWO,IAAI3F,aAAa,KAAK,IAAtB,EAA4B;MACjCnG,MAAM,CAACuL,KAAP,CAAa,eAAb,EAA8B,OAA9B;IACD;;IAED,IAAIpF,aAAa,KAAK,IAAlB,IAA0BkH,YAAY,KAAKlH,aAA/C,EAA8D;MAC5D,IAAIhB,MAAM,CAACpI,oBAAD,CAAV,EAAkC;QAChC,MAAM,IAAIhD,iCAAJ,EAAN;MACD,CAFD,MAEO;QACL6G,OAAO,CAAC+K,WAAR,CAAoB,IAAI5R,iCAAJ,EAApB;MACD;IACF,CAnCI,CAqCL;;;IACA,IAAIiG,MAAM,CAAC9E,OAAD,CAAN,CAAgBqE,OAAhB,IAA2BS,MAAM,CAAC9E,OAAD,CAAN,CAAgBwK,WAAhB,KAAgCX,eAA/D,EAAgF;MAC9E;MACA,IAAI/E,MAAM,CAAC9E,OAAD,CAAN,CAAgBqE,OAAhB,CAAwBkH,OAA5B,EAAqC;QACnCzG,MAAM,CAAC9E,OAAD,CAAN,CAAgBqE,OAAhB,CAAwBkH,OAAxB;MACD;IACF;;IAED7G,MAAM,CAACuF,MAAD,CAAN;EACD;;EAED5D,OAAO,CAAET,GAAF,EAAO;IACZ,MAAM;MAAEd,MAAF;MAAUmF;IAAV,IAAqB,IAA3B;IAEAnF,MAAM,CAACvE,QAAD,CAAN,GAAmB,KAAnB;;IAEA,IAAIqF,GAAJ,EAAS;MACPtH,MAAM,CAAC2L,MAAM,CAAC7J,QAAD,CAAN,IAAoB,CAArB,EAAwB,2CAAxB,CAAN;MACA3B,IAAI,CAAC4H,OAAL,CAAavB,MAAb,EAAqBc,GAArB;IACD;EACF;;AAvHe;;AA0HlB,SAASa,YAAT,CAAuBwD,MAAvB,EAA+B5E,OAA/B,EAAwCO,GAAxC,EAA6C;EAC3C,IAAI;IACFP,OAAO,CAACQ,OAAR,CAAgBD,GAAhB;IACAtH,MAAM,CAAC+G,OAAO,CAAC+K,OAAT,CAAN;EACD,CAHD,CAGE,OAAOxK,GAAP,EAAY;IACZqE,MAAM,CAACiE,IAAP,CAAY,OAAZ,EAAqBtI,GAArB;EACD;AACF;;AAEDwM,MAAM,CAAClI,OAAP,GAAiBxH,MAAjB"},"metadata":{},"sourceType":"script"}