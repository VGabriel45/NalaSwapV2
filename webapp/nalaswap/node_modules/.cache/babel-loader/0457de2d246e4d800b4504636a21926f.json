{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.runScriptWithHardhat = exports.runScript = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst execution_mode_1 = require(\"../core/execution-mode\");\n\nconst env_variables_1 = require(\"../core/params/env-variables\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:scripts-runner\");\n\nasync function runScript(scriptPath) {\n  let scriptArgs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let extraNodeArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraEnvVars = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const {\n    fork\n  } = await Promise.resolve().then(() => __importStar(require(\"child_process\")));\n  return new Promise((resolve, reject) => {\n    const processExecArgv = withFixedInspectArg(process.execArgv);\n    const nodeArgs = [...processExecArgv, ...getTsNodeArgsIfNeeded(scriptPath), ...extraNodeArgs];\n    const envVars = Object.assign(Object.assign({}, process.env), extraEnvVars);\n    const childProcess = fork(scriptPath, scriptArgs, {\n      stdio: \"inherit\",\n      execArgv: nodeArgs,\n      env: envVars\n    });\n    childProcess.once(\"close\", status => {\n      log(`Script ${scriptPath} exited with status code ${status}`);\n      resolve(status);\n    });\n    childProcess.once(\"error\", reject);\n  });\n}\n\nexports.runScript = runScript;\n\nasync function runScriptWithHardhat(hardhatArguments, scriptPath) {\n  let scriptArgs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  let extraNodeArgs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n  let extraEnvVars = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  log(`Creating Hardhat subprocess to run ${scriptPath}`);\n  return runScript(scriptPath, scriptArgs, [...extraNodeArgs, \"--require\", path_1.default.join(__dirname, \"..\", \"..\", \"register\")], Object.assign(Object.assign({}, (0, env_variables_1.getEnvVariablesMap)(hardhatArguments)), extraEnvVars));\n}\n\nexports.runScriptWithHardhat = runScriptWithHardhat;\n/**\n * Fix debugger \"inspect\" arg from process.argv, if present.\n *\n * When running this process with a debugger, a debugger port\n * is specified via the \"--inspect-brk=\" arg param in some IDEs/setups.\n *\n * This normally works, but if we do a fork afterwards, we'll get an error stating\n * that the port is already in use (since the fork would also use the same args,\n * therefore the same port number). To prevent this issue, we could replace the port number with\n * a different free one, or simply use the port-agnostic --inspect\" flag, and leave the debugger\n * port selection to the Node process itself, which will pick an empty AND valid one.\n *\n * This way, we can properly use the debugger for this process AND for the executed\n * script itself - even if it's compiled using ts-node.\n */\n\nfunction withFixedInspectArg(argv) {\n  const fixIfInspectArg = arg => {\n    if (arg.toLowerCase().includes(\"--inspect-brk=\")) {\n      return \"--inspect\";\n    }\n\n    return arg;\n  };\n\n  return argv.map(fixIfInspectArg);\n}\n\nfunction getTsNodeArgsIfNeeded(scriptPath) {\n  if (process.execArgv.includes(\"ts-node/register\")) {\n    return [];\n  } // if we are running the tests we only want to transpile, or these tests\n  // take forever\n\n\n  if ((0, execution_mode_1.isRunningHardhatCoreTests)()) {\n    return [\"--require\", \"ts-node/register/transpile-only\"];\n  } // If the script we are going to run is .ts we need ts-node\n\n\n  if (/\\.tsx?$/i.test(scriptPath)) {\n    return [\"--require\", \"ts-node/register\"];\n  }\n\n  return [];\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;AACA;;AAGA;;AACA;;AAEA,MAAMA,GAAG,GAAG,qBAAM,6BAAN,CAAZ;;AAEO,eAAeC,SAAf,CACLC,UADK,EAIwC;EAAA,IAF7CC,UAE6C,uEAFtB,EAEsB;EAAA,IAD7CC,aAC6C,uEADnB,EACmB;EAAA,IAA7CC,YAA6C,uEAAF,EAAE;EAE7C,MAAM;IAAEC;EAAF,IAAW,wDAAa,eAAb,GAAjB;EAEA,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAoB;IACrC,MAAMC,eAAe,GAAGC,mBAAmB,CAACC,OAAO,CAACC,QAAT,CAA3C;IAEA,MAAMC,QAAQ,GAAG,CACf,GAAGJ,eADY,EAEf,GAAGK,qBAAqB,CAACb,UAAD,CAFT,EAGf,GAAGE,aAHY,CAAjB;IAMA,MAAMY,OAAO,mCAAQJ,OAAO,CAACK,GAAhB,GAAwBZ,YAAxB,CAAb;IAEA,MAAMa,YAAY,GAAGZ,IAAI,CAACJ,UAAD,EAAaC,UAAb,EAAyB;MAChDgB,KAAK,EAAE,SADyC;MAEhDN,QAAQ,EAAEC,QAFsC;MAGhDG,GAAG,EAAED;IAH2C,CAAzB,CAAzB;IAMAE,YAAY,CAACE,IAAb,CAAkB,OAAlB,EAA4BC,MAAD,IAAW;MACpCrB,GAAG,CAAC,UAAUE,UAAU,4BAA4BmB,MAAM,EAAvD,CAAH;MAEAb,OAAO,CAACa,MAAD,CAAP;IACD,CAJD;IAKAH,YAAY,CAACE,IAAb,CAAkB,OAAlB,EAA2BX,MAA3B;EACD,CAvBM,CAAP;AAwBD;;AAhCDa;;AAkCO,eAAeC,oBAAf,CACLC,gBADK,EAELtB,UAFK,EAKwC;EAAA,IAF7CC,UAE6C,uEAFtB,EAEsB;EAAA,IAD7CC,aAC6C,uEADnB,EACmB;EAAA,IAA7CC,YAA6C,uEAAF,EAAE;EAE7CL,GAAG,CAAC,sCAAsCE,UAAU,EAAjD,CAAH;EAEA,OAAOD,SAAS,CACdC,UADc,EAEdC,UAFc,EAGd,CACE,GAAGC,aADL,EAEE,WAFF,EAGEqB,eAAKC,IAAL,CAAUC,SAAV,EAAqB,IAArB,EAA2B,IAA3B,EAAiC,UAAjC,CAHF,CAHc,EAObC,gCAEI,wCAAmBJ,gBAAnB,CAFJ,GAGInB,YAHJ,CAPa,CAAhB;AAaD;;AAtBDiB;AAwBA;;;;;;;;;;;;;;;;AAeA,SAASX,mBAAT,CAA6BkB,IAA7B,EAA2C;EACzC,MAAMC,eAAe,GAAIC,GAAD,IAAgB;IACtC,IAAIA,GAAG,CAACC,WAAJ,GAAkBC,QAAlB,CAA2B,gBAA3B,CAAJ,EAAkD;MAChD,OAAO,WAAP;IACD;;IACD,OAAOF,GAAP;EACD,CALD;;EAMA,OAAOF,IAAI,CAACK,GAAL,CAASJ,eAAT,CAAP;AACD;;AAED,SAASf,qBAAT,CAA+Bb,UAA/B,EAAiD;EAC/C,IAAIU,OAAO,CAACC,QAAR,CAAiBoB,QAAjB,CAA0B,kBAA1B,CAAJ,EAAmD;IACjD,OAAO,EAAP;EACD,CAH8C,CAK/C;EACA;;;EACA,IAAI,iDAAJ,EAAiC;IAC/B,OAAO,CAAC,WAAD,EAAc,iCAAd,CAAP;EACD,CAT8C,CAW/C;;;EACA,IAAI,WAAWE,IAAX,CAAgBjC,UAAhB,CAAJ,EAAiC;IAC/B,OAAO,CAAC,WAAD,EAAc,kBAAd,CAAP;EACD;;EAED,OAAO,EAAP;AACD","names":["log","runScript","scriptPath","scriptArgs","extraNodeArgs","extraEnvVars","fork","Promise","resolve","reject","processExecArgv","withFixedInspectArg","process","execArgv","nodeArgs","getTsNodeArgsIfNeeded","envVars","env","childProcess","stdio","once","status","exports","runScriptWithHardhat","hardhatArguments","path_1","join","__dirname","Object","argv","fixIfInspectArg","arg","toLowerCase","includes","map","test"],"sourceRoot":"","sources":["../../src/internal/util/scripts-runner.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}