{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Resolver = exports.ResolvedFile = void 0;\n\nconst fs_extra_1 = __importDefault(require(\"fs-extra\"));\n\nconst path_1 = __importDefault(require(\"path\"));\n\nconst resolve_1 = __importDefault(require(\"resolve\"));\n\nconst source_names_1 = require(\"../../utils/source-names\");\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nconst hash_1 = require(\"../util/hash\");\n\nconst NODE_MODULES = \"node_modules\";\n\nclass ResolvedFile {\n  constructor(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion) {\n    this.sourceName = sourceName;\n    this.absolutePath = absolutePath;\n    this.content = content;\n    this.contentHash = contentHash;\n    this.lastModificationDate = lastModificationDate;\n    (0, errors_1.assertHardhatInvariant)(libraryName === undefined && libraryVersion === undefined || libraryName !== undefined && libraryVersion !== undefined, \"Libraries should have both name and version, or neither one\");\n\n    if (libraryName !== undefined && libraryVersion !== undefined) {\n      this.library = {\n        name: libraryName,\n        version: libraryVersion\n      };\n    }\n  }\n\n  getVersionedName() {\n    return this.sourceName + (this.library !== undefined ? `@v${this.library.version}` : \"\");\n  }\n\n}\n\nexports.ResolvedFile = ResolvedFile;\n\nclass Resolver {\n  constructor(_projectRoot, _parser, _readFile) {\n    this._projectRoot = _projectRoot;\n    this._parser = _parser;\n    this._readFile = _readFile;\n  }\n  /**\n   * Resolves a source name into a ResolvedFile.\n   *\n   * @param sourceName The source name as it would be provided to solc.\n   */\n\n\n  async resolveSourceName(sourceName) {\n    (0, source_names_1.validateSourceNameFormat)(sourceName);\n\n    if (await (0, source_names_1.isLocalSourceName)(this._projectRoot, sourceName)) {\n      return this._resolveLocalSourceName(sourceName);\n    }\n\n    return this._resolveLibrarySourceName(sourceName);\n  }\n  /**\n   * Resolves an import from an already resolved file.\n   * @param from The file were the import statement is present.\n   * @param imported The path in the import statement.\n   */\n\n\n  async resolveImport(from, imported) {\n    const scheme = this._getUriScheme(imported);\n\n    if (scheme !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_PROTOCOL, {\n        from: from.sourceName,\n        imported,\n        protocol: scheme\n      });\n    }\n\n    if ((0, source_names_1.replaceBackslashes)(imported) !== imported) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_BACKSLASH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if ((0, source_names_1.isAbsolutePathSourceName)(imported)) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_ABSOLUTE_PATH, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    try {\n      if (!this._isRelativeImport(imported)) {\n        return await this.resolveSourceName((0, source_names_1.normalizeSourceName)(imported));\n      }\n\n      const sourceName = await this._relativeImportToSourceName(from, imported); // We have this special case here, because otherwise local relative\n      // imports can be treated as library imports. For example if\n      // `contracts/c.sol` imports `../non-existent/a.sol`\n\n      if (from.library === undefined && !this._isRelativeImportToLibrary(from, imported)) {\n        return await this._resolveLocalSourceName(sourceName);\n      }\n\n      return await this.resolveSourceName(sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND) || errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_FILE_NOT_FOUND, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_WRONG_CASING, {\n          imported,\n          from: from.sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.IMPORTED_LIBRARY_NOT_INSTALLED, {\n          library: error.messageArguments.library,\n          from: from.sourceName\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n  async _resolveLocalSourceName(sourceName) {\n    await this._validateSourceNameExistenceAndCasing(this._projectRoot, sourceName, false);\n    const absolutePath = path_1.default.join(this._projectRoot, sourceName);\n    return this._resolveFile(sourceName, absolutePath);\n  }\n\n  async _resolveLibrarySourceName(sourceName) {\n    const libraryName = this._getLibraryName(sourceName);\n\n    let packageJsonPath;\n\n    try {\n      packageJsonPath = this._resolveNodeModulesFileFromProjectRoot(path_1.default.join(libraryName, \"package.json\"));\n    } catch (error) {\n      // if the project is using a dependency from hardhat itself but it can't\n      // be found, this means that a global installation is being used, so we\n      // resolve the dependency relative to this file\n      if (libraryName === \"hardhat\") {\n        const hardhatCoreDir = path_1.default.join(__dirname, \"..\", \"..\");\n        packageJsonPath = path_1.default.join(hardhatCoreDir, \"package.json\");\n      } else {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.LIBRARY_NOT_INSTALLED, {\n          library: libraryName\n        }, error);\n      }\n    }\n\n    let nodeModulesPath = path_1.default.dirname(path_1.default.dirname(packageJsonPath));\n\n    if (this._isScopedPackage(sourceName)) {\n      nodeModulesPath = path_1.default.dirname(nodeModulesPath);\n    }\n\n    await this._validateSourceNameExistenceAndCasing(nodeModulesPath, sourceName, true);\n    const packageInfo = await fs_extra_1.default.readJson(packageJsonPath);\n    const libraryVersion = packageInfo.version;\n    return this._resolveFile(sourceName, // We resolve to the real path here, as we may be resolving a linked library\n    await fs_extra_1.default.realpath(path_1.default.join(nodeModulesPath, sourceName)), libraryName, libraryVersion);\n  }\n\n  async _relativeImportToSourceName(from, imported) {\n    // This is a special case, were we turn relative imports from local files\n    // into library imports if necessary. The reason for this is that many\n    // users just do `import \"../node_modules/lib/a.sol\";`.\n    if (this._isRelativeImportToLibrary(from, imported)) {\n      return this._relativeImportToLibraryToSourceName(from, imported);\n    }\n\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported)); // If the file with the import is local, and the normalized version\n    // starts with ../ means that it's trying to get outside of the project.\n\n    if (from.library === undefined && sourceName.startsWith(\"../\")) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.INVALID_IMPORT_OUTSIDE_OF_PROJECT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    if (from.library !== undefined && !this._isInsideSameDir(from.sourceName, sourceName)) {\n      // If the file is being imported from a library, this means that it's\n      // trying to reach another one.\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.ILLEGAL_IMPORT, {\n        from: from.sourceName,\n        imported\n      });\n    }\n\n    return sourceName;\n  }\n\n  async _resolveFile(sourceName, absolutePath, libraryName, libraryVersion) {\n    const rawContent = await this._readFile(absolutePath);\n    const stats = await fs_extra_1.default.stat(absolutePath);\n    const lastModificationDate = new Date(stats.ctime);\n    const contentHash = (0, hash_1.createNonCryptographicHashBasedIdentifier)(Buffer.from(rawContent)).toString(\"hex\");\n\n    const parsedContent = this._parser.parse(rawContent, absolutePath, contentHash);\n\n    const content = Object.assign({\n      rawContent\n    }, parsedContent);\n    return new ResolvedFile(sourceName, absolutePath, content, contentHash, lastModificationDate, libraryName, libraryVersion);\n  }\n\n  _isRelativeImport(imported) {\n    return imported.startsWith(\"./\") || imported.startsWith(\"../\");\n  }\n\n  _resolveNodeModulesFileFromProjectRoot(fileName) {\n    return resolve_1.default.sync(fileName, {\n      basedir: this._projectRoot,\n      preserveSymlinks: true\n    });\n  }\n\n  _getLibraryName(sourceName) {\n    let endIndex;\n\n    if (this._isScopedPackage(sourceName)) {\n      endIndex = sourceName.indexOf(\"/\", sourceName.indexOf(\"/\") + 1);\n    } else if (sourceName.indexOf(\"/\") === -1) {\n      endIndex = sourceName.length;\n    } else {\n      endIndex = sourceName.indexOf(\"/\");\n    }\n\n    return sourceName.slice(0, endIndex);\n  }\n\n  _getUriScheme(s) {\n    const re = /([a-zA-Z]+):\\/\\//;\n    const match = re.exec(s);\n\n    if (match === null) {\n      return undefined;\n    }\n\n    return match[1];\n  }\n\n  _isInsideSameDir(sourceNameInDir, sourceNameToTest) {\n    const firstSlash = sourceNameInDir.indexOf(\"/\");\n    const dir = firstSlash !== -1 ? sourceNameInDir.substring(0, firstSlash) : sourceNameInDir;\n    return sourceNameToTest.startsWith(dir);\n  }\n\n  _isScopedPackage(packageOrPackageFile) {\n    return packageOrPackageFile.startsWith(\"@\");\n  }\n\n  _isRelativeImportToLibrary(from, imported) {\n    return this._isRelativeImport(imported) && from.library === undefined && imported.includes(`${NODE_MODULES}/`);\n  }\n\n  _relativeImportToLibraryToSourceName(from, imported) {\n    const sourceName = (0, source_names_1.normalizeSourceName)(path_1.default.join(path_1.default.dirname(from.sourceName), imported));\n    const nmIndex = sourceName.indexOf(`${NODE_MODULES}/`);\n    return sourceName.substr(nmIndex + NODE_MODULES.length + 1);\n  }\n\n  async _validateSourceNameExistenceAndCasing(fromDir, sourceName, isLibrary) {\n    try {\n      await (0, source_names_1.validateSourceNameExistenceAndCasing)(fromDir, sourceName);\n    } catch (error) {\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.FILE_NOT_FOUND)) {\n        throw new errors_1.HardhatError(isLibrary ? errors_list_1.ERRORS.RESOLVER.LIBRARY_FILE_NOT_FOUND : errors_list_1.ERRORS.RESOLVER.FILE_NOT_FOUND, {\n          file: sourceName\n        }, error);\n      }\n\n      if (errors_1.HardhatError.isHardhatErrorType(error, errors_list_1.ERRORS.SOURCE_NAMES.WRONG_CASING)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.RESOLVER.WRONG_SOURCE_NAME_CASING, {\n          incorrect: sourceName,\n          correct: error.messageArguments.correct\n        }, error);\n      } // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n\n      throw error;\n    }\n  }\n\n}\n\nexports.Resolver = Resolver;","map":{"version":3,"mappings":"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","names":["NODE_MODULES","ResolvedFile","constructor","sourceName","absolutePath","content","contentHash","lastModificationDate","libraryName","libraryVersion","undefined","library","name","version","getVersionedName","exports","Resolver","_projectRoot","_parser","_readFile","resolveSourceName","_resolveLocalSourceName","_resolveLibrarySourceName","resolveImport","from","imported","scheme","_getUriScheme","errors_1","errors_list_1","RESOLVER","INVALID_IMPORT_PROTOCOL","protocol","INVALID_IMPORT_BACKSLASH","INVALID_IMPORT_ABSOLUTE_PATH","_isRelativeImport","_relativeImportToSourceName","_isRelativeImportToLibrary","error","isHardhatErrorType","FILE_NOT_FOUND","LIBRARY_FILE_NOT_FOUND","IMPORTED_FILE_NOT_FOUND","WRONG_SOURCE_NAME_CASING","INVALID_IMPORT_WRONG_CASING","LIBRARY_NOT_INSTALLED","IMPORTED_LIBRARY_NOT_INSTALLED","messageArguments","_validateSourceNameExistenceAndCasing","path_1","join","_resolveFile","_getLibraryName","packageJsonPath","_resolveNodeModulesFileFromProjectRoot","hardhatCoreDir","__dirname","nodeModulesPath","dirname","_isScopedPackage","packageInfo","fs_extra_1","readJson","realpath","_relativeImportToLibraryToSourceName","startsWith","INVALID_IMPORT_OUTSIDE_OF_PROJECT","_isInsideSameDir","ILLEGAL_IMPORT","rawContent","stats","stat","Date","ctime","Buffer","toString","parsedContent","parse","fileName","resolve_1","sync","basedir","preserveSymlinks","endIndex","indexOf","length","slice","s","re","match","exec","sourceNameInDir","sourceNameToTest","firstSlash","dir","substring","packageOrPackageFile","includes","nmIndex","substr","fromDir","isLibrary","SOURCE_NAMES","file","WRONG_CASING","incorrect","correct"],"sourceRoot":"","sources":["../../src/internal/solidity/resolver.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}