{"ast":null,"code":"'use strict';\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors');\n\nconst {\n  kClients,\n  kRunning\n} = require('./core/symbols');\n\nconst Dispatcher = require('./dispatcher');\n\nconst Pool = require('./pool');\n\nconst Client = require('./client');\n\nconst util = require('./core/util');\n\nconst RedirectHandler = require('./handler/redirect');\n\nconst {\n  WeakRef,\n  FinalizationRegistry\n} = require('./compat/dispatcher-weakref')();\n\nconst kDestroyed = Symbol('destroyed');\nconst kClosed = Symbol('closed');\nconst kOnConnect = Symbol('onConnect');\nconst kOnDisconnect = Symbol('onDisconnect');\nconst kOnConnectionError = Symbol('onConnectionError');\nconst kMaxRedirections = Symbol('maxRedirections');\nconst kOnDrain = Symbol('onDrain');\nconst kFactory = Symbol('factory');\nconst kFinalizer = Symbol('finalizer');\nconst kOptions = Symbol('options');\n\nfunction defaultFactory(origin, opts) {\n  return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);\n}\n\nclass Agent extends Dispatcher {\n  constructor() {\n    let {\n      factory = defaultFactory,\n      maxRedirections = 0,\n      connect,\n      ...options\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.');\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object');\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number');\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect\n      };\n    }\n\n    this[kOptions] = { ...util.deepClone(options),\n      connect\n    };\n    this[kMaxRedirections] = maxRedirections;\n    this[kFactory] = factory;\n    this[kClients] = new Map();\n    this[kFinalizer] = new FinalizationRegistry(\n    /* istanbul ignore next: gc is undeterministic */\n    key => {\n      const ref = this[kClients].get(key);\n\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key);\n      }\n    });\n    this[kClosed] = false;\n    this[kDestroyed] = false;\n    const agent = this;\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets]);\n    };\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets]);\n    };\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err);\n    };\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err);\n    };\n  }\n\n  get [kRunning]() {\n    let ret = 0;\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore next: gc is undeterministic */\n\n      if (client) {\n        ret += client[kRunning];\n      }\n    }\n\n    return ret;\n  }\n\n  dispatch(opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.');\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.');\n      }\n\n      let key;\n\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin);\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.');\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError();\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError();\n      }\n\n      const ref = this[kClients].get(key);\n      let dispatcher = ref ? ref.deref() : null;\n\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions]).on('drain', this[kOnDrain]).on('connect', this[kOnConnect]).on('disconnect', this[kOnDisconnect]).on('connectionError', this[kOnConnectionError]);\n        this[kClients].set(key, new WeakRef(dispatcher));\n        this[kFinalizer].register(dispatcher, key);\n      }\n\n      const {\n        maxRedirections = this[kMaxRedirections]\n      } = opts;\n\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts,\n          maxRedirections: 0\n        }; // Stop sub dispatcher from also redirecting.\n\n        handler = new RedirectHandler(this, maxRedirections, opts, handler);\n      }\n\n      return dispatcher.dispatch(opts, handler);\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method');\n      }\n\n      handler.onError(err);\n    }\n  }\n\n  get closed() {\n    return this[kClosed];\n  }\n\n  get destroyed() {\n    return this[kDestroyed];\n  }\n\n  close(callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function');\n    }\n\n    this[kClosed] = true;\n    const closePromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        closePromises.push(client.close());\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises);\n    } // Should never error.\n\n\n    Promise.all(closePromises).then(() => process.nextTick(callback));\n  }\n\n  destroy(err, callback) {\n    if (typeof err === 'function') {\n      callback = err;\n      err = null;\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function');\n    }\n\n    this[kClosed] = true;\n    this[kDestroyed] = true;\n    const destroyPromises = [];\n\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref();\n      /* istanbul ignore else: gc is undeterministic */\n\n      if (client) {\n        destroyPromises.push(client.destroy(err));\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises);\n    } // Should never error.\n\n\n    Promise.all(destroyPromises).then(() => process.nextTick(callback));\n  }\n\n}\n\nmodule.exports = Agent;","map":{"version":3,"names":["ClientClosedError","InvalidArgumentError","ClientDestroyedError","require","kClients","kRunning","Dispatcher","Pool","Client","util","RedirectHandler","WeakRef","FinalizationRegistry","kDestroyed","Symbol","kClosed","kOnConnect","kOnDisconnect","kOnConnectionError","kMaxRedirections","kOnDrain","kFactory","kFinalizer","kOptions","defaultFactory","origin","opts","connections","Agent","constructor","factory","maxRedirections","connect","options","Number","isInteger","deepClone","Map","key","ref","get","undefined","deref","delete","agent","targets","emit","err","ret","values","client","dispatch","handler","URL","String","dispatcher","on","set","register","onError","closed","destroyed","close","callback","closePromises","push","Promise","all","then","process","nextTick","destroy","destroyPromises","module","exports"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/agent.js"],"sourcesContent":["'use strict'\n\nconst {\n  ClientClosedError,\n  InvalidArgumentError,\n  ClientDestroyedError\n} = require('./core/errors')\nconst { kClients, kRunning } = require('./core/symbols')\nconst Dispatcher = require('./dispatcher')\nconst Pool = require('./pool')\nconst Client = require('./client')\nconst util = require('./core/util')\nconst RedirectHandler = require('./handler/redirect')\nconst { WeakRef, FinalizationRegistry } = require('./compat/dispatcher-weakref')()\n\nconst kDestroyed = Symbol('destroyed')\nconst kClosed = Symbol('closed')\nconst kOnConnect = Symbol('onConnect')\nconst kOnDisconnect = Symbol('onDisconnect')\nconst kOnConnectionError = Symbol('onConnectionError')\nconst kMaxRedirections = Symbol('maxRedirections')\nconst kOnDrain = Symbol('onDrain')\nconst kFactory = Symbol('factory')\nconst kFinalizer = Symbol('finalizer')\nconst kOptions = Symbol('options')\n\nfunction defaultFactory (origin, opts) {\n  return opts && opts.connections === 1\n    ? new Client(origin, opts)\n    : new Pool(origin, opts)\n}\n\nclass Agent extends Dispatcher {\n  constructor ({ factory = defaultFactory, maxRedirections = 0, connect, ...options } = {}) {\n    super()\n\n    if (typeof factory !== 'function') {\n      throw new InvalidArgumentError('factory must be a function.')\n    }\n\n    if (connect != null && typeof connect !== 'function' && typeof connect !== 'object') {\n      throw new InvalidArgumentError('connect must be a function or an object')\n    }\n\n    if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {\n      throw new InvalidArgumentError('maxRedirections must be a positive number')\n    }\n\n    if (connect && typeof connect !== 'function') {\n      connect = { ...connect }\n    }\n\n    this[kOptions] = { ...util.deepClone(options), connect }\n    this[kMaxRedirections] = maxRedirections\n    this[kFactory] = factory\n    this[kClients] = new Map()\n    this[kFinalizer] = new FinalizationRegistry(/* istanbul ignore next: gc is undeterministic */ key => {\n      const ref = this[kClients].get(key)\n      if (ref !== undefined && ref.deref() === undefined) {\n        this[kClients].delete(key)\n      }\n    })\n    this[kClosed] = false\n    this[kDestroyed] = false\n\n    const agent = this\n\n    this[kOnDrain] = (origin, targets) => {\n      agent.emit('drain', origin, [agent, ...targets])\n    }\n\n    this[kOnConnect] = (origin, targets) => {\n      agent.emit('connect', origin, [agent, ...targets])\n    }\n\n    this[kOnDisconnect] = (origin, targets, err) => {\n      agent.emit('disconnect', origin, [agent, ...targets], err)\n    }\n\n    this[kOnConnectionError] = (origin, targets, err) => {\n      agent.emit('connectionError', origin, [agent, ...targets], err)\n    }\n  }\n\n  get [kRunning] () {\n    let ret = 0\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore next: gc is undeterministic */\n      if (client) {\n        ret += client[kRunning]\n      }\n    }\n    return ret\n  }\n\n  dispatch (opts, handler) {\n    if (!handler || typeof handler !== 'object') {\n      throw new InvalidArgumentError('handler must be an object.')\n    }\n\n    try {\n      if (!opts || typeof opts !== 'object') {\n        throw new InvalidArgumentError('opts must be an object.')\n      }\n\n      let key\n      if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {\n        key = String(opts.origin)\n      } else {\n        throw new InvalidArgumentError('opts.origin must be a non-empty string or URL.')\n      }\n\n      if (this[kDestroyed]) {\n        throw new ClientDestroyedError()\n      }\n\n      if (this[kClosed]) {\n        throw new ClientClosedError()\n      }\n\n      const ref = this[kClients].get(key)\n\n      let dispatcher = ref ? ref.deref() : null\n      if (!dispatcher) {\n        dispatcher = this[kFactory](opts.origin, this[kOptions])\n          .on('drain', this[kOnDrain])\n          .on('connect', this[kOnConnect])\n          .on('disconnect', this[kOnDisconnect])\n          .on('connectionError', this[kOnConnectionError])\n\n        this[kClients].set(key, new WeakRef(dispatcher))\n        this[kFinalizer].register(dispatcher, key)\n      }\n\n      const { maxRedirections = this[kMaxRedirections] } = opts\n      if (maxRedirections != null && maxRedirections !== 0) {\n        opts = { ...opts, maxRedirections: 0 } // Stop sub dispatcher from also redirecting.\n        handler = new RedirectHandler(this, maxRedirections, opts, handler)\n      }\n\n      return dispatcher.dispatch(opts, handler)\n    } catch (err) {\n      if (typeof handler.onError !== 'function') {\n        throw new InvalidArgumentError('invalid onError method')\n      }\n\n      handler.onError(err)\n    }\n  }\n\n  get closed () {\n    return this[kClosed]\n  }\n\n  get destroyed () {\n    return this[kDestroyed]\n  }\n\n  close (callback) {\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n\n    const closePromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        closePromises.push(client.close())\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(closePromises)\n    }\n\n    // Should never error.\n    Promise.all(closePromises).then(() => process.nextTick(callback))\n  }\n\n  destroy (err, callback) {\n    if (typeof err === 'function') {\n      callback = err\n      err = null\n    }\n\n    if (callback != null && typeof callback !== 'function') {\n      throw new InvalidArgumentError('callback must be a function')\n    }\n\n    this[kClosed] = true\n    this[kDestroyed] = true\n\n    const destroyPromises = []\n    for (const ref of this[kClients].values()) {\n      const client = ref.deref()\n      /* istanbul ignore else: gc is undeterministic */\n      if (client) {\n        destroyPromises.push(client.destroy(err))\n      }\n    }\n\n    if (!callback) {\n      return Promise.all(destroyPromises)\n    }\n\n    // Should never error.\n    Promise.all(destroyPromises).then(() => process.nextTick(callback))\n  }\n}\n\nmodule.exports = Agent\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}