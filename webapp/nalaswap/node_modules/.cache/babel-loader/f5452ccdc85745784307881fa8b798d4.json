{"ast":null,"code":"'use strict';\n\nconst Readable = require('./readable');\n\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors');\n\nconst util = require('../core/util');\n\nconst {\n  AsyncResource\n} = require('async_hooks');\n\nconst {\n  addSignal,\n  removeSignal\n} = require('./abort-signal');\n\nclass RequestHandler extends AsyncResource {\n  constructor(opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts');\n    }\n\n    const {\n      signal,\n      method,\n      opaque,\n      body,\n      onInfo,\n      responseHeaders\n    } = opts;\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback');\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget');\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method');\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback');\n      }\n\n      super('UNDICI_REQUEST');\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err);\n      }\n\n      throw err;\n    }\n\n    this.responseHeaders = responseHeaders || null;\n    this.opaque = opaque || null;\n    this.callback = callback;\n    this.res = null;\n    this.abort = null;\n    this.body = body;\n    this.trailers = {};\n    this.context = null;\n    this.onInfo = onInfo || null;\n\n    if (util.isStream(body)) {\n      body.on('error', err => {\n        this.onError(err);\n      });\n    }\n\n    addSignal(this, signal);\n  }\n\n  onConnect(abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError();\n    }\n\n    this.abort = abort;\n    this.context = context;\n  }\n\n  onHeaders(statusCode, rawHeaders, resume) {\n    const {\n      callback,\n      opaque,\n      abort,\n      context\n    } = this;\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n        this.onInfo({\n          statusCode,\n          headers\n        });\n      }\n\n      return;\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders);\n    const body = new Readable(resume, abort, parsedHeaders['content-type']);\n    this.callback = null;\n    this.res = body;\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders);\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    });\n  }\n\n  onData(chunk) {\n    const {\n      res\n    } = this;\n    return res.push(chunk);\n  }\n\n  onComplete(trailers) {\n    const {\n      res\n    } = this;\n    removeSignal(this);\n    util.parseHeaders(trailers, this.trailers);\n    res.push(null);\n  }\n\n  onError(err) {\n    const {\n      res,\n      callback,\n      body,\n      opaque\n    } = this;\n    removeSignal(this);\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null;\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, {\n          opaque\n        });\n      });\n    }\n\n    if (res) {\n      this.res = null; // Ensure all queued handlers are invoked before destroying res.\n\n      queueMicrotask(() => {\n        util.destroy(res, err);\n      });\n    }\n\n    if (body) {\n      this.body = null;\n      util.destroy(body, err);\n    }\n  }\n\n}\n\nfunction request(opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data);\n      });\n    });\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback));\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err;\n    }\n\n    const opaque = opts && opts.opaque;\n    queueMicrotask(() => callback(err, {\n      opaque\n    }));\n  }\n}\n\nmodule.exports = request;","map":{"version":3,"names":["Readable","require","InvalidArgumentError","RequestAbortedError","util","AsyncResource","addSignal","removeSignal","RequestHandler","constructor","opts","callback","signal","method","opaque","body","onInfo","responseHeaders","on","addEventListener","err","isStream","destroy","nop","res","abort","trailers","context","onError","onConnect","onHeaders","statusCode","rawHeaders","resume","headers","parseRawHeaders","parseHeaders","parsedHeaders","runInAsyncScope","onData","chunk","push","onComplete","queueMicrotask","request","undefined","Promise","resolve","reject","call","data","dispatch","module","exports"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/api/api-request.js"],"sourcesContent":["'use strict'\n\nconst Readable = require('./readable')\nconst {\n  InvalidArgumentError,\n  RequestAbortedError\n} = require('../core/errors')\nconst util = require('../core/util')\nconst { AsyncResource } = require('async_hooks')\nconst { addSignal, removeSignal } = require('./abort-signal')\n\nclass RequestHandler extends AsyncResource {\n  constructor (opts, callback) {\n    if (!opts || typeof opts !== 'object') {\n      throw new InvalidArgumentError('invalid opts')\n    }\n\n    const { signal, method, opaque, body, onInfo, responseHeaders } = opts\n\n    try {\n      if (typeof callback !== 'function') {\n        throw new InvalidArgumentError('invalid callback')\n      }\n\n      if (signal && typeof signal.on !== 'function' && typeof signal.addEventListener !== 'function') {\n        throw new InvalidArgumentError('signal must be an EventEmitter or EventTarget')\n      }\n\n      if (method === 'CONNECT') {\n        throw new InvalidArgumentError('invalid method')\n      }\n\n      if (onInfo && typeof onInfo !== 'function') {\n        throw new InvalidArgumentError('invalid onInfo callback')\n      }\n\n      super('UNDICI_REQUEST')\n    } catch (err) {\n      if (util.isStream(body)) {\n        util.destroy(body.on('error', util.nop), err)\n      }\n      throw err\n    }\n\n    this.responseHeaders = responseHeaders || null\n    this.opaque = opaque || null\n    this.callback = callback\n    this.res = null\n    this.abort = null\n    this.body = body\n    this.trailers = {}\n    this.context = null\n    this.onInfo = onInfo || null\n\n    if (util.isStream(body)) {\n      body.on('error', (err) => {\n        this.onError(err)\n      })\n    }\n\n    addSignal(this, signal)\n  }\n\n  onConnect (abort, context) {\n    if (!this.callback) {\n      throw new RequestAbortedError()\n    }\n\n    this.abort = abort\n    this.context = context\n  }\n\n  onHeaders (statusCode, rawHeaders, resume) {\n    const { callback, opaque, abort, context } = this\n\n    if (statusCode < 200) {\n      if (this.onInfo) {\n        const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n        this.onInfo({ statusCode, headers })\n      }\n      return\n    }\n\n    const parsedHeaders = util.parseHeaders(rawHeaders)\n    const body = new Readable(resume, abort, parsedHeaders['content-type'])\n\n    this.callback = null\n    this.res = body\n    const headers = this.responseHeaders === 'raw' ? util.parseRawHeaders(rawHeaders) : util.parseHeaders(rawHeaders)\n\n    this.runInAsyncScope(callback, null, null, {\n      statusCode,\n      headers,\n      trailers: this.trailers,\n      opaque,\n      body,\n      context\n    })\n  }\n\n  onData (chunk) {\n    const { res } = this\n    return res.push(chunk)\n  }\n\n  onComplete (trailers) {\n    const { res } = this\n\n    removeSignal(this)\n\n    util.parseHeaders(trailers, this.trailers)\n\n    res.push(null)\n  }\n\n  onError (err) {\n    const { res, callback, body, opaque } = this\n\n    removeSignal(this)\n\n    if (callback) {\n      // TODO: Does this need queueMicrotask?\n      this.callback = null\n      queueMicrotask(() => {\n        this.runInAsyncScope(callback, null, err, { opaque })\n      })\n    }\n\n    if (res) {\n      this.res = null\n      // Ensure all queued handlers are invoked before destroying res.\n      queueMicrotask(() => {\n        util.destroy(res, err)\n      })\n    }\n\n    if (body) {\n      this.body = null\n      util.destroy(body, err)\n    }\n  }\n}\n\nfunction request (opts, callback) {\n  if (callback === undefined) {\n    return new Promise((resolve, reject) => {\n      request.call(this, opts, (err, data) => {\n        return err ? reject(err) : resolve(data)\n      })\n    })\n  }\n\n  try {\n    this.dispatch(opts, new RequestHandler(opts, callback))\n  } catch (err) {\n    if (typeof callback !== 'function') {\n      throw err\n    }\n    const opaque = opts && opts.opaque\n    queueMicrotask(() => callback(err, { opaque }))\n  }\n}\n\nmodule.exports = request\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}