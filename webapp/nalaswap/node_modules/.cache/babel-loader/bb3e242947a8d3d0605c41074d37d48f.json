{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = global || self, factory(global.Diff = {}));\n})(this, function (exports) {\n  'use strict';\n\n  function Diff() {}\n\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  } //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  } // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n\n\n  function distanceIterator(start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange; // If we have previous context, start with that\n\n\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2; // Overlapping\n\n\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3; // end the range and output\n\n\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines; // Mine inserted\n\n\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2; // Theirs inserted\n\n\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\n\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","define","amd","self","Diff","prototype","diff","oldString","newString","options","arguments","length","undefined","callback","done","value","setTimeout","castInput","removeEmpty","tokenize","newLen","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","join","count","execEditLength","diagonalPath","basePath","addPath","removePath","_oldPos","canAdd","canRemove","clonePath","pushComponent","buildValues","useLongestToken","exec","ret","added","removed","last","push","commonCount","equals","left","right","comparator","ignoreCase","toLowerCase","array","i","split","chars","componentPos","componentLen","component","slice","map","oldValue","tmp","lastComponent","pop","path","characterDiff","diffChars","oldStr","newStr","generateOptions","defaults","name","hasOwnProperty","extendedWordChars","reWhitespace","wordDiff","ignoreWhitespace","test","tokens","splice","diffWords","diffWordsWithSpace","lineDiff","retLines","linesAndNewlines","line","newlineIsToken","trim","diffLines","diffTrimmedLines","sentenceDiff","diffSentences","cssDiff","diffCss","_typeof","obj","Symbol","iterator","constructor","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","Object","from","o","minLen","n","toString","call","len","arr2","TypeError","objectPrototypeToString","jsonDiff","_this$options","undefinedReplacement","_this$options$stringi","stringifyReplacer","k","v","JSON","stringify","canonicalize","replace","diffJson","oldObj","newObj","stack","replacementStack","replacer","key","canonicalizedObj","toJSON","sortedKeys","_key","sort","arrayDiff","diffArrays","oldArr","newArr","parsePatch","uniDiff","diffstr","delimiters","match","list","parseIndex","index","header","parseFileHeader","hunks","_line","parseHunk","strict","Error","fileHeader","keyPrefix","data","fileName","substr","chunkHeaderIndex","chunkHeaderLine","chunkHeader","hunk","oldStart","oldLines","newStart","newLines","lines","linedelimiters","addCount","removeCount","indexOf","operation","distanceIterator","start","minLine","maxLine","wantForward","backwardExhausted","forwardExhausted","localOffset","applyPatch","source","compareLine","lineNumber","patchContent","errorCount","fuzzFactor","offset","removeEOFNL","addEOFNL","hunkFits","toPos","j","content","diffOffset","_i","_hunk","_toPos","delimiter","previousOperation","_k","applyPatches","currentIndex","processIndex","complete","loadFile","err","updatedContent","patched","structuredPatch","oldFileName","newFileName","oldHeader","newHeader","context","contextLines","entry","oldRangeStart","newRangeStart","curRange","oldLine","newLine","_loop","current","_curRange","prev","apply","_curRange2","_curRange3","contextSize","Math","min","oldEOFNewline","newEOFNewline","noNlBeforeAdds","formatPatch","createTwoFilesPatch","createPatch","arrayEqual","a","b","arrayStartsWith","calcLineCount","_calcOldNewLineCount","calcOldNewLineCount","merge","mine","theirs","base","loadPatch","fileNameChanged","selectField","mineIndex","theirsIndex","mineOffset","theirsOffset","mineCurrent","Infinity","theirsCurrent","hunkBefore","cloneHunk","mergedHunk","mergeLines","param","patch","conflict","check","mineLines","theirOffset","theirLines","their","insertLeading","theirCurrent","mutualChange","_hunk$lines","collectChange","_hunk$lines2","removal","insertTrailing","myChanges","theirChanges","allRemoves","skipRemoveSuperset","_hunk$lines3","_hunk$lines4","_hunk$lines5","swap","collectContext","merged","_hunk$lines6","insert","state","matchChanges","changes","matchIndex","contextChanges","conflicted","change","reduce","removeChanges","delta","changeContent","forEach","myCount","theirCount","convertChangesToDMP","convertChangesToXML","escapeHTML","s","defineProperty"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/diff/dist/diff.js"],"sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.Diff = {}));\n}(this, (function (exports) { 'use strict';\n\n  function Diff() {}\n  Diff.prototype = {\n    diff: function diff(oldString, newString) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var callback = options.callback;\n\n      if (typeof options === 'function') {\n        callback = options;\n        options = {};\n      }\n\n      this.options = options;\n      var self = this;\n\n      function done(value) {\n        if (callback) {\n          setTimeout(function () {\n            callback(undefined, value);\n          }, 0);\n          return true;\n        } else {\n          return value;\n        }\n      } // Allow subclasses to massage the input prior to running\n\n\n      oldString = this.castInput(oldString);\n      newString = this.castInput(newString);\n      oldString = this.removeEmpty(this.tokenize(oldString));\n      newString = this.removeEmpty(this.tokenize(newString));\n      var newLen = newString.length,\n          oldLen = oldString.length;\n      var editLength = 1;\n      var maxEditLength = newLen + oldLen;\n      var bestPath = [{\n        newPos: -1,\n        components: []\n      }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\n      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n        // Identity per the equality and tokenizer\n        return done([{\n          value: this.join(newString),\n          count: newString.length\n        }]);\n      } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n      function execEditLength() {\n        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n          var basePath = void 0;\n\n          var addPath = bestPath[diagonalPath - 1],\n              removePath = bestPath[diagonalPath + 1],\n              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n          if (addPath) {\n            // No one else is going to attempt to use this value, clear it\n            bestPath[diagonalPath - 1] = undefined;\n          }\n\n          var canAdd = addPath && addPath.newPos + 1 < newLen,\n              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\n          if (!canAdd && !canRemove) {\n            // If this path is a terminal then prune\n            bestPath[diagonalPath] = undefined;\n            continue;\n          } // Select the diagonal that we want to branch from. We select the prior\n          // path whose position in the new string is the farthest from the origin\n          // and does not pass the bounds of the diff graph\n\n\n          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n            basePath = clonePath(removePath);\n            self.pushComponent(basePath.components, undefined, true);\n          } else {\n            basePath = addPath; // No need to clone, we've pulled it from the list\n\n            basePath.newPos++;\n            self.pushComponent(basePath.components, true, undefined);\n          }\n\n          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done\n\n          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n          } else {\n            // Otherwise track this path as a potential candidate and continue.\n            bestPath[diagonalPath] = basePath;\n          }\n        }\n\n        editLength++;\n      } // Performs the length of edit iteration. Is a bit fugly as this has to support the\n      // sync and async mode which is never fun. Loops over execEditLength until a value\n      // is produced.\n\n\n      if (callback) {\n        (function exec() {\n          setTimeout(function () {\n            // This should not happen, but we want to be safe.\n\n            /* istanbul ignore next */\n            if (editLength > maxEditLength) {\n              return callback();\n            }\n\n            if (!execEditLength()) {\n              exec();\n            }\n          }, 0);\n        })();\n      } else {\n        while (editLength <= maxEditLength) {\n          var ret = execEditLength();\n\n          if (ret) {\n            return ret;\n          }\n        }\n      }\n    },\n    pushComponent: function pushComponent(components, added, removed) {\n      var last = components[components.length - 1];\n\n      if (last && last.added === added && last.removed === removed) {\n        // We need to clone here as the component clone operation is just\n        // as shallow array clone\n        components[components.length - 1] = {\n          count: last.count + 1,\n          added: added,\n          removed: removed\n        };\n      } else {\n        components.push({\n          count: 1,\n          added: added,\n          removed: removed\n        });\n      }\n    },\n    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n      var newLen = newString.length,\n          oldLen = oldString.length,\n          newPos = basePath.newPos,\n          oldPos = newPos - diagonalPath,\n          commonCount = 0;\n\n      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n        newPos++;\n        oldPos++;\n        commonCount++;\n      }\n\n      if (commonCount) {\n        basePath.components.push({\n          count: commonCount\n        });\n      }\n\n      basePath.newPos = newPos;\n      return oldPos;\n    },\n    equals: function equals(left, right) {\n      if (this.options.comparator) {\n        return this.options.comparator(left, right);\n      } else {\n        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n      }\n    },\n    removeEmpty: function removeEmpty(array) {\n      var ret = [];\n\n      for (var i = 0; i < array.length; i++) {\n        if (array[i]) {\n          ret.push(array[i]);\n        }\n      }\n\n      return ret;\n    },\n    castInput: function castInput(value) {\n      return value;\n    },\n    tokenize: function tokenize(value) {\n      return value.split('');\n    },\n    join: function join(chars) {\n      return chars.join('');\n    }\n  };\n\n  function buildValues(diff, components, newString, oldString, useLongestToken) {\n    var componentPos = 0,\n        componentLen = components.length,\n        newPos = 0,\n        oldPos = 0;\n\n    for (; componentPos < componentLen; componentPos++) {\n      var component = components[componentPos];\n\n      if (!component.removed) {\n        if (!component.added && useLongestToken) {\n          var value = newString.slice(newPos, newPos + component.count);\n          value = value.map(function (value, i) {\n            var oldValue = oldString[oldPos + i];\n            return oldValue.length > value.length ? oldValue : value;\n          });\n          component.value = diff.join(value);\n        } else {\n          component.value = diff.join(newString.slice(newPos, newPos + component.count));\n        }\n\n        newPos += component.count; // Common case\n\n        if (!component.added) {\n          oldPos += component.count;\n        }\n      } else {\n        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention\n        // The diffing algorithm is tied to add then remove output and this is the simplest\n        // route to get the desired output with minimal overhead.\n\n        if (componentPos && components[componentPos - 1].added) {\n          var tmp = components[componentPos - 1];\n          components[componentPos - 1] = components[componentPos];\n          components[componentPos] = tmp;\n        }\n      }\n    } // Special case handle for when one terminal is ignored (i.e. whitespace).\n    // For this case we merge the terminal into the prior string and drop the change.\n    // This is only available for string mode.\n\n\n    var lastComponent = components[componentLen - 1];\n\n    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n      components[componentLen - 2].value += lastComponent.value;\n      components.pop();\n    }\n\n    return components;\n  }\n\n  function clonePath(path) {\n    return {\n      newPos: path.newPos,\n      components: path.components.slice(0)\n    };\n  }\n\n  var characterDiff = new Diff();\n  function diffChars(oldStr, newStr, options) {\n    return characterDiff.diff(oldStr, newStr, options);\n  }\n\n  function generateOptions(options, defaults) {\n    if (typeof options === 'function') {\n      defaults.callback = options;\n    } else if (options) {\n      for (var name in options) {\n        /* istanbul ignore else */\n        if (options.hasOwnProperty(name)) {\n          defaults[name] = options[name];\n        }\n      }\n    }\n\n    return defaults;\n  }\n\n  //\n  // Ranges and exceptions:\n  // Latin-1 Supplement, 0080–00FF\n  //  - U+00D7  × Multiplication sign\n  //  - U+00F7  ÷ Division sign\n  // Latin Extended-A, 0100–017F\n  // Latin Extended-B, 0180–024F\n  // IPA Extensions, 0250–02AF\n  // Spacing Modifier Letters, 02B0–02FF\n  //  - U+02C7  ˇ &#711;  Caron\n  //  - U+02D8  ˘ &#728;  Breve\n  //  - U+02D9  ˙ &#729;  Dot Above\n  //  - U+02DA  ˚ &#730;  Ring Above\n  //  - U+02DB  ˛ &#731;  Ogonek\n  //  - U+02DC  ˜ &#732;  Small Tilde\n  //  - U+02DD  ˝ &#733;  Double Acute Accent\n  // Latin Extended Additional, 1E00–1EFF\n\n  var extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n  var reWhitespace = /\\S/;\n  var wordDiff = new Diff();\n\n  wordDiff.equals = function (left, right) {\n    if (this.options.ignoreCase) {\n      left = left.toLowerCase();\n      right = right.toLowerCase();\n    }\n\n    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n  };\n\n  wordDiff.tokenize = function (value) {\n    // All whitespace symbols except newline group into one token, each newline - in separate token\n    var tokens = value.split(/([^\\S\\r\\n]+|[()[\\]{}'\"\\r\\n]|\\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\n    for (var i = 0; i < tokens.length - 1; i++) {\n      // If we have an empty string in the next field and we have only word chars before and after, merge\n      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n        tokens[i] += tokens[i + 2];\n        tokens.splice(i + 1, 2);\n        i--;\n      }\n    }\n\n    return tokens;\n  };\n\n  function diffWords(oldStr, newStr, options) {\n    options = generateOptions(options, {\n      ignoreWhitespace: true\n    });\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n  function diffWordsWithSpace(oldStr, newStr, options) {\n    return wordDiff.diff(oldStr, newStr, options);\n  }\n\n  var lineDiff = new Diff();\n\n  lineDiff.tokenize = function (value) {\n    var retLines = [],\n        linesAndNewlines = value.split(/(\\n|\\r\\n)/); // Ignore the final empty token that occurs if the string ends with a new line\n\n    if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n      linesAndNewlines.pop();\n    } // Merge the content and line separators into single tokens\n\n\n    for (var i = 0; i < linesAndNewlines.length; i++) {\n      var line = linesAndNewlines[i];\n\n      if (i % 2 && !this.options.newlineIsToken) {\n        retLines[retLines.length - 1] += line;\n      } else {\n        if (this.options.ignoreWhitespace) {\n          line = line.trim();\n        }\n\n        retLines.push(line);\n      }\n    }\n\n    return retLines;\n  };\n\n  function diffLines(oldStr, newStr, callback) {\n    return lineDiff.diff(oldStr, newStr, callback);\n  }\n  function diffTrimmedLines(oldStr, newStr, callback) {\n    var options = generateOptions(callback, {\n      ignoreWhitespace: true\n    });\n    return lineDiff.diff(oldStr, newStr, options);\n  }\n\n  var sentenceDiff = new Diff();\n\n  sentenceDiff.tokenize = function (value) {\n    return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n  };\n\n  function diffSentences(oldStr, newStr, callback) {\n    return sentenceDiff.diff(oldStr, newStr, callback);\n  }\n\n  var cssDiff = new Diff();\n\n  cssDiff.tokenize = function (value) {\n    return value.split(/([{}:;,]|\\s+)/);\n  };\n\n  function diffCss(oldStr, newStr, callback) {\n    return cssDiff.diff(oldStr, newStr, callback);\n  }\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n  }\n\n  function _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n  }\n\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var objectPrototypeToString = Object.prototype.toString;\n  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\n  jsonDiff.useLongestToken = true;\n  jsonDiff.tokenize = lineDiff.tokenize;\n\n  jsonDiff.castInput = function (value) {\n    var _this$options = this.options,\n        undefinedReplacement = _this$options.undefinedReplacement,\n        _this$options$stringi = _this$options.stringifyReplacer,\n        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {\n      return typeof v === 'undefined' ? undefinedReplacement : v;\n    } : _this$options$stringi;\n    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n  };\n\n  jsonDiff.equals = function (left, right) {\n    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'));\n  };\n\n  function diffJson(oldObj, newObj, options) {\n    return jsonDiff.diff(oldObj, newObj, options);\n  } // This function handles the presence of circular references by bailing out when encountering an\n  // object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\n  function canonicalize(obj, stack, replacementStack, replacer, key) {\n    stack = stack || [];\n    replacementStack = replacementStack || [];\n\n    if (replacer) {\n      obj = replacer(key, obj);\n    }\n\n    var i;\n\n    for (i = 0; i < stack.length; i += 1) {\n      if (stack[i] === obj) {\n        return replacementStack[i];\n      }\n    }\n\n    var canonicalizedObj;\n\n    if ('[object Array]' === objectPrototypeToString.call(obj)) {\n      stack.push(obj);\n      canonicalizedObj = new Array(obj.length);\n      replacementStack.push(canonicalizedObj);\n\n      for (i = 0; i < obj.length; i += 1) {\n        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n      return canonicalizedObj;\n    }\n\n    if (obj && obj.toJSON) {\n      obj = obj.toJSON();\n    }\n\n    if (_typeof(obj) === 'object' && obj !== null) {\n      stack.push(obj);\n      canonicalizedObj = {};\n      replacementStack.push(canonicalizedObj);\n\n      var sortedKeys = [],\n          _key;\n\n      for (_key in obj) {\n        /* istanbul ignore else */\n        if (obj.hasOwnProperty(_key)) {\n          sortedKeys.push(_key);\n        }\n      }\n\n      sortedKeys.sort();\n\n      for (i = 0; i < sortedKeys.length; i += 1) {\n        _key = sortedKeys[i];\n        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n      }\n\n      stack.pop();\n      replacementStack.pop();\n    } else {\n      canonicalizedObj = obj;\n    }\n\n    return canonicalizedObj;\n  }\n\n  var arrayDiff = new Diff();\n\n  arrayDiff.tokenize = function (value) {\n    return value.slice();\n  };\n\n  arrayDiff.join = arrayDiff.removeEmpty = function (value) {\n    return value;\n  };\n\n  function diffArrays(oldArr, newArr, callback) {\n    return arrayDiff.diff(oldArr, newArr, callback);\n  }\n\n  function parsePatch(uniDiff) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        list = [],\n        i = 0;\n\n    function parseIndex() {\n      var index = {};\n      list.push(index); // Parse diff metadata\n\n      while (i < diffstr.length) {\n        var line = diffstr[i]; // File header found, end parsing diff metadata\n\n        if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n          break;\n        } // Diff index\n\n\n        var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\n        if (header) {\n          index.index = header[1];\n        }\n\n        i++;\n      } // Parse file headers if they are defined. Unified diff requires them, but\n      // there's no technical issues to have an isolated hunk without file header\n\n\n      parseFileHeader(index);\n      parseFileHeader(index); // Parse hunks\n\n      index.hunks = [];\n\n      while (i < diffstr.length) {\n        var _line = diffstr[i];\n\n        if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n          break;\n        } else if (/^@@/.test(_line)) {\n          index.hunks.push(parseHunk());\n        } else if (_line && options.strict) {\n          // Ignore unexpected content unless in strict mode\n          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n        } else {\n          i++;\n        }\n      }\n    } // Parses the --- and +++ headers, if none are found, no lines\n    // are consumed.\n\n\n    function parseFileHeader(index) {\n      var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\n      if (fileHeader) {\n        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n        var data = fileHeader[2].split('\\t', 2);\n        var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\n        if (/^\".*\"$/.test(fileName)) {\n          fileName = fileName.substr(1, fileName.length - 2);\n        }\n\n        index[keyPrefix + 'FileName'] = fileName;\n        index[keyPrefix + 'Header'] = (data[1] || '').trim();\n        i++;\n      }\n    } // Parses a hunk\n    // This assumes that we are at the start of a hunk.\n\n\n    function parseHunk() {\n      var chunkHeaderIndex = i,\n          chunkHeaderLine = diffstr[i++],\n          chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n      var hunk = {\n        oldStart: +chunkHeader[1],\n        oldLines: typeof chunkHeader[2] === 'undefined' ? 1 : +chunkHeader[2],\n        newStart: +chunkHeader[3],\n        newLines: typeof chunkHeader[4] === 'undefined' ? 1 : +chunkHeader[4],\n        lines: [],\n        linedelimiters: []\n      }; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart += 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart += 1;\n      }\n\n      var addCount = 0,\n          removeCount = 0;\n\n      for (; i < diffstr.length; i++) {\n        // Lines starting with '---' could be mistaken for the \"remove line\" operation\n        // But they could be the header for the next file. Therefore prune such cases out.\n        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n          break;\n        }\n\n        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n          hunk.lines.push(diffstr[i]);\n          hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n          if (operation === '+') {\n            addCount++;\n          } else if (operation === '-') {\n            removeCount++;\n          } else if (operation === ' ') {\n            addCount++;\n            removeCount++;\n          }\n        } else {\n          break;\n        }\n      } // Handle the empty block count case\n\n\n      if (!addCount && hunk.newLines === 1) {\n        hunk.newLines = 0;\n      }\n\n      if (!removeCount && hunk.oldLines === 1) {\n        hunk.oldLines = 0;\n      } // Perform optional sanity checking\n\n\n      if (options.strict) {\n        if (addCount !== hunk.newLines) {\n          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n\n        if (removeCount !== hunk.oldLines) {\n          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n        }\n      }\n\n      return hunk;\n    }\n\n    while (i < diffstr.length) {\n      parseIndex();\n    }\n\n    return list;\n  }\n\n  // Iterator that traverses in the range of [min, max], stepping\n  // by distance from a given start position. I.e. for [0, 4], with\n  // start of 2, this will iterate 2, 3, 1, 4, 0.\n  function distanceIterator (start, minLine, maxLine) {\n    var wantForward = true,\n        backwardExhausted = false,\n        forwardExhausted = false,\n        localOffset = 1;\n    return function iterator() {\n      if (wantForward && !forwardExhausted) {\n        if (backwardExhausted) {\n          localOffset++;\n        } else {\n          wantForward = false;\n        } // Check if trying to fit beyond text length, and if not, check it fits\n        // after offset location (or desired location on first iteration)\n\n\n        if (start + localOffset <= maxLine) {\n          return localOffset;\n        }\n\n        forwardExhausted = true;\n      }\n\n      if (!backwardExhausted) {\n        if (!forwardExhausted) {\n          wantForward = true;\n        } // Check if trying to fit before text beginning, and if not, check it fits\n        // before offset location\n\n\n        if (minLine <= start - localOffset) {\n          return -localOffset++;\n        }\n\n        backwardExhausted = true;\n        return iterator();\n      } // We tried to fit hunk before text beginning and beyond text length, then\n      // hunk can't fit on the text. Return undefined\n\n    };\n  }\n\n  function applyPatch(source, uniDiff) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    if (Array.isArray(uniDiff)) {\n      if (uniDiff.length > 1) {\n        throw new Error('applyPatch only works with a single input.');\n      }\n\n      uniDiff = uniDiff[0];\n    } // Apply the diff to the input\n\n\n    var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n        delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n        hunks = uniDiff.hunks,\n        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {\n      return line === patchContent;\n    },\n        errorCount = 0,\n        fuzzFactor = options.fuzzFactor || 0,\n        minLine = 0,\n        offset = 0,\n        removeEOFNL,\n        addEOFNL;\n    /**\n     * Checks if the hunk exactly fits on the provided location\n     */\n\n\n    function hunkFits(hunk, toPos) {\n      for (var j = 0; j < hunk.lines.length; j++) {\n        var line = hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line;\n\n        if (operation === ' ' || operation === '-') {\n          // Context sanity check\n          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n            errorCount++;\n\n            if (errorCount > fuzzFactor) {\n              return false;\n            }\n          }\n\n          toPos++;\n        }\n      }\n\n      return true;\n    } // Search best fit offsets for each hunk based on the previous ones\n\n\n    for (var i = 0; i < hunks.length; i++) {\n      var hunk = hunks[i],\n          maxLine = lines.length - hunk.oldLines,\n          localOffset = 0,\n          toPos = offset + hunk.oldStart - 1;\n      var iterator = distanceIterator(toPos, minLine, maxLine);\n\n      for (; localOffset !== undefined; localOffset = iterator()) {\n        if (hunkFits(hunk, toPos + localOffset)) {\n          hunk.offset = offset += localOffset;\n          break;\n        }\n      }\n\n      if (localOffset === undefined) {\n        return false;\n      } // Set lower text limit to end of the current hunk, so next ones don't try\n      // to fit over already patched text\n\n\n      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n    } // Apply patch hunks\n\n\n    var diffOffset = 0;\n\n    for (var _i = 0; _i < hunks.length; _i++) {\n      var _hunk = hunks[_i],\n          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\n      diffOffset += _hunk.newLines - _hunk.oldLines;\n\n      for (var j = 0; j < _hunk.lines.length; j++) {\n        var line = _hunk.lines[j],\n            operation = line.length > 0 ? line[0] : ' ',\n            content = line.length > 0 ? line.substr(1) : line,\n            delimiter = _hunk.linedelimiters[j];\n\n        if (operation === ' ') {\n          _toPos++;\n        } else if (operation === '-') {\n          lines.splice(_toPos, 1);\n          delimiters.splice(_toPos, 1);\n          /* istanbul ignore else */\n        } else if (operation === '+') {\n          lines.splice(_toPos, 0, content);\n          delimiters.splice(_toPos, 0, delimiter);\n          _toPos++;\n        } else if (operation === '\\\\') {\n          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\n          if (previousOperation === '+') {\n            removeEOFNL = true;\n          } else if (previousOperation === '-') {\n            addEOFNL = true;\n          }\n        }\n      }\n    } // Handle EOFNL insertion/removal\n\n\n    if (removeEOFNL) {\n      while (!lines[lines.length - 1]) {\n        lines.pop();\n        delimiters.pop();\n      }\n    } else if (addEOFNL) {\n      lines.push('');\n      delimiters.push('\\n');\n    }\n\n    for (var _k = 0; _k < lines.length - 1; _k++) {\n      lines[_k] = lines[_k] + delimiters[_k];\n    }\n\n    return lines.join('');\n  } // Wrapper that supports multiple file patches via callbacks.\n\n  function applyPatches(uniDiff, options) {\n    if (typeof uniDiff === 'string') {\n      uniDiff = parsePatch(uniDiff);\n    }\n\n    var currentIndex = 0;\n\n    function processIndex() {\n      var index = uniDiff[currentIndex++];\n\n      if (!index) {\n        return options.complete();\n      }\n\n      options.loadFile(index, function (err, data) {\n        if (err) {\n          return options.complete(err);\n        }\n\n        var updatedContent = applyPatch(data, index, options);\n        options.patched(index, updatedContent, function (err) {\n          if (err) {\n            return options.complete(err);\n          }\n\n          processIndex();\n        });\n      });\n    }\n\n    processIndex();\n  }\n\n  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    if (!options) {\n      options = {};\n    }\n\n    if (typeof options.context === 'undefined') {\n      options.context = 4;\n    }\n\n    var diff = diffLines(oldStr, newStr, options);\n    diff.push({\n      value: '',\n      lines: []\n    }); // Append an empty value to make cleanup easier\n\n    function contextLines(lines) {\n      return lines.map(function (entry) {\n        return ' ' + entry;\n      });\n    }\n\n    var hunks = [];\n    var oldRangeStart = 0,\n        newRangeStart = 0,\n        curRange = [],\n        oldLine = 1,\n        newLine = 1;\n\n    var _loop = function _loop(i) {\n      var current = diff[i],\n          lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n      current.lines = lines;\n\n      if (current.added || current.removed) {\n        var _curRange;\n\n        // If we have previous context, start with that\n        if (!oldRangeStart) {\n          var prev = diff[i - 1];\n          oldRangeStart = oldLine;\n          newRangeStart = newLine;\n\n          if (prev) {\n            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n            oldRangeStart -= curRange.length;\n            newRangeStart -= curRange.length;\n          }\n        } // Output our changes\n\n\n        (_curRange = curRange).push.apply(_curRange, _toConsumableArray(lines.map(function (entry) {\n          return (current.added ? '+' : '-') + entry;\n        }))); // Track the updated file position\n\n\n        if (current.added) {\n          newLine += lines.length;\n        } else {\n          oldLine += lines.length;\n        }\n      } else {\n        // Identical context lines. Track line changes\n        if (oldRangeStart) {\n          // Close out any changes that have been output (or join overlapping)\n          if (lines.length <= options.context * 2 && i < diff.length - 2) {\n            var _curRange2;\n\n            // Overlapping\n            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray(contextLines(lines)));\n          } else {\n            var _curRange3;\n\n            // end the range and output\n            var contextSize = Math.min(lines.length, options.context);\n\n            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray(contextLines(lines.slice(0, contextSize))));\n\n            var hunk = {\n              oldStart: oldRangeStart,\n              oldLines: oldLine - oldRangeStart + contextSize,\n              newStart: newRangeStart,\n              newLines: newLine - newRangeStart + contextSize,\n              lines: curRange\n            };\n\n            if (i >= diff.length - 2 && lines.length <= options.context) {\n              // EOF is inside this hunk\n              var oldEOFNewline = /\\n$/.test(oldStr);\n              var newEOFNewline = /\\n$/.test(newStr);\n              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;\n\n              if (!oldEOFNewline && noNlBeforeAdds && oldStr.length > 0) {\n                // special case: old has no eol and no trailing context; no-nl can end up before adds\n                // however, if the old file is empty, do not output the no-nl line\n                curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n              }\n\n              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {\n                curRange.push('\\\\ No newline at end of file');\n              }\n            }\n\n            hunks.push(hunk);\n            oldRangeStart = 0;\n            newRangeStart = 0;\n            curRange = [];\n          }\n        }\n\n        oldLine += lines.length;\n        newLine += lines.length;\n      }\n    };\n\n    for (var i = 0; i < diff.length; i++) {\n      _loop(i);\n    }\n\n    return {\n      oldFileName: oldFileName,\n      newFileName: newFileName,\n      oldHeader: oldHeader,\n      newHeader: newHeader,\n      hunks: hunks\n    };\n  }\n  function formatPatch(diff) {\n    var ret = [];\n\n    if (diff.oldFileName == diff.newFileName) {\n      ret.push('Index: ' + diff.oldFileName);\n    }\n\n    ret.push('===================================================================');\n    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n    for (var i = 0; i < diff.hunks.length; i++) {\n      var hunk = diff.hunks[i]; // Unified Diff Format quirk: If the chunk size is 0,\n      // the first number is one lower than one would expect.\n      // https://www.artima.com/weblogs/viewpost.jsp?thread=164293\n\n      if (hunk.oldLines === 0) {\n        hunk.oldStart -= 1;\n      }\n\n      if (hunk.newLines === 0) {\n        hunk.newStart -= 1;\n      }\n\n      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n      ret.push.apply(ret, hunk.lines);\n    }\n\n    return ret.join('\\n') + '\\n';\n  }\n  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return formatPatch(structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options));\n  }\n  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n  }\n\n  function arrayEqual(a, b) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    return arrayStartsWith(a, b);\n  }\n  function arrayStartsWith(array, start) {\n    if (start.length > array.length) {\n      return false;\n    }\n\n    for (var i = 0; i < start.length; i++) {\n      if (start[i] !== array[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function calcLineCount(hunk) {\n    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),\n        oldLines = _calcOldNewLineCount.oldLines,\n        newLines = _calcOldNewLineCount.newLines;\n\n    if (oldLines !== undefined) {\n      hunk.oldLines = oldLines;\n    } else {\n      delete hunk.oldLines;\n    }\n\n    if (newLines !== undefined) {\n      hunk.newLines = newLines;\n    } else {\n      delete hunk.newLines;\n    }\n  }\n  function merge(mine, theirs, base) {\n    mine = loadPatch(mine, base);\n    theirs = loadPatch(theirs, base);\n    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.\n    // Leaving sanity checks on this to the API consumer that may know more about the\n    // meaning in their own context.\n\n    if (mine.index || theirs.index) {\n      ret.index = mine.index || theirs.index;\n    }\n\n    if (mine.newFileName || theirs.newFileName) {\n      if (!fileNameChanged(mine)) {\n        // No header or no change in ours, use theirs (and ours if theirs does not exist)\n        ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n        ret.newFileName = theirs.newFileName || mine.newFileName;\n        ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n        ret.newHeader = theirs.newHeader || mine.newHeader;\n      } else if (!fileNameChanged(theirs)) {\n        // No header or no change in theirs, use ours\n        ret.oldFileName = mine.oldFileName;\n        ret.newFileName = mine.newFileName;\n        ret.oldHeader = mine.oldHeader;\n        ret.newHeader = mine.newHeader;\n      } else {\n        // Both changed... figure it out\n        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n      }\n    }\n\n    ret.hunks = [];\n    var mineIndex = 0,\n        theirsIndex = 0,\n        mineOffset = 0,\n        theirsOffset = 0;\n\n    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n      var mineCurrent = mine.hunks[mineIndex] || {\n        oldStart: Infinity\n      },\n          theirsCurrent = theirs.hunks[theirsIndex] || {\n        oldStart: Infinity\n      };\n\n      if (hunkBefore(mineCurrent, theirsCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n        mineIndex++;\n        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n      } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n        // This patch does not overlap with any of the others, yay.\n        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n        theirsIndex++;\n        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n      } else {\n        // Overlap, merge as best we can\n        var mergedHunk = {\n          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n          oldLines: 0,\n          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n          newLines: 0,\n          lines: []\n        };\n        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n        theirsIndex++;\n        mineIndex++;\n        ret.hunks.push(mergedHunk);\n      }\n    }\n\n    return ret;\n  }\n\n  function loadPatch(param, base) {\n    if (typeof param === 'string') {\n      if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n        return parsePatch(param)[0];\n      }\n\n      if (!base) {\n        throw new Error('Must provide a base reference or pass in a patch');\n      }\n\n      return structuredPatch(undefined, undefined, base, param);\n    }\n\n    return param;\n  }\n\n  function fileNameChanged(patch) {\n    return patch.newFileName && patch.newFileName !== patch.oldFileName;\n  }\n\n  function selectField(index, mine, theirs) {\n    if (mine === theirs) {\n      return mine;\n    } else {\n      index.conflict = true;\n      return {\n        mine: mine,\n        theirs: theirs\n      };\n    }\n  }\n\n  function hunkBefore(test, check) {\n    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n  }\n\n  function cloneHunk(hunk, offset) {\n    return {\n      oldStart: hunk.oldStart,\n      oldLines: hunk.oldLines,\n      newStart: hunk.newStart + offset,\n      newLines: hunk.newLines,\n      lines: hunk.lines\n    };\n  }\n\n  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n    // This will generally result in a conflicted hunk, but there are cases where the context\n    // is the only overlap where we can successfully merge the content here.\n    var mine = {\n      offset: mineOffset,\n      lines: mineLines,\n      index: 0\n    },\n        their = {\n      offset: theirOffset,\n      lines: theirLines,\n      index: 0\n    }; // Handle any leading content\n\n    insertLeading(hunk, mine, their);\n    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.\n\n    while (mine.index < mine.lines.length && their.index < their.lines.length) {\n      var mineCurrent = mine.lines[mine.index],\n          theirCurrent = their.lines[their.index];\n\n      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n        // Both modified ...\n        mutualChange(hunk, mine, their);\n      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n        var _hunk$lines;\n\n        // Mine inserted\n        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray(collectChange(mine)));\n      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n        var _hunk$lines2;\n\n        // Theirs inserted\n        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray(collectChange(their)));\n      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n        // Mine removed or edited\n        removal(hunk, mine, their);\n      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n        // Their removed or edited\n        removal(hunk, their, mine, true);\n      } else if (mineCurrent === theirCurrent) {\n        // Context identity\n        hunk.lines.push(mineCurrent);\n        mine.index++;\n        their.index++;\n      } else {\n        // Context mismatch\n        conflict(hunk, collectChange(mine), collectChange(their));\n      }\n    } // Now push anything that may be remaining\n\n\n    insertTrailing(hunk, mine);\n    insertTrailing(hunk, their);\n    calcLineCount(hunk);\n  }\n\n  function mutualChange(hunk, mine, their) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectChange(their);\n\n    if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n      // Special case for remove changes that are supersets of one another\n      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n        var _hunk$lines3;\n\n        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray(myChanges));\n\n        return;\n      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n        var _hunk$lines4;\n\n        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray(theirChanges));\n\n        return;\n      }\n    } else if (arrayEqual(myChanges, theirChanges)) {\n      var _hunk$lines5;\n\n      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray(myChanges));\n\n      return;\n    }\n\n    conflict(hunk, myChanges, theirChanges);\n  }\n\n  function removal(hunk, mine, their, swap) {\n    var myChanges = collectChange(mine),\n        theirChanges = collectContext(their, myChanges);\n\n    if (theirChanges.merged) {\n      var _hunk$lines6;\n\n      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray(theirChanges.merged));\n    } else {\n      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n    }\n  }\n\n  function conflict(hunk, mine, their) {\n    hunk.conflict = true;\n    hunk.lines.push({\n      conflict: true,\n      mine: mine,\n      theirs: their\n    });\n  }\n\n  function insertLeading(hunk, insert, their) {\n    while (insert.offset < their.offset && insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n      insert.offset++;\n    }\n  }\n\n  function insertTrailing(hunk, insert) {\n    while (insert.index < insert.lines.length) {\n      var line = insert.lines[insert.index++];\n      hunk.lines.push(line);\n    }\n  }\n\n  function collectChange(state) {\n    var ret = [],\n        operation = state.lines[state.index][0];\n\n    while (state.index < state.lines.length) {\n      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\n      if (operation === '-' && line[0] === '+') {\n        operation = '+';\n      }\n\n      if (operation === line[0]) {\n        ret.push(line);\n        state.index++;\n      } else {\n        break;\n      }\n    }\n\n    return ret;\n  }\n\n  function collectContext(state, matchChanges) {\n    var changes = [],\n        merged = [],\n        matchIndex = 0,\n        contextChanges = false,\n        conflicted = false;\n\n    while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n      var change = state.lines[state.index],\n          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done\n\n      if (match[0] === '+') {\n        break;\n      }\n\n      contextChanges = contextChanges || change[0] !== ' ';\n      merged.push(match);\n      matchIndex++; // Consume any additions in the other block as a conflict to attempt\n      // to pull in the remaining context after this\n\n      if (change[0] === '+') {\n        conflicted = true;\n\n        while (change[0] === '+') {\n          changes.push(change);\n          change = state.lines[++state.index];\n        }\n      }\n\n      if (match.substr(1) === change.substr(1)) {\n        changes.push(change);\n        state.index++;\n      } else {\n        conflicted = true;\n      }\n    }\n\n    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n      conflicted = true;\n    }\n\n    if (conflicted) {\n      return changes;\n    }\n\n    while (matchIndex < matchChanges.length) {\n      merged.push(matchChanges[matchIndex++]);\n    }\n\n    return {\n      merged: merged,\n      changes: changes\n    };\n  }\n\n  function allRemoves(changes) {\n    return changes.reduce(function (prev, change) {\n      return prev && change[0] === '-';\n    }, true);\n  }\n\n  function skipRemoveSuperset(state, removeChanges, delta) {\n    for (var i = 0; i < delta; i++) {\n      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\n      if (state.lines[state.index + i] !== ' ' + changeContent) {\n        return false;\n      }\n    }\n\n    state.index += delta;\n    return true;\n  }\n\n  function calcOldNewLineCount(lines) {\n    var oldLines = 0;\n    var newLines = 0;\n    lines.forEach(function (line) {\n      if (typeof line !== 'string') {\n        var myCount = calcOldNewLineCount(line.mine);\n        var theirCount = calcOldNewLineCount(line.theirs);\n\n        if (oldLines !== undefined) {\n          if (myCount.oldLines === theirCount.oldLines) {\n            oldLines += myCount.oldLines;\n          } else {\n            oldLines = undefined;\n          }\n        }\n\n        if (newLines !== undefined) {\n          if (myCount.newLines === theirCount.newLines) {\n            newLines += myCount.newLines;\n          } else {\n            newLines = undefined;\n          }\n        }\n      } else {\n        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n          newLines++;\n        }\n\n        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n          oldLines++;\n        }\n      }\n    });\n    return {\n      oldLines: oldLines,\n      newLines: newLines\n    };\n  }\n\n  // See: http://code.google.com/p/google-diff-match-patch/wiki/API\n  function convertChangesToDMP(changes) {\n    var ret = [],\n        change,\n        operation;\n\n    for (var i = 0; i < changes.length; i++) {\n      change = changes[i];\n\n      if (change.added) {\n        operation = 1;\n      } else if (change.removed) {\n        operation = -1;\n      } else {\n        operation = 0;\n      }\n\n      ret.push([operation, change.value]);\n    }\n\n    return ret;\n  }\n\n  function convertChangesToXML(changes) {\n    var ret = [];\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n\n      if (change.added) {\n        ret.push('<ins>');\n      } else if (change.removed) {\n        ret.push('<del>');\n      }\n\n      ret.push(escapeHTML(change.value));\n\n      if (change.added) {\n        ret.push('</ins>');\n      } else if (change.removed) {\n        ret.push('</del>');\n      }\n    }\n\n    return ret.join('');\n  }\n\n  function escapeHTML(s) {\n    var n = s;\n    n = n.replace(/&/g, '&amp;');\n    n = n.replace(/</g, '&lt;');\n    n = n.replace(/>/g, '&gt;');\n    n = n.replace(/\"/g, '&quot;');\n    return n;\n  }\n\n  exports.Diff = Diff;\n  exports.applyPatch = applyPatch;\n  exports.applyPatches = applyPatches;\n  exports.canonicalize = canonicalize;\n  exports.convertChangesToDMP = convertChangesToDMP;\n  exports.convertChangesToXML = convertChangesToXML;\n  exports.createPatch = createPatch;\n  exports.createTwoFilesPatch = createTwoFilesPatch;\n  exports.diffArrays = diffArrays;\n  exports.diffChars = diffChars;\n  exports.diffCss = diffCss;\n  exports.diffJson = diffJson;\n  exports.diffLines = diffLines;\n  exports.diffSentences = diffSentences;\n  exports.diffTrimmedLines = diffTrimmedLines;\n  exports.diffWords = diffWords;\n  exports.diffWordsWithSpace = diffWordsWithSpace;\n  exports.merge = merge;\n  exports.parsePatch = parsePatch;\n  exports.structuredPatch = structuredPatch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}