{"ast":null,"code":"// https://github.com/Ethan-Arrowood/undici-fetch\n'use strict';\n\nconst {\n  validateHeaderName,\n  validateHeaderValue\n} = require('http');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst {\n  kGuard\n} = require('./symbols');\n\nconst {\n  kEnumerableProperty\n} = require('../core/util');\n\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = require('./constants');\n\nfunction binarySearch(arr, val) {\n  let low = 0;\n  let high = Math.floor(arr.length / 2);\n\n  while (high > low) {\n    const mid = high + low >>> 1;\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n\n  return low * 2;\n}\n\nfunction normalizeAndValidateHeaderName(name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`);\n  }\n\n  const normalizedHeaderName = name.toLocaleLowerCase();\n  validateHeaderName(normalizedHeaderName);\n  return normalizedHeaderName;\n}\n\nfunction normalizeAndValidateHeaderValue(name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name);\n  }\n\n  const normalizedHeaderValue = `${value}`.replace(/^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g, '');\n  validateHeaderValue(name, normalizedHeaderValue);\n  return normalizedHeaderValue;\n}\n\nfunction fill(headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError();\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError();\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header];\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError();\n      } // 2. Append header’s first item/header’s second item to headers.\n\n\n      headers.append(header[0], header[1]);\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1]);\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError();\n  }\n} // TODO: Composition over inheritence? Or helper methods?\n\n\nclass HeadersList extends Array {\n  append(name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`;\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue);\n    }\n  }\n\n  delete(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2);\n    }\n  }\n\n  get(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      return this[index + 1];\n    }\n\n    return null;\n  }\n\n  has(name) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const index = binarySearch(this, normalizedName);\n    return this[index] === normalizedName;\n  }\n\n  set(name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name);\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value);\n    const index = binarySearch(this, normalizedName);\n\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue;\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue);\n    }\n  }\n\n}\n\nclass Headers {\n  constructor() {\n    if ((arguments.length <= 0 ? undefined : arguments[0]) !== undefined && !(typeof (arguments.length <= 0 ? undefined : arguments[0]) === 'object' && (arguments.length <= 0 ? undefined : arguments[0]) != null) && !Array.isArray(arguments.length <= 0 ? undefined : arguments[0])) {\n      throw new TypeError(\"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\");\n    }\n\n    const init = arguments.length >= 1 ? (arguments.length <= 0 ? undefined : arguments[0]) ?? {} : {};\n    this[kHeadersList] = new HeadersList(); // The new Headers(init) constructor steps are:\n    // 1. Set this’s guard to \"none\".\n\n    this[kGuard] = 'none'; // 2. If init is given, then fill this with init.\n\n    fill(this, init);\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  }\n\n  toString() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return Object.prototype.toString.call(this);\n  }\n\n  append() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].append(String(arguments.length <= 0 ? undefined : arguments[0]), String(arguments.length <= 1 ? undefined : arguments[1]));\n  }\n\n  delete() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].delete(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  get() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    return this[kHeadersList].get(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  has() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    return this[kHeadersList].has(String(arguments.length <= 0 ? undefined : arguments[0]));\n  }\n\n  set() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 2) {\n      throw new TypeError(`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`);\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(arguments.length <= 0 ? undefined : arguments[0]));\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable');\n    } else if (this[kGuard] === 'request' && forbiddenHeaderNames.includes(normalizedName)) {\n      return;\n    } else if (this[kGuard] === 'request-no-cors') {// TODO\n    } else if (this[kGuard] === 'response' && forbiddenResponseHeaderNames.includes(normalizedName)) {\n      return;\n    }\n\n    return this[kHeadersList].set(String(arguments.length <= 0 ? undefined : arguments[0]), String(arguments.length <= 1 ? undefined : arguments[1]));\n  }\n\n  *keys() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index];\n    }\n  }\n\n  *values() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index];\n    }\n  }\n\n  *entries() {\n    const clone = this[kHeadersList].slice();\n\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]];\n    }\n  }\n\n  forEach() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    if (typeof (arguments.length <= 0 ? undefined : arguments[0]) !== 'function') {\n      throw new TypeError(\"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\");\n    }\n\n    const callback = arguments.length <= 0 ? undefined : arguments[0];\n    const thisArg = arguments.length <= 1 ? undefined : arguments[1];\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(thisArg, this[kHeadersList][index + 1], this[kHeadersList][index], this);\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this[kHeadersList];\n  }\n\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries;\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n});\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n};","map":{"version":3,"names":["validateHeaderName","validateHeaderValue","require","kHeadersList","kGuard","kEnumerableProperty","forbiddenHeaderNames","forbiddenResponseHeaderNames","binarySearch","arr","val","low","high","Math","floor","length","mid","localeCompare","normalizeAndValidateHeaderName","name","undefined","TypeError","normalizedHeaderName","toLocaleLowerCase","normalizeAndValidateHeaderValue","value","normalizedHeaderValue","replace","fill","headers","object","Symbol","iterator","header","Array","isArray","append","Object","entries","HeadersList","normalizedName","normalizedValue","index","splice","delete","get","has","set","Headers","constructor","init","toStringTag","toString","prototype","call","String","includes","keys","clone","slice","values","forEach","callback","thisArg","for","defineProperties","module","exports"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/fetch/headers.js"],"sourcesContent":["// https://github.com/Ethan-Arrowood/undici-fetch\n\n'use strict'\n\nconst { validateHeaderName, validateHeaderValue } = require('http')\nconst { kHeadersList } = require('../core/symbols')\nconst { kGuard } = require('./symbols')\nconst { kEnumerableProperty } = require('../core/util')\nconst {\n  forbiddenHeaderNames,\n  forbiddenResponseHeaderNames\n} = require('./constants')\n\nfunction binarySearch (arr, val) {\n  let low = 0\n  let high = Math.floor(arr.length / 2)\n\n  while (high > low) {\n    const mid = (high + low) >>> 1\n\n    if (val.localeCompare(arr[mid * 2]) > 0) {\n      low = mid + 1\n    } else {\n      high = mid\n    }\n  }\n\n  return low * 2\n}\n\nfunction normalizeAndValidateHeaderName (name) {\n  if (name === undefined) {\n    throw new TypeError(`Header name ${name}`)\n  }\n  const normalizedHeaderName = name.toLocaleLowerCase()\n  validateHeaderName(normalizedHeaderName)\n  return normalizedHeaderName\n}\n\nfunction normalizeAndValidateHeaderValue (name, value) {\n  if (value === undefined) {\n    throw new TypeError(value, name)\n  }\n  const normalizedHeaderValue = `${value}`.replace(\n    /^[\\n\\t\\r\\x20]+|[\\n\\t\\r\\x20]+$/g,\n    ''\n  )\n  validateHeaderValue(name, normalizedHeaderValue)\n  return normalizedHeaderValue\n}\n\nfunction fill (headers, object) {\n  // To fill a Headers object headers with a given object object, run these steps:\n\n  if (object[Symbol.iterator]) {\n    // 1. If object is a sequence, then for each header in object:\n    // TODO: How to check if sequence?\n    for (let header of object) {\n      // 1. If header does not contain exactly two items, then throw a TypeError.\n      if (!header[Symbol.iterator]) {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (typeof header === 'string') {\n        // TODO: Spec doesn't define what to do here?\n        throw new TypeError()\n      }\n\n      if (!Array.isArray(header)) {\n        header = [...header]\n      }\n\n      if (header.length !== 2) {\n        throw new TypeError()\n      }\n\n      // 2. Append header’s first item/header’s second item to headers.\n      headers.append(header[0], header[1])\n    }\n  } else if (object && typeof object === 'object') {\n    // Otherwise, object is a record, then for each key → value in object,\n    // append key/value to headers.\n    // TODO: How to check if record?\n    for (const header of Object.entries(object)) {\n      headers.append(header[0], header[1])\n    }\n  } else {\n    // TODO: Spec doesn't define what to do here?\n    throw TypeError()\n  }\n}\n\n// TODO: Composition over inheritence? Or helper methods?\nclass HeadersList extends Array {\n  append (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this[index + 1] += `, ${normalizedValue}`\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n\n  delete (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      this.splice(index, 2)\n    }\n  }\n\n  get (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    if (this[index] === normalizedName) {\n      return this[index + 1]\n    }\n\n    return null\n  }\n\n  has (name) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n\n    const index = binarySearch(this, normalizedName)\n\n    return this[index] === normalizedName\n  }\n\n  set (name, value) {\n    const normalizedName = normalizeAndValidateHeaderName(name)\n    const normalizedValue = normalizeAndValidateHeaderValue(name, value)\n\n    const index = binarySearch(this, normalizedName)\n    if (this[index] === normalizedName) {\n      this[index + 1] = normalizedValue\n    } else {\n      this.splice(index, 0, normalizedName, normalizedValue)\n    }\n  }\n}\n\nclass Headers {\n  constructor (...args) {\n    if (\n      args[0] !== undefined &&\n      !(typeof args[0] === 'object' && args[0] != null) &&\n      !Array.isArray(args[0])\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>\"\n      )\n    }\n    const init = args.length >= 1 ? args[0] ?? {} : {}\n\n    this[kHeadersList] = new HeadersList()\n\n    // The new Headers(init) constructor steps are:\n\n    // 1. Set this’s guard to \"none\".\n    this[kGuard] = 'none'\n\n    // 2. If init is given, then fill this with init.\n    fill(this, init)\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  toString () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return Object.prototype.toString.call(this)\n  }\n\n  append (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'append' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].append(String(args[0]), String(args[1]))\n  }\n\n  delete (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'delete' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].delete(String(args[0]))\n  }\n\n  get (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'get' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].get(String(args[0]))\n  }\n\n  has (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'has' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    return this[kHeadersList].has(String(args[0]))\n  }\n\n  set (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 2) {\n      throw new TypeError(\n        `Failed to execute 'set' on 'Headers': 2 arguments required, but only ${args.length} present.`\n      )\n    }\n\n    const normalizedName = normalizeAndValidateHeaderName(String(args[0]))\n\n    if (this[kGuard] === 'immutable') {\n      throw new TypeError('immutable')\n    } else if (\n      this[kGuard] === 'request' &&\n      forbiddenHeaderNames.includes(normalizedName)\n    ) {\n      return\n    } else if (this[kGuard] === 'request-no-cors') {\n      // TODO\n    } else if (\n      this[kGuard] === 'response' &&\n      forbiddenResponseHeaderNames.includes(normalizedName)\n    ) {\n      return\n    }\n\n    return this[kHeadersList].set(String(args[0]), String(args[1]))\n  }\n\n  * keys () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * values () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 1; index < clone.length; index += 2) {\n      yield clone[index]\n    }\n  }\n\n  * entries () {\n    const clone = this[kHeadersList].slice()\n    for (let index = 0; index < clone.length; index += 2) {\n      yield [clone[index], clone[index + 1]]\n    }\n  }\n\n  forEach (...args) {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${args.length} present.`\n      )\n    }\n    if (typeof args[0] !== 'function') {\n      throw new TypeError(\n        \"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.\"\n      )\n    }\n    const callback = args[0]\n    const thisArg = args[1]\n\n    for (let index = 0; index < this[kHeadersList].length; index += 2) {\n      callback.call(\n        thisArg,\n        this[kHeadersList][index + 1],\n        this[kHeadersList][index],\n        this\n      )\n    }\n  }\n\n  [Symbol.for('nodejs.util.inspect.custom')] () {\n    if (!(this instanceof Headers)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this[kHeadersList]\n  }\n}\n\nHeaders.prototype[Symbol.iterator] = Headers.prototype.entries\n\nObject.defineProperties(Headers.prototype, {\n  append: kEnumerableProperty,\n  delete: kEnumerableProperty,\n  get: kEnumerableProperty,\n  has: kEnumerableProperty,\n  set: kEnumerableProperty,\n  keys: kEnumerableProperty,\n  values: kEnumerableProperty,\n  entries: kEnumerableProperty,\n  forEach: kEnumerableProperty\n})\n\nmodule.exports = {\n  fill,\n  Headers,\n  HeadersList,\n  binarySearch,\n  normalizeAndValidateHeaderName,\n  normalizeAndValidateHeaderValue\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}