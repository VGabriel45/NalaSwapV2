{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst assert = require('assert');\n\nconst util = require('./util');\n\nconst {\n  InvalidArgumentError,\n  ConnectTimeoutError\n} = require('./errors');\n\nlet tls; // include tls conditionally since it is not always available\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector(_ref) {\n  let {\n    maxCachedSessions,\n    socketPath,\n    timeout,\n    ...opts\n  } = _ref;\n\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero');\n  }\n\n  const options = {\n    path: socketPath,\n    ...opts\n  };\n  const sessionCache = new Map();\n  timeout = timeout == null ? 10e3 : timeout;\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;\n  return function connect(_ref2, callback) {\n    let {\n      hostname,\n      host,\n      protocol,\n      port,\n      servername\n    } = _ref2;\n    let socket;\n\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls');\n      }\n\n      servername = servername || options.servername || util.getServerName(host) || null;\n      const sessionKey = servername || hostname;\n      const session = sessionCache.get(sessionKey) || null;\n      assert(sessionKey);\n      socket = tls.connect({\n        highWaterMark: 16384,\n        // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      });\n      socket.on('session', function (session) {\n        // cache is disabled\n        if (maxCachedSessions === 0) {\n          return;\n        }\n\n        if (sessionCache.size >= maxCachedSessions) {\n          // remove the oldest session\n          const {\n            value: oldestKey\n          } = sessionCache.keys().next();\n          sessionCache.delete(oldestKey);\n        }\n\n        sessionCache.set(sessionKey, session);\n      }).on('error', function (err) {\n        if (sessionKey && err.code !== 'UND_ERR_INFO') {\n          // TODO (fix): Only delete for session related errors.\n          sessionCache.delete(sessionKey);\n        }\n      });\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024,\n        // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      });\n    }\n\n    const timeoutId = timeout ? setTimeout(onConnectTimeout, timeout, socket) : null;\n    socket.setNoDelay(true).once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n      clearTimeout(timeoutId);\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(null, this);\n      }\n    }).on('error', function (err) {\n      clearTimeout(timeoutId);\n\n      if (callback) {\n        const cb = callback;\n        callback = null;\n        cb(err);\n      }\n    });\n    return socket;\n  };\n}\n\nfunction onConnectTimeout(socket) {\n  util.destroy(socket, new ConnectTimeoutError());\n}\n\nmodule.exports = buildConnector;","map":{"version":3,"names":["net","require","assert","util","InvalidArgumentError","ConnectTimeoutError","tls","buildConnector","maxCachedSessions","socketPath","timeout","opts","Number","isInteger","options","path","sessionCache","Map","connect","callback","hostname","host","protocol","port","servername","socket","getServerName","sessionKey","session","get","highWaterMark","on","size","value","oldestKey","keys","next","delete","set","err","code","timeoutId","setTimeout","onConnectTimeout","setNoDelay","once","clearTimeout","cb","destroy","module","exports"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/core/connect.js"],"sourcesContent":["'use strict'\n\nconst net = require('net')\nconst assert = require('assert')\nconst util = require('./util')\nconst { InvalidArgumentError, ConnectTimeoutError } = require('./errors')\nlet tls // include tls conditionally since it is not always available\n\n// TODO: session re-use does not wait for the first\n// connection to resolve the session and might therefore\n// resolve the same servername multiple times even when\n// re-use is enabled.\n\nfunction buildConnector ({ maxCachedSessions, socketPath, timeout, ...opts }) {\n  if (maxCachedSessions != null && (!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)) {\n    throw new InvalidArgumentError('maxCachedSessions must be a positive integer or zero')\n  }\n\n  const options = { path: socketPath, ...opts }\n  const sessionCache = new Map()\n  timeout = timeout == null ? 10e3 : timeout\n  maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions\n\n  return function connect ({ hostname, host, protocol, port, servername }, callback) {\n    let socket\n    if (protocol === 'https:') {\n      if (!tls) {\n        tls = require('tls')\n      }\n      servername = servername || options.servername || util.getServerName(host) || null\n\n      const sessionKey = servername || hostname\n      const session = sessionCache.get(sessionKey) || null\n\n      assert(sessionKey)\n\n      socket = tls.connect({\n        highWaterMark: 16384, // TLS in node can't have bigger HWM anyway...\n        ...options,\n        servername,\n        session,\n        port: port || 443,\n        host: hostname\n      })\n\n      socket\n        .on('session', function (session) {\n          // cache is disabled\n          if (maxCachedSessions === 0) {\n            return\n          }\n\n          if (sessionCache.size >= maxCachedSessions) {\n            // remove the oldest session\n            const { value: oldestKey } = sessionCache.keys().next()\n            sessionCache.delete(oldestKey)\n          }\n\n          sessionCache.set(sessionKey, session)\n        })\n        .on('error', function (err) {\n          if (sessionKey && err.code !== 'UND_ERR_INFO') {\n            // TODO (fix): Only delete for session related errors.\n            sessionCache.delete(sessionKey)\n          }\n        })\n    } else {\n      socket = net.connect({\n        highWaterMark: 64 * 1024, // Same as nodejs fs streams.\n        ...options,\n        port: port || 80,\n        host: hostname\n      })\n    }\n\n    const timeoutId = timeout\n      ? setTimeout(onConnectTimeout, timeout, socket)\n      : null\n\n    socket\n      .setNoDelay(true)\n      .once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(null, this)\n        }\n      })\n      .on('error', function (err) {\n        clearTimeout(timeoutId)\n\n        if (callback) {\n          const cb = callback\n          callback = null\n          cb(err)\n        }\n      })\n\n    return socket\n  }\n}\n\nfunction onConnectTimeout (socket) {\n  util.destroy(socket, new ConnectTimeoutError())\n}\n\nmodule.exports = buildConnector\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}