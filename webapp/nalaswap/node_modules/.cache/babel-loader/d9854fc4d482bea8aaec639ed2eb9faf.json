{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.instructionToCallstackStackTraceEntry = exports.ErrorInferrer = void 0;\n\nconst exceptions_1 = require(\"@ethereumjs/vm/dist/exceptions\");\n\nconst abi_1 = require(\"@ethersproject/abi\");\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst abi_helpers_1 = require(\"../../util/abi-helpers\");\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION = \"0.5.9\";\nconst FIRST_SOLC_VERSION_RECEIVE_FUNCTION = \"0.6.0\";\nconst FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS = \"0.6.3\";\nconst EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT = 0x6000;\n/* eslint-disable @nomiclabs/hardhat-internal-rules/only-hardhat-error */\n\nclass ErrorInferrer {\n  inferBeforeTracingCallMessage(trace) {\n    if (this._isDirectLibraryCall(trace)) {\n      return this._getDirectLibraryCallErrorStackTrace(trace);\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (this._isFunctionNotPayableError(trace, calledFunction)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        value: trace.value\n      }];\n    }\n\n    if (this._isMissingFunctionAndFallbackError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.MISSING_FALLBACK_OR_RECEIVE_ERROR,\n          sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR,\n        sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n      }];\n    }\n\n    if (this._isFallbackNotPayableError(trace, calledFunction)) {\n      if (this._emptyCalldataAndNoReceive(trace)) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR,\n          sourceReference: this._getFallbackStartSourceReference(trace),\n          value: trace.value\n        }];\n      }\n\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FALLBACK_NOT_PAYABLE_ERROR,\n        sourceReference: this._getFallbackStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n  }\n\n  inferBeforeTracingCreateMessage(trace) {\n    if (this._isConstructorNotPayableError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.FUNCTION_NOT_PAYABLE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        value: trace.value\n      }];\n    }\n\n    if (this._isConstructorInvalidArgumentsError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData) {\n    var _a, _b, _c, _d, _e, _f;\n\n    return (_f = (_e = (_d = (_c = (_b = (_a = this._checkLastSubmessage(trace, stacktrace, lastSubmessageData)) !== null && _a !== void 0 ? _a : this._checkFailedLastCall(trace, stacktrace)) !== null && _b !== void 0 ? _b : this._checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction)) !== null && _c !== void 0 ? _c : this._checkNonContractCalled(trace, stacktrace)) !== null && _d !== void 0 ? _d : this._checkSolidity063UnmappedRevert(trace, stacktrace)) !== null && _e !== void 0 ? _e : this._checkContractTooLarge(trace)) !== null && _f !== void 0 ? _f : this._otherExecutionErrorStacktrace(trace, stacktrace);\n  }\n\n  filterRedundantFrames(stacktrace) {\n    return stacktrace.filter((frame, i) => {\n      if (i + 1 === stacktrace.length) {\n        return true;\n      }\n\n      const nextFrame = stacktrace[i + 1]; // we can only filter frames if we know their sourceReference\n      // and the one from the next frame\n\n      if (frame.sourceReference === undefined || nextFrame.sourceReference === undefined) {\n        return true;\n      } // look TWO frames ahead to determine if this is a specific occurrence of\n      // a redundant CALLSTACK_ENTRY frame observed when using Solidity 0.8.5:\n\n\n      if (frame.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && i + 2 < stacktrace.length && stacktrace[i + 2].sourceReference !== undefined && stacktrace[i + 2].type === solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR) {\n        // ! below for tsc. we confirmed existence in the enclosing conditional.\n        const thatSrcRef = stacktrace[i + 2].sourceReference;\n\n        if (frame.sourceReference.range[0] === thatSrcRef.range[0] && frame.sourceReference.range[1] === thatSrcRef.range[1] && frame.sourceReference.line === thatSrcRef.line) {\n          return false;\n        }\n      } // constructors contain the whole contract, so we ignore them\n\n\n      if (frame.sourceReference.function === \"constructor\" && nextFrame.sourceReference.function !== \"constructor\") {\n        return true;\n      } // this is probably a recursive call\n\n\n      if (i > 0 && frame.type === nextFrame.type && frame.sourceReference.range[0] === nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] === nextFrame.sourceReference.range[1] && frame.sourceReference.line === nextFrame.sourceReference.line) {\n        return true;\n      }\n\n      if (frame.sourceReference.range[0] <= nextFrame.sourceReference.range[0] && frame.sourceReference.range[1] >= nextFrame.sourceReference.range[1]) {\n        return false;\n      }\n\n      return true;\n    });\n  } // Heuristics\n\n  /**\n   * Check if the last submessage can be used to generate the stack trace.\n   */\n\n\n  _checkLastSubmessage(trace, stacktrace, lastSubmessageData) {\n    if (lastSubmessageData === undefined) {\n      return undefined;\n    }\n\n    const inferredStacktrace = [...stacktrace]; // get the instruction before the submessage and add it to the stack trace\n\n    const callStep = trace.steps[lastSubmessageData.stepIndex - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      throw new Error(\"This should not happen: MessageTrace should be preceded by a EVM step\");\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n    const callStackFrame = instructionToCallstackStackTraceEntry(trace.bytecode, callInst);\n    const lastMessageFailed = lastSubmessageData.messageTrace.error !== undefined;\n\n    if (lastMessageFailed) {\n      // add the call/create that generated the message to the stack trace\n      inferredStacktrace.push(callStackFrame);\n\n      if (this._isSubtraceErrorPropagated(trace, lastSubmessageData.stepIndex) || this._isProxyErrorPropagated(trace, lastSubmessageData.stepIndex)) {\n        inferredStacktrace.push(...lastSubmessageData.stacktrace);\n\n        if (this._isContractCallRunOutOfGasError(trace, lastSubmessageData.stepIndex)) {\n          const lastFrame = inferredStacktrace.pop();\n          inferredStacktrace.push({\n            type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR,\n            sourceReference: lastFrame.sourceReference\n          });\n        }\n\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    } else {\n      const isReturnDataSizeError = this._failsRightAfterCall(trace, lastSubmessageData.stepIndex);\n\n      if (isReturnDataSizeError) {\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.RETURNDATA_SIZE_ERROR,\n          sourceReference: callStackFrame.sourceReference\n        });\n        return this._fixInitialModifier(trace, inferredStacktrace);\n      }\n    }\n  }\n  /**\n   * Check if the last call/create that was done failed.\n   */\n\n\n  _checkFailedLastCall(trace, stacktrace) {\n    for (let stepIndex = trace.steps.length - 2; stepIndex >= 0; stepIndex--) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n      const isCallOrCreate = (0, opcodes_1.isCall)(inst.opcode) || (0, opcodes_1.isCreate)(inst.opcode);\n\n      if (isCallOrCreate && (0, message_trace_1.isEvmStep)(nextStep)) {\n        if (this._isCallFailedError(trace, stepIndex, inst)) {\n          const inferredStacktrace = [...stacktrace, this._callInstructionToCallFailedToExecuteStackTraceEntry(trace.bytecode, inst)];\n          return this._fixInitialModifier(trace, inferredStacktrace);\n        }\n      }\n    }\n  }\n  /**\n   * Check if the execution stopped with a revert or an invalid opcode.\n   */\n\n\n  _checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction) {\n    var _a;\n\n    if (lastInstruction.opcode !== opcodes_1.Opcode.REVERT && lastInstruction.opcode !== opcodes_1.Opcode.INVALID) {\n      return;\n    }\n\n    const inferredStacktrace = [...stacktrace];\n\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      // There should always be a function here, but that's not the case with optimizations.\n      //\n      // If this is a create trace, we already checked args and nonpayable failures before\n      // calling this function.\n      //\n      // If it's a call trace, we already jumped into a function. But optimizations can happen.\n      const failingFunction = lastInstruction.location.getContainingFunction(); // If the failure is in a modifier we add an entry with the function/constructor\n\n      if (failingFunction !== undefined && failingFunction.type === model_1.ContractFunctionType.MODIFIER) {\n        inferredStacktrace.push(this._getEntryBeforeFailureInModifier(trace, functionJumpdests));\n      }\n    }\n\n    const panicStacktrace = this._checkPanic(trace, inferredStacktrace, lastInstruction);\n\n    if (panicStacktrace !== undefined) {\n      return panicStacktrace;\n    }\n\n    const customErrorStacktrace = this._checkCustomErrors(trace, inferredStacktrace, lastInstruction);\n\n    if (customErrorStacktrace !== undefined) {\n      return customErrorStacktrace;\n    }\n\n    if (lastInstruction.location !== undefined && (!(0, message_trace_1.isDecodedCallTrace)(trace) || jumpedIntoFunction)) {\n      const failingFunction = lastInstruction.location.getContainingFunction();\n\n      if (failingFunction !== undefined) {\n        inferredStacktrace.push(this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction));\n      } else if ((0, message_trace_1.isDecodedCallTrace)(trace)) {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4))),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      } else {\n        // This is here because of the optimizations\n        inferredStacktrace.push({\n          type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n          sourceReference: this._getConstructorStartSourceReference(trace),\n          message: new return_data_1.ReturnData(trace.returnData),\n          isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n        });\n      }\n\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    } // If the revert instruction is not mapped but there is return data,\n    // we add the frame anyway, sith the best sourceReference we can get\n\n\n    if (lastInstruction.location === undefined && trace.returnData.length > 0) {\n      const revertFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n        sourceReference: (_a = this._getLastSourceReference(trace)) !== null && _a !== void 0 ? _a : this._getContractStartWithoutFunctionSourceReference(trace),\n        message: new return_data_1.ReturnData(trace.returnData),\n        isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n      };\n      inferredStacktrace.push(revertFrame);\n      return this._fixInitialModifier(trace, inferredStacktrace);\n    }\n  }\n  /**\n   * Check if the trace reverted with a panic error.\n   */\n\n\n  _checkPanic(trace, stacktrace, lastInstruction) {\n    if (!this._isPanicReturnData(trace.returnData)) {\n      return;\n    } // If the last frame is an internal function, it means that the trace\n    // jumped there to return the panic. If that's the case, we remove that\n    // frame.\n\n\n    const lastFrame = stacktrace[stacktrace.length - 1];\n\n    if ((lastFrame === null || lastFrame === void 0 ? void 0 : lastFrame.type) === solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY) {\n      stacktrace.splice(-1);\n    }\n\n    const panicReturnData = new return_data_1.ReturnData(trace.returnData);\n    const errorCode = panicReturnData.decodePanic(); // if the error comes from a call to a zero-initialized function,\n    // we remove the last frame, which represents the call, to avoid\n    // having duplicated frames\n\n    if (errorCode.eqn(0x51)) {\n      stacktrace.splice(-1);\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToPanicStackTraceEntry(trace, lastInstruction, errorCode));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n\n  _checkCustomErrors(trace, stacktrace, lastInstruction) {\n    const returnData = new return_data_1.ReturnData(trace.returnData);\n\n    if (returnData.isEmpty() || returnData.isErrorReturnData()) {\n      // if there is no return data, or if it's a Error(string),\n      // then it can't be a custom error\n      return;\n    }\n\n    let errorMessage = \"reverted with an unrecognized custom error\";\n\n    for (const customError of trace.bytecode.contract.customErrors) {\n      if (returnData.matchesSelector(customError.selector)) {\n        // if the return data matches a custom error in the called contract,\n        // we format the message using the returnData and the custom error instance\n        const decodedValues = abi_1.defaultAbiCoder.decode(customError.paramTypes, returnData.value.slice(4));\n        const params = abi_helpers_1.AbiHelpers.formatValues([...decodedValues]);\n        errorMessage = `reverted with custom error '${customError.name}(${params})'`;\n        break;\n      }\n    }\n\n    const inferredStacktrace = [...stacktrace];\n    inferredStacktrace.push(this._instructionWithinFunctionToCustomErrorStackTraceEntry(trace, lastInstruction, errorMessage));\n    return this._fixInitialModifier(trace, inferredStacktrace);\n  }\n  /**\n   * Check last instruction to try to infer the error.\n   */\n\n\n  _checkLastInstruction(trace, stacktrace, functionJumpdests, jumpedIntoFunction) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      throw new Error(\"This should not happen: MessageTrace ends with a subtrace\");\n    }\n\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n\n    const revertOrInvalidStacktrace = this._checkRevertOrInvalidOpcode(trace, stacktrace, lastInstruction, functionJumpdests, jumpedIntoFunction);\n\n    if (revertOrInvalidStacktrace !== undefined) {\n      return revertOrInvalidStacktrace;\n    }\n\n    if ((0, message_trace_1.isDecodedCallTrace)(trace) && !jumpedIntoFunction) {\n      if (this._hasFailedInsideTheFallbackFunction(trace) || this._hasFailedInsideTheReceiveFunction(trace)) {\n        return [this._instructionWithinFunctionToRevertStackTraceEntry(trace, lastInstruction)];\n      } // Sometimes we do fail inside of a function but there's no jump into\n\n\n      if (lastInstruction.location !== undefined) {\n        const failingFunction = lastInstruction.location.getContainingFunction();\n\n        if (failingFunction !== undefined) {\n          return [{\n            type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n            sourceReference: this._getFunctionStartSourceReference(trace, failingFunction),\n            message: new return_data_1.ReturnData(trace.returnData),\n            isInvalidOpcodeError: lastInstruction.opcode === opcodes_1.Opcode.INVALID\n          }];\n        }\n      }\n\n      const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n      if (calledFunction !== undefined) {\n        return [{\n          type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n          sourceReference: this._getFunctionStartSourceReference(trace, calledFunction)\n        }];\n      }\n\n      if (this._solidity063MaybeUnmappedRevert(trace)) {\n        const revertFrame = this._solidity063GetFrameForUnmappedRevertBeforeFunction(trace);\n\n        if (revertFrame !== undefined) {\n          return [revertFrame];\n        }\n      }\n\n      return [this._getOtherErrorBeforeCalledFunctionStackTraceEntry(trace)];\n    }\n  }\n\n  _checkNonContractCalled(trace, stacktrace) {\n    if (this._isCalledNonContractAccountError(trace)) {\n      const nonContractCalledFrame = {\n        type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n        // We are sure this is not undefined because there was at least a call instruction\n        sourceReference: this._getLastSourceReference(trace)\n      };\n      return [...stacktrace, nonContractCalledFrame];\n    }\n  }\n\n  _checkSolidity063UnmappedRevert(trace, stacktrace) {\n    if (this._solidity063MaybeUnmappedRevert(trace)) {\n      const revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n      if (revertFrame !== undefined) {\n        return [...stacktrace, revertFrame];\n      }\n    }\n  }\n\n  _checkContractTooLarge(trace) {\n    if ((0, message_trace_1.isCreateTrace)(trace) && this._isContractTooLargeError(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.CONTRACT_TOO_LARGE_ERROR,\n        sourceReference: this._getConstructorStartSourceReference(trace)\n      }];\n    }\n  }\n\n  _otherExecutionErrorStacktrace(trace, stacktrace) {\n    const otherExecutionErrorFrame = {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getLastSourceReference(trace)\n    };\n    return [...stacktrace, otherExecutionErrorFrame];\n  } // Helpers\n\n\n  _fixInitialModifier(trace, stacktrace) {\n    const firstEntry = stacktrace[0];\n\n    if (firstEntry !== undefined && firstEntry.type === solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY && firstEntry.functionType === model_1.ContractFunctionType.MODIFIER) {\n      return [this._getEntryBeforeInitialModifierCallstackEntry(trace), ...stacktrace];\n    }\n\n    return stacktrace;\n  }\n\n  _isDirectLibraryCall(trace) {\n    return trace.depth === 0 && trace.bytecode.contract.type === model_1.ContractType.LIBRARY;\n  }\n\n  _getDirectLibraryCallErrorStackTrace(trace) {\n    const func = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (func !== undefined) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n        sourceReference: this._getFunctionStartSourceReference(trace, func)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.DIRECT_LIBRARY_CALL_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    }];\n  }\n\n  _isFunctionNotPayableError(trace, calledFunction) {\n    if (calledFunction === undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    } // Libraries don't have a nonpayable check\n\n\n    if (trace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    return calledFunction.isPayable === undefined || !calledFunction.isPayable;\n  }\n\n  _getFunctionStartSourceReference(trace, func) {\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: func.name,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isMissingFunctionAndFallbackError(trace, calledFunction) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    } // the called function exists in the contract\n\n\n    if (calledFunction !== undefined) {\n      return false;\n    } // there's a receive function and no calldata\n\n\n    if (trace.calldata.length === 0 && trace.bytecode.contract.receive !== undefined) {\n      return false;\n    }\n\n    return trace.bytecode.contract.fallback === undefined;\n  }\n\n  _emptyCalldataAndNoReceive(trace) {\n    // this only makes sense when receive functions are available\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_RECEIVE_FUNCTION)) {\n      return false;\n    }\n\n    return trace.calldata.length === 0 && trace.bytecode.contract.receive === undefined;\n  }\n\n  _getContractStartWithoutFunctionSourceReference(trace) {\n    const location = trace.bytecode.contract.location;\n    return {\n      sourceName: location.file.sourceName,\n      sourceContent: location.file.content,\n      contract: trace.bytecode.contract.name,\n      line: location.getStartingLineNumber(),\n      range: [location.offset, location.offset + location.length]\n    };\n  }\n\n  _isFallbackNotPayableError(trace, calledFunction) {\n    if (calledFunction !== undefined) {\n      return false;\n    } // This error doesn't return data\n\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (trace.value.lten(0)) {\n      return false;\n    }\n\n    if (trace.bytecode.contract.fallback === undefined) {\n      return false;\n    }\n\n    const isPayable = trace.bytecode.contract.fallback.isPayable;\n    return isPayable === undefined || !isPayable;\n  }\n\n  _getFallbackStartSourceReference(trace) {\n    const func = trace.bytecode.contract.fallback;\n\n    if (func === undefined) {\n      throw new Error(\"This shouldn't happen: trying to get fallback source reference from a contract without fallback\");\n    }\n\n    return {\n      sourceName: func.location.file.sourceName,\n      sourceContent: func.location.file.content,\n      contract: trace.bytecode.contract.name,\n      function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n      line: func.location.getStartingLineNumber(),\n      range: [func.location.offset, func.location.offset + func.location.length]\n    };\n  }\n\n  _isConstructorNotPayableError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const constructor = trace.bytecode.contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    return trace.value.gtn(0) && (constructor.isPayable === undefined || !constructor.isPayable);\n  }\n  /**\n   * Returns a source reference pointing to the constructor if it exists, or to the contract\n   * otherwise.\n   */\n\n\n  _getConstructorStartSourceReference(trace) {\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction;\n    const line = constructor !== undefined ? constructor.location.getStartingLineNumber() : contract.location.getStartingLineNumber();\n    return {\n      sourceName: contract.location.file.sourceName,\n      sourceContent: contract.location.file.content,\n      contract: contract.name,\n      function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n      line,\n      range: [contract.location.offset, contract.location.offset + contract.location.length]\n    };\n  }\n\n  _isConstructorInvalidArgumentsError(trace) {\n    // This error doesn't return data\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    const contract = trace.bytecode.contract;\n    const constructor = contract.constructorFunction; // This function is only matters with contracts that have constructors defined. The ones that\n    // don't are abstract contracts, or their constructor doesn't take any argument.\n\n    if (constructor === undefined) {\n      return false;\n    }\n\n    if (semver_1.default.lt(trace.bytecode.compilerVersion, FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION)) {\n      return false;\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT || lastInst.location !== undefined) {\n      return false;\n    }\n\n    let hasReadDeploymentCodeSize = false; // eslint-disable-next-line @typescript-eslint/prefer-for-of\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined && !contract.location.equals(inst.location) && !constructor.location.equals(inst.location)) {\n        return false;\n      }\n\n      if (inst.opcode === opcodes_1.Opcode.CODESIZE && (0, message_trace_1.isCreateTrace)(trace)) {\n        hasReadDeploymentCodeSize = true;\n      }\n    }\n\n    return hasReadDeploymentCodeSize;\n  }\n\n  _getEntryBeforeInitialModifierCallstackEntry(trace) {\n    if ((0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getConstructorStartSourceReference(trace),\n        functionType: model_1.ContractFunctionType.CONSTRUCTOR\n      };\n    }\n\n    const calledFunction = trace.bytecode.contract.getFunctionFromSelector(trace.calldata.slice(0, 4));\n\n    if (calledFunction !== undefined) {\n      return {\n        type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n        sourceReference: this._getFunctionStartSourceReference(trace, calledFunction),\n        functionType: model_1.ContractFunctionType.FUNCTION\n      };\n    } // If it failed or made a call from within a modifier, and the selector doesn't match\n    // any function, it must have a fallback.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getFallbackStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.FALLBACK\n    };\n  }\n\n  _getLastSourceReference(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        continue;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location === undefined) {\n        continue;\n      }\n\n      return sourceLocationToSourceReference(trace.bytecode, inst.location);\n    }\n\n    return undefined;\n  }\n\n  _hasFailedInsideTheFallbackFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.fallback === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.fallback);\n  }\n\n  _hasFailedInsideTheReceiveFunction(trace) {\n    const contract = trace.bytecode.contract;\n\n    if (contract.receive === undefined) {\n      return false;\n    }\n\n    return this._hasFailedInsideFunction(trace, contract.receive);\n  }\n\n  _hasFailedInsideFunction(trace, func) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInstruction = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInstruction.location !== undefined && lastInstruction.opcode === opcodes_1.Opcode.REVERT && func.location.contains(lastInstruction.location);\n  }\n\n  _instructionWithinFunctionToRevertStackTraceEntry(trace, inst) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR,\n      sourceReference: sourceLocationToSourceReference(trace.bytecode, inst.location),\n      message: new return_data_1.ReturnData(trace.returnData),\n      isInvalidOpcodeError: inst.opcode === opcodes_1.Opcode.INVALID\n    };\n  }\n\n  _instructionWithinFunctionToPanicStackTraceEntry(trace, inst, errorCode) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.PANIC_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      errorCode\n    };\n  }\n\n  _instructionWithinFunctionToCustomErrorStackTraceEntry(trace, inst, message) {\n    var _a;\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CUSTOM_ERROR,\n      sourceReference: (_a = sourceLocationToSourceReference(trace.bytecode, inst.location)) !== null && _a !== void 0 ? _a : this._getLastSourceReference(trace),\n      message\n    };\n  }\n\n  _solidity063MaybeUnmappedRevert(trace) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return semver_1.default.satisfies(trace.bytecode.compilerVersion, `^${FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS}`) && lastInst.opcode === opcodes_1.Opcode.REVERT;\n  } // Solidity 0.6.3 unmapped reverts special handling\n  // For more info: https://github.com/ethereum/solidity/issues/9006\n\n\n  _solidity063GetFrameForUnmappedRevertBeforeFunction(trace) {\n    let revertFrame = this._solidity063GetFrameForUnmappedRevertWithinFunction(trace);\n\n    if (revertFrame === undefined || revertFrame.sourceReference === undefined) {\n      if (trace.bytecode.contract.receive === undefined || trace.calldata.length > 0) {\n        if (trace.bytecode.contract.fallback !== undefined) {\n          // Failed within the fallback\n          const location = trace.bytecode.contract.fallback.location;\n          revertFrame = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n            sourceReference: {\n              contract: trace.bytecode.contract.name,\n              function: solidity_stack_trace_1.FALLBACK_FUNCTION_NAME,\n              sourceName: location.file.sourceName,\n              sourceContent: location.file.content,\n              line: location.getStartingLineNumber(),\n              range: [location.offset, location.offset + location.length]\n            }\n          };\n\n          this._solidity063CorrectLineNumber(revertFrame);\n        }\n      } else {\n        // Failed within the receive function\n        const location = trace.bytecode.contract.receive.location;\n        revertFrame = {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR,\n          sourceReference: {\n            contract: trace.bytecode.contract.name,\n            function: solidity_stack_trace_1.RECEIVE_FUNCTION_NAME,\n            sourceName: location.file.sourceName,\n            sourceContent: location.file.content,\n            line: location.getStartingLineNumber(),\n            range: [location.offset, location.offset + location.length]\n          }\n        };\n\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n    }\n\n    return revertFrame;\n  }\n\n  _getOtherErrorBeforeCalledFunctionStackTraceEntry(trace) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.OTHER_EXECUTION_ERROR,\n      sourceReference: this._getContractStartWithoutFunctionSourceReference(trace)\n    };\n  }\n\n  _isCalledNonContractAccountError(trace) {\n    // We could change this to checking that the last valid location maps to a call, but\n    // it's way more complex as we need to get the ast node from that location.\n    const lastIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastIndex === undefined || lastIndex === 0) {\n      return false;\n    }\n\n    const lastStep = trace.steps[lastIndex]; // We know this is an EVM step\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.ISZERO) {\n      return false;\n    }\n\n    const prevStep = trace.steps[lastIndex - 1]; // We know this is an EVM step\n\n    const prevInst = trace.bytecode.getInstruction(prevStep.pc);\n    return prevInst.opcode === opcodes_1.Opcode.EXTCODESIZE;\n  }\n\n  _solidity063GetFrameForUnmappedRevertWithinFunction(trace) {\n    // If we are within a function there's a last valid location. It may\n    // be the entire contract.\n    const prevInst = this._getLastInstructionWithValidLocation(trace);\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const nextInstPc = lastStep.pc + 1;\n    const hasNextInst = trace.bytecode.hasInstruction(nextInstPc);\n\n    if (hasNextInst) {\n      const nextInst = trace.bytecode.getInstruction(nextInstPc);\n      const prevLoc = prevInst.location;\n      const nextLoc = nextInst.location;\n      const prevFunc = prevLoc.getContainingFunction();\n      const nextFunc = nextLoc === null || nextLoc === void 0 ? void 0 : nextLoc.getContainingFunction(); // This is probably a require. This means that we have the exact\n      // line, but the stack trace may be degraded (e.g. missing our\n      // synthetic call frames when failing in a modifier) so we still\n      // add this frame as UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n\n      if (prevFunc !== undefined && nextLoc !== undefined && prevLoc.equals(nextLoc)) {\n        return Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      let revertFrame; // If the previous and next location don't match, we try to use the\n      // previous one if it's inside a function, otherwise we use the next one\n\n      if (prevFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      } else if (nextFunc !== undefined) {\n        revertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, nextInst)), {\n          type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n        });\n      }\n\n      if (revertFrame !== undefined) {\n        this._solidity063CorrectLineNumber(revertFrame);\n      }\n\n      return revertFrame;\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      // Solidity is smart enough to stop emitting extra instructions after\n      // an unconditional revert happens in a constructor. If this is the case\n      // we just return a special error.\n      const constructorRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n        type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n      }); // When the latest instruction is not within a function we need\n      // some default sourceReference to show to the user\n\n      if (constructorRevertFrame.sourceReference === undefined) {\n        const location = trace.bytecode.contract.location;\n        const defaultSourceReference = {\n          function: solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME,\n          contract: trace.bytecode.contract.name,\n          sourceName: location.file.sourceName,\n          sourceContent: location.file.content,\n          line: location.getStartingLineNumber(),\n          range: [location.offset, location.offset + location.length]\n        };\n\n        if (trace.bytecode.contract.constructorFunction !== undefined) {\n          defaultSourceReference.line = trace.bytecode.contract.constructorFunction.location.getStartingLineNumber();\n        }\n\n        constructorRevertFrame.sourceReference = defaultSourceReference;\n      } else {\n        this._solidity063CorrectLineNumber(constructorRevertFrame);\n      }\n\n      return constructorRevertFrame;\n    } // We may as well just be in a function or modifier and just happen\n    // to be at the last instruction of the runtime bytecode.\n    // In this case we just return whatever the last mapped intruction\n    // points to.\n\n\n    const latestInstructionRevertFrame = Object.assign(Object.assign({}, this._instructionWithinFunctionToRevertStackTraceEntry(trace, prevInst)), {\n      type: solidity_stack_trace_1.StackTraceEntryType.UNMAPPED_SOLC_0_6_3_REVERT_ERROR\n    });\n\n    if (latestInstructionRevertFrame.sourceReference !== undefined) {\n      this._solidity063CorrectLineNumber(latestInstructionRevertFrame);\n    }\n\n    return latestInstructionRevertFrame;\n  }\n\n  _isContractTooLargeError(trace) {\n    if (trace.error === undefined || trace.error.error !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    } // This error doesn't come from solidity, but actually from the VM.\n    // The deployment code executes correctly, but it OOGs.\n\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.RETURN) {\n      return false;\n    } // TODO: This is an over approximation, as we should be comparing the\n    //  runtime bytecode.\n\n\n    if (trace.bytecode.normalizedCode.length <= EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT) {\n      return false;\n    } // TODO: What happens if it's an actual out of gas that OOGs at the return?\n    //   maybe traces should have gasLimit and gasUsed.\n\n\n    return true;\n  }\n\n  _solidity063CorrectLineNumber(revertFrame) {\n    const lines = revertFrame.sourceReference.sourceContent.split(\"\\n\");\n    const currentLine = lines[revertFrame.sourceReference.line - 1];\n\n    if (currentLine.includes(\"require\") || currentLine.includes(\"revert\")) {\n      return;\n    }\n\n    const nextLines = lines.slice(revertFrame.sourceReference.line);\n    const firstNonEmptyLine = nextLines.findIndex(l => l.trim() !== \"\");\n\n    if (firstNonEmptyLine === -1) {\n      return;\n    }\n\n    const nextLine = nextLines[firstNonEmptyLine];\n\n    if (nextLine.includes(\"require\") || nextLine.includes(\"revert\")) {\n      revertFrame.sourceReference.line += 1 + firstNonEmptyLine;\n    }\n  }\n\n  _getLastInstructionWithValidLocationStepIndex(trace) {\n    for (let i = trace.steps.length - 1; i >= 0; i--) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return undefined;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc);\n\n      if (inst.location !== undefined) {\n        return i;\n      }\n    }\n\n    return undefined;\n  }\n\n  _getLastInstructionWithValidLocation(trace) {\n    const lastLocationIndex = this._getLastInstructionWithValidLocationStepIndex(trace);\n\n    if (lastLocationIndex === undefined) {\n      return undefined;\n    }\n\n    const lastLocationStep = trace.steps[lastLocationIndex];\n\n    if ((0, message_trace_1.isEvmStep)(lastLocationStep)) {\n      const lastInstructionWithLocation = trace.bytecode.getInstruction(lastLocationStep.pc);\n      return lastInstructionWithLocation;\n    }\n\n    return undefined;\n  }\n\n  _callInstructionToCallFailedToExecuteStackTraceEntry(bytecode, callInst) {\n    // Calls only happen within functions\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALL_FAILED_ERROR,\n      sourceReference: sourceLocationToSourceReference(bytecode, callInst.location)\n    };\n  }\n\n  _getEntryBeforeFailureInModifier(trace, functionJumpdests) {\n    // If there's a jumpdest, this modifier belongs to the last function that it represents\n    if (functionJumpdests.length > 0) {\n      return instructionToCallstackStackTraceEntry(trace.bytecode, functionJumpdests[functionJumpdests.length - 1]);\n    } // This function is only called after we jumped into the initial function in call traces, so\n    // there should always be at least a function jumpdest.\n\n\n    if (!(0, message_trace_1.isDecodedCreateTrace)(trace)) {\n      throw new Error(\"This shouldn't happen: a call trace has no functionJumpdest but has already jumped into a function\");\n    } // If there's no jump dest, we point to the constructor.\n\n\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: this._getConstructorStartSourceReference(trace),\n      functionType: model_1.ContractFunctionType.CONSTRUCTOR\n    };\n  }\n\n  _failsRightAfterCall(trace, callSubtraceStepIndex) {\n    const lastStep = trace.steps[trace.steps.length - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(lastStep)) {\n      return false;\n    }\n\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n\n    if (lastInst.opcode !== opcodes_1.Opcode.REVERT) {\n      return false;\n    }\n\n    const callOpcodeStep = trace.steps[callSubtraceStepIndex - 1];\n    const callInst = trace.bytecode.getInstruction(callOpcodeStep.pc);\n    return this._isLastLocation(trace, callSubtraceStepIndex + 1, callInst.location // Calls are always made from within functions\n    );\n  }\n\n  _isCallFailedError(trace, instIndex, callInstruction) {\n    const callLocation = callInstruction.location; // Calls are always made from within functions\n\n    return this._isLastLocation(trace, instIndex, callLocation);\n  }\n\n  _isLastLocation(trace, fromStep, location) {\n    for (let i = fromStep; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const stepInst = trace.bytecode.getInstruction(step.pc);\n\n      if (stepInst.location === undefined) {\n        continue;\n      }\n\n      if (!location.equals(stepInst.location)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _isSubtraceErrorPropagated(trace, callSubtraceStepIndex) {\n    var _a, _b;\n\n    const call = trace.steps[callSubtraceStepIndex];\n\n    if (!trace.returnData.equals(call.returnData)) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) === exceptions_1.ERROR.OUT_OF_GAS && ((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) === exceptions_1.ERROR.OUT_OF_GAS) {\n      return true;\n    }\n\n    return this._failsRightAfterCall(trace, callSubtraceStepIndex);\n  }\n\n  _isProxyErrorPropagated(trace, callSubtraceStepIndex) {\n    if (!(0, message_trace_1.isDecodedCallTrace)(trace)) {\n      return false;\n    }\n\n    const callStep = trace.steps[callSubtraceStepIndex - 1];\n\n    if (!(0, message_trace_1.isEvmStep)(callStep)) {\n      return false;\n    }\n\n    const callInst = trace.bytecode.getInstruction(callStep.pc);\n\n    if (callInst.opcode !== opcodes_1.Opcode.DELEGATECALL) {\n      return false;\n    }\n\n    const subtrace = trace.steps[callSubtraceStepIndex];\n\n    if ((0, message_trace_1.isEvmStep)(subtrace)) {\n      return false;\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(subtrace)) {\n      return false;\n    } // If we can't recognize the implementation we'd better don't consider it as such\n\n\n    if (subtrace.bytecode === undefined) {\n      return false;\n    }\n\n    if (subtrace.bytecode.contract.type === model_1.ContractType.LIBRARY) {\n      return false;\n    }\n\n    if (!trace.returnData.equals(subtrace.returnData)) {\n      return false;\n    }\n\n    for (let i = callSubtraceStepIndex + 1; i < trace.steps.length; i++) {\n      const step = trace.steps[i];\n\n      if (!(0, message_trace_1.isEvmStep)(step)) {\n        return false;\n      }\n\n      const inst = trace.bytecode.getInstruction(step.pc); // All the remaining locations should be valid, as they are part of the inline asm\n\n      if (inst.location === undefined) {\n        return false;\n      }\n\n      if (inst.jumpType === model_1.JumpType.INTO_FUNCTION || inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n        return false;\n      }\n    }\n\n    const lastStep = trace.steps[trace.steps.length - 1];\n    const lastInst = trace.bytecode.getInstruction(lastStep.pc);\n    return lastInst.opcode === opcodes_1.Opcode.REVERT;\n  }\n\n  _isContractCallRunOutOfGasError(trace, callStepIndex) {\n    var _a, _b;\n\n    if (trace.returnData.length > 0) {\n      return false;\n    }\n\n    if (((_a = trace.error) === null || _a === void 0 ? void 0 : _a.error) !== exceptions_1.ERROR.REVERT) {\n      return false;\n    }\n\n    const call = trace.steps[callStepIndex];\n\n    if (((_b = call.error) === null || _b === void 0 ? void 0 : _b.error) !== exceptions_1.ERROR.OUT_OF_GAS) {\n      return false;\n    }\n\n    return this._failsRightAfterCall(trace, callStepIndex);\n  }\n\n  _isPanicReturnData(returnData) {\n    return new return_data_1.ReturnData(returnData).isPanicReturnData();\n  }\n\n}\n\nexports.ErrorInferrer = ErrorInferrer;\n\nfunction instructionToCallstackStackTraceEntry(bytecode, inst) {\n  // This means that a jump is made from within an internal solc function.\n  // These are normally made from yul code, so they don't map to any Solidity\n  // function\n  if (inst.location === undefined) {\n    const location = bytecode.contract.location;\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.INTERNAL_FUNCTION_CALLSTACK_ENTRY,\n      pc: inst.pc,\n      sourceReference: {\n        sourceName: bytecode.contract.location.file.sourceName,\n        sourceContent: bytecode.contract.location.file.content,\n        contract: bytecode.contract.name,\n        function: undefined,\n        line: bytecode.contract.location.getStartingLineNumber(),\n        range: [location.offset, location.offset + location.length]\n      }\n    };\n  }\n\n  const func = inst.location.getContainingFunction();\n\n  if (func !== undefined) {\n    return {\n      type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n      sourceReference: sourceLocationToSourceReference(bytecode, inst.location),\n      functionType: func.type\n    };\n  }\n\n  return {\n    type: solidity_stack_trace_1.StackTraceEntryType.CALLSTACK_ENTRY,\n    sourceReference: {\n      function: undefined,\n      contract: bytecode.contract.name,\n      sourceName: inst.location.file.sourceName,\n      sourceContent: inst.location.file.content,\n      line: inst.location.getStartingLineNumber(),\n      range: [inst.location.offset, inst.location.offset + inst.location.length]\n    },\n    functionType: model_1.ContractFunctionType.FUNCTION\n  };\n}\n\nexports.instructionToCallstackStackTraceEntry = instructionToCallstackStackTraceEntry;\n\nfunction sourceLocationToSourceReference(bytecode, location) {\n  if (location === undefined) {\n    return undefined;\n  }\n\n  const func = location.getContainingFunction();\n\n  if (func === undefined) {\n    return undefined;\n  }\n\n  let funcName = func.name;\n\n  if (func.type === model_1.ContractFunctionType.CONSTRUCTOR) {\n    funcName = solidity_stack_trace_1.CONSTRUCTOR_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.FALLBACK) {\n    funcName = solidity_stack_trace_1.FALLBACK_FUNCTION_NAME;\n  } else if (func.type === model_1.ContractFunctionType.RECEIVE) {\n    funcName = solidity_stack_trace_1.RECEIVE_FUNCTION_NAME;\n  }\n\n  return {\n    function: funcName,\n    contract: func.type === model_1.ContractFunctionType.FREE_FUNCTION ? undefined : bytecode.contract.name,\n    sourceName: func.location.file.sourceName,\n    sourceContent: func.location.file.content,\n    line: location.getStartingLineNumber(),\n    range: [location.offset, location.offset + location.length]\n  };\n}","map":{"version":3,"mappings":"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","names":["FIRST_SOLC_VERSION_CREATE_PARAMS_VALIDATION","FIRST_SOLC_VERSION_RECEIVE_FUNCTION","FIRST_SOLC_VERSION_WITH_UNMAPPED_REVERTS","EIP170_BYTECODE_SIZE_INCLUSIVE_LIMIT","ErrorInferrer","inferBeforeTracingCallMessage","trace","_isDirectLibraryCall","_getDirectLibraryCallErrorStackTrace","calledFunction","bytecode","contract","getFunctionFromSelector","calldata","slice","_isFunctionNotPayableError","type","solidity_stack_trace_1","FUNCTION_NOT_PAYABLE_ERROR","sourceReference","_getFunctionStartSourceReference","value","_isMissingFunctionAndFallbackError","_emptyCalldataAndNoReceive","MISSING_FALLBACK_OR_RECEIVE_ERROR","_getContractStartWithoutFunctionSourceReference","UNRECOGNIZED_FUNCTION_WITHOUT_FALLBACK_ERROR","_isFallbackNotPayableError","FALLBACK_NOT_PAYABLE_AND_NO_RECEIVE_ERROR","_getFallbackStartSourceReference","FALLBACK_NOT_PAYABLE_ERROR","inferBeforeTracingCreateMessage","_isConstructorNotPayableError","_getConstructorStartSourceReference","_isConstructorInvalidArgumentsError","INVALID_PARAMS_ERROR","inferAfterTracing","stacktrace","functionJumpdests","jumpedIntoFunction","lastSubmessageData","_checkLastSubmessage","_a","_checkFailedLastCall","_b","_checkLastInstruction","_c","_checkNonContractCalled","_d","_checkSolidity063UnmappedRevert","_e","_checkContractTooLarge","_f","_otherExecutionErrorStacktrace","filterRedundantFrames","filter","frame","i","length","nextFrame","undefined","CALLSTACK_ENTRY","RETURNDATA_SIZE_ERROR","thatSrcRef","range","line","function","inferredStacktrace","callStep","steps","stepIndex","Error","callInst","getInstruction","pc","callStackFrame","instructionToCallstackStackTraceEntry","lastMessageFailed","messageTrace","error","push","_isSubtraceErrorPropagated","_isProxyErrorPropagated","_isContractCallRunOutOfGasError","lastFrame","pop","CONTRACT_CALL_RUN_OUT_OF_GAS_ERROR","_fixInitialModifier","isReturnDataSizeError","_failsRightAfterCall","step","nextStep","inst","isCallOrCreate","opcode","_isCallFailedError","_callInstructionToCallFailedToExecuteStackTraceEntry","_checkRevertOrInvalidOpcode","lastInstruction","opcodes_1","REVERT","INVALID","location","failingFunction","getContainingFunction","model_1","MODIFIER","_getEntryBeforeFailureInModifier","panicStacktrace","_checkPanic","customErrorStacktrace","_checkCustomErrors","_instructionWithinFunctionToRevertStackTraceEntry","REVERT_ERROR","message","return_data_1","returnData","isInvalidOpcodeError","revertFrame","_getLastSourceReference","_isPanicReturnData","INTERNAL_FUNCTION_CALLSTACK_ENTRY","splice","panicReturnData","errorCode","decodePanic","eqn","_instructionWithinFunctionToPanicStackTraceEntry","isEmpty","isErrorReturnData","errorMessage","customError","customErrors","matchesSelector","selector","decodedValues","abi_1","decode","paramTypes","params","abi_helpers_1","formatValues","name","_instructionWithinFunctionToCustomErrorStackTraceEntry","lastStep","revertOrInvalidStacktrace","_hasFailedInsideTheFallbackFunction","_hasFailedInsideTheReceiveFunction","_solidity063MaybeUnmappedRevert","_solidity063GetFrameForUnmappedRevertBeforeFunction","_getOtherErrorBeforeCalledFunctionStackTraceEntry","_isCalledNonContractAccountError","nonContractCalledFrame","NONCONTRACT_ACCOUNT_CALLED_ERROR","_solidity063GetFrameForUnmappedRevertWithinFunction","_isContractTooLargeError","CONTRACT_TOO_LARGE_ERROR","otherExecutionErrorFrame","OTHER_EXECUTION_ERROR","firstEntry","functionType","_getEntryBeforeInitialModifierCallstackEntry","depth","LIBRARY","func","DIRECT_LIBRARY_CALL_ERROR","lten","isPayable","sourceName","file","sourceContent","content","getStartingLineNumber","offset","receive","fallback","semver_1","lt","compilerVersion","constructor","constructorFunction","gtn","lastInst","hasReadDeploymentCodeSize","equals","CODESIZE","CONSTRUCTOR","FUNCTION","FALLBACK","sourceLocationToSourceReference","_hasFailedInsideFunction","contains","PANIC_ERROR","CUSTOM_ERROR","satisfies","UNMAPPED_SOLC_0_6_3_REVERT_ERROR","_solidity063CorrectLineNumber","lastIndex","_getLastInstructionWithValidLocationStepIndex","ISZERO","prevStep","prevInst","EXTCODESIZE","_getLastInstructionWithValidLocation","nextInstPc","hasNextInst","hasInstruction","nextInst","prevLoc","nextLoc","prevFunc","nextFunc","constructorRevertFrame","defaultSourceReference","latestInstructionRevertFrame","exceptions_1","OUT_OF_GAS","RETURN","normalizedCode","lines","split","currentLine","includes","nextLines","firstNonEmptyLine","findIndex","l","trim","nextLine","lastLocationIndex","lastLocationStep","lastInstructionWithLocation","CALL_FAILED_ERROR","callSubtraceStepIndex","callOpcodeStep","_isLastLocation","instIndex","callInstruction","callLocation","fromStep","stepInst","call","DELEGATECALL","subtrace","jumpType","INTO_FUNCTION","OUTOF_FUNCTION","callStepIndex","isPanicReturnData","exports","funcName","RECEIVE","FREE_FUNCTION"],"sourceRoot":"","sources":["../../../src/internal/hardhat-network/stack-traces/error-inferrer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}