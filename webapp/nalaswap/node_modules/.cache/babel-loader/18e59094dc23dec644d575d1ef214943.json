{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SolidityTracer = exports.FIRST_SOLC_VERSION_SUPPORTED = exports.SUPPORTED_SOLIDITY_VERSION_RANGE = void 0;\n\nconst return_data_1 = require(\"../provider/return-data\");\n\nconst error_inferrer_1 = require(\"./error-inferrer\");\n\nconst mapped_inlined_internal_functions_heuristics_1 = require(\"./mapped-inlined-internal-functions-heuristics\");\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst model_1 = require(\"./model\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nexports.SUPPORTED_SOLIDITY_VERSION_RANGE = \"<=0.8.9\";\nexports.FIRST_SOLC_VERSION_SUPPORTED = \"0.5.1\";\n\nclass SolidityTracer {\n  constructor() {\n    this._errorInferrer = new error_inferrer_1.ErrorInferrer();\n  }\n\n  getStackTrace(maybeDecodedMessageTrace) {\n    if (maybeDecodedMessageTrace.error === undefined) {\n      return [];\n    }\n\n    if ((0, message_trace_1.isPrecompileTrace)(maybeDecodedMessageTrace)) {\n      return this._getPrecompileMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if ((0, message_trace_1.isDecodedCreateTrace)(maybeDecodedMessageTrace)) {\n      return this._getCreateMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    if ((0, message_trace_1.isDecodedCallTrace)(maybeDecodedMessageTrace)) {\n      return this._getCallMessageStackTrace(maybeDecodedMessageTrace);\n    }\n\n    return this._getUnrecognizedMessageStackTrace(maybeDecodedMessageTrace);\n  }\n\n  _getCallMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCallMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getUnrecognizedMessageStackTrace(trace) {\n    const subtrace = this._getLastSubtrace(trace);\n\n    if (subtrace !== undefined) {\n      // This is not a very exact heuristic, but most of the time it will be right, as solidity\n      // reverts if a call fails, and most contracts are in solidity\n      if (subtrace.error !== undefined && trace.returnData.equals(subtrace.returnData)) {\n        let unrecognizedEntry;\n\n        if ((0, message_trace_1.isCreateTrace)(trace)) {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_CALLSTACK_ENTRY\n          };\n        } else {\n          unrecognizedEntry = {\n            type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY,\n            address: trace.address\n          };\n        }\n\n        return [unrecognizedEntry, ...this.getStackTrace(subtrace)];\n      }\n    }\n\n    if ((0, message_trace_1.isCreateTrace)(trace)) {\n      return [{\n        type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CREATE_ERROR,\n        message: new return_data_1.ReturnData(trace.returnData)\n      }];\n    }\n\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.UNRECOGNIZED_CONTRACT_ERROR,\n      address: trace.address,\n      message: new return_data_1.ReturnData(trace.returnData)\n    }];\n  }\n\n  _getCreateMessageStackTrace(trace) {\n    const inferredError = this._errorInferrer.inferBeforeTracingCreateMessage(trace);\n\n    if (inferredError !== undefined) {\n      return inferredError;\n    }\n\n    return this._traceEvmExecution(trace);\n  }\n\n  _getPrecompileMessageStackTrace(trace) {\n    return [{\n      type: solidity_stack_trace_1.StackTraceEntryType.PRECOMPILE_ERROR,\n      precompile: trace.precompile\n    }];\n  }\n\n  _traceEvmExecution(trace) {\n    const stackTrace = this._rawTraceEvmExecution(trace);\n\n    if ((0, mapped_inlined_internal_functions_heuristics_1.stackTraceMayRequireAdjustments)(stackTrace, trace)) {\n      return (0, mapped_inlined_internal_functions_heuristics_1.adjustStackTrace)(stackTrace, trace);\n    }\n\n    return stackTrace;\n  }\n\n  _rawTraceEvmExecution(trace) {\n    const stacktrace = [];\n    let subtracesSeen = 0;\n    let jumpedIntoFunction = false;\n    const functionJumpdests = [];\n    let lastSubmessageData;\n\n    for (let stepIndex = 0; stepIndex < trace.steps.length; stepIndex++) {\n      const step = trace.steps[stepIndex];\n      const nextStep = trace.steps[stepIndex + 1];\n\n      if ((0, message_trace_1.isEvmStep)(step)) {\n        const inst = trace.bytecode.getInstruction(step.pc);\n\n        if (inst.jumpType === model_1.JumpType.INTO_FUNCTION) {\n          const nextEvmStep = nextStep; // A jump can't be followed by a subtrace\n\n          const nextInst = trace.bytecode.getInstruction(nextEvmStep.pc);\n\n          if (nextInst !== undefined && nextInst.opcode === opcodes_1.Opcode.JUMPDEST) {\n            stacktrace.push((0, error_inferrer_1.instructionToCallstackStackTraceEntry)(trace.bytecode, inst));\n\n            if (nextInst.location !== undefined) {\n              jumpedIntoFunction = true;\n            }\n\n            functionJumpdests.push(nextInst);\n          }\n        } else if (inst.jumpType === model_1.JumpType.OUTOF_FUNCTION) {\n          stacktrace.pop();\n          functionJumpdests.pop();\n        }\n      } else {\n        subtracesSeen += 1; // If there are more subtraces, this one didn't terminate the execution\n\n        if (subtracesSeen < trace.numberOfSubtraces) {\n          continue;\n        }\n\n        const submessageTrace = this.getStackTrace(step);\n        lastSubmessageData = {\n          messageTrace: step,\n          stepIndex,\n          stacktrace: submessageTrace\n        };\n      }\n    }\n\n    const stacktraceWithInferredError = this._errorInferrer.inferAfterTracing(trace, stacktrace, functionJumpdests, jumpedIntoFunction, lastSubmessageData);\n\n    return this._errorInferrer.filterRedundantFrames(stacktraceWithInferredError);\n  }\n\n  _getLastSubtrace(trace) {\n    if (trace.numberOfSubtraces < 1) {\n      return undefined;\n    }\n\n    let i = trace.steps.length - 1;\n\n    while ((0, message_trace_1.isEvmStep)(trace.steps[i])) {\n      i -= 1;\n    }\n\n    return trace.steps[i];\n  }\n\n}\n\nexports.SolidityTracer = SolidityTracer;","map":{"version":3,"mappings":"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","names":["exports","SolidityTracer","constructor","error_inferrer_1","getStackTrace","maybeDecodedMessageTrace","error","undefined","_getPrecompileMessageStackTrace","_getCreateMessageStackTrace","_getCallMessageStackTrace","_getUnrecognizedMessageStackTrace","trace","inferredError","_errorInferrer","inferBeforeTracingCallMessage","_traceEvmExecution","subtrace","_getLastSubtrace","returnData","equals","unrecognizedEntry","type","solidity_stack_trace_1","UNRECOGNIZED_CREATE_CALLSTACK_ENTRY","UNRECOGNIZED_CONTRACT_CALLSTACK_ENTRY","address","UNRECOGNIZED_CREATE_ERROR","message","return_data_1","UNRECOGNIZED_CONTRACT_ERROR","inferBeforeTracingCreateMessage","PRECOMPILE_ERROR","precompile","stackTrace","_rawTraceEvmExecution","stacktrace","subtracesSeen","jumpedIntoFunction","functionJumpdests","lastSubmessageData","stepIndex","steps","length","step","nextStep","inst","bytecode","getInstruction","pc","jumpType","model_1","INTO_FUNCTION","nextEvmStep","nextInst","opcode","opcodes_1","JUMPDEST","push","location","OUTOF_FUNCTION","pop","numberOfSubtraces","submessageTrace","messageTrace","stacktraceWithInferredError","inferAfterTracing","filterRedundantFrames","i"],"sourceRoot":"","sources":["../../../src/internal/hardhat-network/stack-traces/solidityTracer.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}