{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArgumentsParser = void 0;\n\nconst errors_1 = require(\"../core/errors\");\n\nconst errors_list_1 = require(\"../core/errors-list\");\n\nclass ArgumentsParser {\n  static paramNameToCLA(paramName) {\n    return ArgumentsParser.PARAM_PREFIX + paramName.split(/(?=[A-Z])/g).map(s => s.toLowerCase()).join(\"-\");\n  }\n\n  static cLAToParamName(cLA) {\n    if (cLA.toLowerCase() !== cLA) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.PARAM_NAME_INVALID_CASING, {\n        param: cLA\n      });\n    }\n\n    const parts = cLA.slice(ArgumentsParser.PARAM_PREFIX.length).split(\"-\").filter(x => x.length > 0);\n    return parts[0] + parts.slice(1).map(s => s[0].toUpperCase() + s.slice(1)).join(\"\");\n  }\n\n  parseHardhatArguments(hardhatParamDefinitions, envVariableArguments, rawCLAs) {\n    const hardhatArguments = {};\n    let taskName;\n    const unparsedCLAs = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (taskName === undefined) {\n        if (!this._hasCLAParamNameFormat(arg)) {\n          taskName = arg;\n          continue;\n        }\n\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_COMMAND_LINE_ARG, {\n            argument: arg\n          });\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      } else {\n        if (!this._isCLAParamName(arg, hardhatParamDefinitions)) {\n          unparsedCLAs.push(arg);\n          continue;\n        }\n\n        i = this._parseArgumentAt(rawCLAs, i, hardhatParamDefinitions, hardhatArguments);\n      }\n    }\n\n    return {\n      hardhatArguments: this._addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments),\n      taskName,\n      unparsedCLAs\n    };\n  }\n\n  parseTaskArguments(taskDefinition, rawCLAs) {\n    const {\n      paramArguments,\n      rawPositionalArguments\n    } = this._parseTaskParamArguments(taskDefinition, rawCLAs);\n\n    const positionalArguments = this._parsePositionalParamArgs(rawPositionalArguments, taskDefinition.positionalParamDefinitions);\n\n    return Object.assign(Object.assign({}, paramArguments), positionalArguments);\n  }\n\n  _parseTaskParamArguments(taskDefinition, rawCLAs) {\n    const paramArguments = {};\n    const rawPositionalArguments = [];\n\n    for (let i = 0; i < rawCLAs.length; i++) {\n      const arg = rawCLAs[i];\n\n      if (!this._hasCLAParamNameFormat(arg)) {\n        rawPositionalArguments.push(arg);\n        continue;\n      }\n\n      if (!this._isCLAParamName(arg, taskDefinition.paramDefinitions)) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_PARAM_NAME, {\n          param: arg\n        });\n      }\n\n      i = this._parseArgumentAt(rawCLAs, i, taskDefinition.paramDefinitions, paramArguments);\n    }\n\n    this._addTaskDefaultArguments(taskDefinition, paramArguments);\n\n    return {\n      paramArguments,\n      rawPositionalArguments\n    };\n  }\n\n  _addHardhatDefaultArguments(hardhatParamDefinitions, envVariableArguments, hardhatArguments) {\n    return Object.assign(Object.assign({}, envVariableArguments), hardhatArguments);\n  }\n\n  _addTaskDefaultArguments(taskDefinition, taskArguments) {\n    for (const paramName of Object.keys(taskDefinition.paramDefinitions)) {\n      const definition = taskDefinition.paramDefinitions[paramName];\n\n      if (taskArguments[paramName] !== undefined) {\n        continue;\n      }\n\n      if (!definition.isOptional) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      }\n\n      taskArguments[paramName] = definition.defaultValue;\n    }\n  }\n\n  _isCLAParamName(str, paramDefinitions) {\n    if (!this._hasCLAParamNameFormat(str)) {\n      return false;\n    }\n\n    const name = ArgumentsParser.cLAToParamName(str);\n    return paramDefinitions[name] !== undefined;\n  }\n\n  _hasCLAParamNameFormat(str) {\n    return str.startsWith(ArgumentsParser.PARAM_PREFIX);\n  }\n\n  _parseArgumentAt(rawCLAs, index, paramDefinitions, parsedArguments) {\n    const claArg = rawCLAs[index];\n    const paramName = ArgumentsParser.cLAToParamName(claArg);\n    const definition = paramDefinitions[paramName];\n\n    if (parsedArguments[paramName] !== undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.REPEATED_PARAM, {\n        param: claArg\n      });\n    }\n\n    if (definition.isFlag) {\n      parsedArguments[paramName] = true;\n    } else {\n      index++;\n      const value = rawCLAs[index];\n\n      if (value === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n          param: ArgumentsParser.paramNameToCLA(paramName)\n        });\n      } // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n\n      const type = definition.type;\n      parsedArguments[paramName] = type.parse(paramName, value);\n    }\n\n    return index;\n  }\n\n  _parsePositionalParamArgs(rawPositionalParamArgs, positionalParamDefinitions) {\n    const args = {};\n\n    for (let i = 0; i < positionalParamDefinitions.length; i++) {\n      const definition = positionalParamDefinitions[i]; // We only parse the arguments of non-subtasks, and those only\n      // accept CLIArgumentTypes.\n\n      const type = definition.type;\n      const rawArg = rawPositionalParamArgs[i];\n\n      if (rawArg === undefined) {\n        if (!definition.isOptional) {\n          throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_POSITIONAL_ARG, {\n            param: definition.name\n          });\n        }\n\n        args[definition.name] = definition.defaultValue;\n      } else if (!definition.isVariadic) {\n        args[definition.name] = type.parse(definition.name, rawArg);\n      } else {\n        args[definition.name] = rawPositionalParamArgs.slice(i).map(raw => type.parse(definition.name, raw));\n      }\n    }\n\n    const lastDefinition = positionalParamDefinitions[positionalParamDefinitions.length - 1];\n    const hasVariadicParam = lastDefinition !== undefined && lastDefinition.isVariadic;\n\n    if (!hasVariadicParam && rawPositionalParamArgs.length > positionalParamDefinitions.length) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_POSITIONAL_ARG, {\n        argument: rawPositionalParamArgs[positionalParamDefinitions.length]\n      });\n    }\n\n    return args;\n  }\n\n}\n\nexports.ArgumentsParser = ArgumentsParser;\nArgumentsParser.PARAM_PREFIX = \"--\";","map":{"version":3,"mappings":"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","names":["ArgumentsParser","paramNameToCLA","paramName","PARAM_PREFIX","split","map","s","toLowerCase","join","cLAToParamName","cLA","errors_1","errors_list_1","ARGUMENTS","PARAM_NAME_INVALID_CASING","param","parts","slice","length","filter","x","toUpperCase","parseHardhatArguments","hardhatParamDefinitions","envVariableArguments","rawCLAs","hardhatArguments","taskName","unparsedCLAs","i","arg","undefined","_hasCLAParamNameFormat","_isCLAParamName","UNRECOGNIZED_COMMAND_LINE_ARG","argument","_parseArgumentAt","push","_addHardhatDefaultArguments","parseTaskArguments","taskDefinition","paramArguments","rawPositionalArguments","_parseTaskParamArguments","positionalArguments","_parsePositionalParamArgs","positionalParamDefinitions","paramDefinitions","UNRECOGNIZED_PARAM_NAME","_addTaskDefaultArguments","taskArguments","Object","keys","definition","isOptional","MISSING_TASK_ARGUMENT","defaultValue","str","name","startsWith","index","parsedArguments","claArg","REPEATED_PARAM","isFlag","value","type","parse","rawPositionalParamArgs","args","rawArg","MISSING_POSITIONAL_ARG","isVariadic","raw","lastDefinition","hasVariadicParam","UNRECOGNIZED_POSITIONAL_ARG","exports"],"sourceRoot":"","sources":["../../src/internal/cli/ArgumentsParser.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}