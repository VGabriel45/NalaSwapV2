{"ast":null,"code":"\"use strict\";\n/**\n * This file includes Solidity tracing heuristics for solc starting with version\n * 0.6.9.\n *\n * This solc version introduced a significant change to how sourcemaps are\n * handled for inline yul/internal functions. These were mapped to the\n * unmapped/-1 file before, which lead to many unmapped reverts. Now, they are\n * mapped to the part of the Solidity source that lead to their inlining.\n *\n * This change is a very positive change, as errors would point to the correct\n * line by default. The only problem is that we used to rely very heavily on\n * unmapped reverts to decide when our error detection heuristics were to be\n * run. In fact, this heuristics were first introduced because of unmapped\n * reverts.\n *\n * Instead of synthetically completing stack traces when unmapped reverts occur,\n * we now start from complete stack traces and adjust them if we can provide\n * more meaningful errors.\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.adjustStackTrace = exports.stackTraceMayRequireAdjustments = void 0;\n\nconst semver_1 = __importDefault(require(\"semver\"));\n\nconst message_trace_1 = require(\"./message-trace\");\n\nconst opcodes_1 = require(\"./opcodes\");\n\nconst solidity_stack_trace_1 = require(\"./solidity-stack-trace\");\n\nconst FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS = \"0.6.9\";\n\nfunction stackTraceMayRequireAdjustments(stackTrace, decodedTrace) {\n  if (stackTrace.length === 0) {\n    return false;\n  }\n\n  const lastFrame = stackTrace[stackTrace.length - 1];\n  return lastFrame.type === solidity_stack_trace_1.StackTraceEntryType.REVERT_ERROR && !lastFrame.isInvalidOpcodeError && lastFrame.message.isEmpty() && semver_1.default.gte(decodedTrace.bytecode.compilerVersion, FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS);\n}\n\nexports.stackTraceMayRequireAdjustments = stackTraceMayRequireAdjustments;\n\nfunction adjustStackTrace(stackTrace, decodedTrace) {\n  const start = stackTrace.slice(0, -1);\n  const [revert] = stackTrace.slice(-1);\n\n  if (isNonContractAccountCalledError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.NONCONTRACT_ACCOUNT_CALLED_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isConstructorInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  if (isCallInvalidParamsError(decodedTrace)) {\n    return [...start, {\n      type: solidity_stack_trace_1.StackTraceEntryType.INVALID_PARAMS_ERROR,\n      sourceReference: revert.sourceReference\n    }];\n  }\n\n  return stackTrace;\n}\n\nexports.adjustStackTrace = adjustStackTrace;\n\nfunction isNonContractAccountCalledError(decodedTrace) {\n  return matchOpcodes(decodedTrace, -9, [opcodes_1.Opcode.EXTCODESIZE, opcodes_1.Opcode.ISZERO, opcodes_1.Opcode.DUP1, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isConstructorInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCreateTrace)(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -20, [opcodes_1.Opcode.CODESIZE]) && matchOpcodes(decodedTrace, -15, [opcodes_1.Opcode.CODECOPY]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction isCallInvalidParamsError(decodedTrace) {\n  if (!(0, message_trace_1.isDecodedCallTrace)(decodedTrace)) {\n    return false;\n  }\n\n  return matchOpcodes(decodedTrace, -11, [opcodes_1.Opcode.CALLDATASIZE]) && matchOpcodes(decodedTrace, -7, [opcodes_1.Opcode.LT, opcodes_1.Opcode.ISZERO]);\n}\n\nfunction matchOpcode(decodedTrace, stepIndex, opcode) {\n  const [step] = decodedTrace.steps.slice(stepIndex, stepIndex + 1);\n\n  if (step === undefined || !(0, message_trace_1.isEvmStep)(step)) {\n    return false;\n  }\n\n  const instruction = decodedTrace.bytecode.getInstruction(step.pc);\n  return instruction.opcode === opcode;\n}\n\nfunction matchOpcodes(decodedTrace, firstStepIndex, opcodes) {\n  let index = firstStepIndex;\n\n  for (const opcode of opcodes) {\n    if (!matchOpcode(decodedTrace, index, opcode)) {\n      return false;\n    }\n\n    index += 1;\n  }\n\n  return true;\n}","map":{"version":3,"mappings":"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","names":["FIRST_SOLC_VERSION_WITH_MAPPED_SMALL_INTERNAL_FUNCTIONS","stackTraceMayRequireAdjustments","stackTrace","decodedTrace","length","lastFrame","type","solidity_stack_trace_1","REVERT_ERROR","isInvalidOpcodeError","message","isEmpty","semver_1","gte","bytecode","compilerVersion","exports","adjustStackTrace","start","slice","revert","isNonContractAccountCalledError","NONCONTRACT_ACCOUNT_CALLED_ERROR","sourceReference","isConstructorInvalidParamsError","INVALID_PARAMS_ERROR","isCallInvalidParamsError","matchOpcodes","opcodes_1","EXTCODESIZE","ISZERO","DUP1","CODESIZE","CODECOPY","LT","CALLDATASIZE","matchOpcode","stepIndex","opcode","step","steps","undefined","instruction","getInstruction","pc","firstStepIndex","opcodes","index"],"sourceRoot":"","sources":["../../../src/internal/hardhat-network/stack-traces/mapped-inlined-internal-functions-heuristics.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}