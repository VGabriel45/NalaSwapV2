{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Environment = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst artifacts_1 = require(\"../artifacts\");\n\nconst lazy_1 = require(\"../util/lazy\");\n\nconst config_loading_1 = require(\"./config/config-loading\");\n\nconst errors_1 = require(\"./errors\");\n\nconst errors_list_1 = require(\"./errors-list\");\n\nconst construction_1 = require(\"./providers/construction\");\n\nconst task_definitions_1 = require(\"./tasks/task-definitions\");\n\nconst log = (0, debug_1.default)(\"hardhat:core:hre\");\n\nclass Environment {\n  /**\n   * Initializes the Hardhat Runtime Environment and the given\n   * extender functions.\n   *\n   * @remarks The extenders' execution order is given by the order\n   * of the requires in the hardhat's config file and its plugins.\n   *\n   * @param config The hardhat's config object.\n   * @param hardhatArguments The parsed hardhat's arguments.\n   * @param tasks A map of tasks.\n   * @param extenders A list of extenders.\n   */\n  constructor(config, hardhatArguments, tasks) {\n    var _this = this;\n\n    let extenders = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n    let experimentalHardhatNetworkMessageTraceHooks = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n    let userConfig = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n    this.config = config;\n    this.hardhatArguments = hardhatArguments;\n    this.tasks = tasks;\n    this.userConfig = userConfig;\n    /**\n     * Executes the task with the given name.\n     *\n     * @param name The task's name.\n     * @param taskArguments A map of task's arguments.\n     *\n     * @throws a HH303 if there aren't any defined tasks with the given name.\n     * @returns a promise with the task's execution result.\n     */\n\n    this.run = async function (name) {\n      let taskArguments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const taskDefinition = _this.tasks[name];\n      log(\"Running task %s\", name);\n\n      if (taskDefinition === undefined) {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {\n          task: name\n        });\n      }\n\n      const resolvedTaskArguments = _this._resolveValidTaskArguments(taskDefinition, taskArguments);\n\n      try {\n        return await _this._runTaskDefinition(taskDefinition, resolvedTaskArguments);\n      } catch (e) {\n        (0, config_loading_1.analyzeModuleNotFoundError)(e, _this.config.paths.configFile); // eslint-disable-next-line @nomiclabs/hardhat-internal-rules/only-hardhat-error\n\n        throw e;\n      }\n    };\n\n    log(\"Creating HardhatRuntimeEnvironment\");\n    const networkName = hardhatArguments.network !== undefined ? hardhatArguments.network : config.defaultNetwork;\n    const networkConfig = config.networks[networkName];\n\n    if (networkConfig === undefined) {\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {\n        network: networkName\n      });\n    }\n\n    this.artifacts = new artifacts_1.Artifacts(config.paths.artifacts);\n    const provider = (0, lazy_1.lazyObject)(() => {\n      log(`Creating provider for network ${networkName}`);\n      return (0, construction_1.createProvider)(networkName, networkConfig, this.config.paths, this.artifacts, experimentalHardhatNetworkMessageTraceHooks.map(hook => (trace, isCallMessageTrace) => hook(this, trace, isCallMessageTrace)));\n    });\n    this.network = {\n      name: networkName,\n      config: config.networks[networkName],\n      provider\n    };\n    this._extenders = extenders;\n    extenders.forEach(extender => extender(this));\n  }\n  /**\n   * Injects the properties of `this` (the Hardhat Runtime Environment) into the global scope.\n   *\n   * @param blacklist a list of property names that won't be injected.\n   *\n   * @returns a function that restores the previous environment.\n   */\n\n\n  injectToGlobal() {\n    let blacklist = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Environment._BLACKLISTED_PROPERTIES;\n    const globalAsAny = global;\n    const previousValues = {};\n    const previousHre = globalAsAny.hre;\n    globalAsAny.hre = this;\n\n    for (const [key, value] of Object.entries(this)) {\n      if (blacklist.includes(key)) {\n        continue;\n      }\n\n      previousValues[key] = globalAsAny[key];\n      globalAsAny[key] = value;\n    }\n\n    return () => {\n      for (const [key, _] of Object.entries(this)) {\n        if (blacklist.includes(key)) {\n          continue;\n        }\n\n        globalAsAny.hre = previousHre;\n        globalAsAny[key] = previousValues[key];\n      }\n    };\n  }\n\n  async _runTaskDefinition(taskDefinition, taskArguments) {\n    var _this2 = this;\n\n    let runSuperFunction;\n\n    if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {\n      runSuperFunction = async function () {\n        let _taskArguments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : taskArguments;\n\n        log(\"Running %s's super\", taskDefinition.name);\n        return _this2._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);\n      };\n\n      runSuperFunction.isDefined = true;\n    } else {\n      runSuperFunction = async () => {\n        throw new errors_1.HardhatError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {\n          taskName: taskDefinition.name\n        });\n      };\n\n      runSuperFunction.isDefined = false;\n    }\n\n    const runSuper = runSuperFunction;\n    const globalAsAny = global;\n    const previousRunSuper = globalAsAny.runSuper;\n    globalAsAny.runSuper = runSuper;\n    const uninjectFromGlobal = this.injectToGlobal();\n\n    try {\n      return await taskDefinition.action(taskArguments, this, runSuper);\n    } finally {\n      uninjectFromGlobal();\n      globalAsAny.runSuper = previousRunSuper;\n    }\n  }\n  /**\n   * Check that task arguments are within TaskDefinition defined params constraints.\n   * Also, populate missing, non-mandatory arguments with default param values (if any).\n   *\n   * @private\n   * @throws HardhatError if any of the following are true:\n   *  > a required argument is missing\n   *  > an argument's value's type doesn't match the defined param type\n   *\n   * @param taskDefinition\n   * @param taskArguments\n   * @returns resolvedTaskArguments\n   */\n\n\n  _resolveValidTaskArguments(taskDefinition, taskArguments) {\n    const {\n      paramDefinitions,\n      positionalParamDefinitions\n    } = taskDefinition;\n    const nonPositionalParamDefinitions = Object.values(paramDefinitions); // gather all task param definitions\n\n    const allTaskParamDefinitions = [...nonPositionalParamDefinitions, ...positionalParamDefinitions];\n    const initResolvedArguments = {\n      errors: [],\n      values: {}\n    };\n    const resolvedArguments = allTaskParamDefinitions.reduce((_ref, paramDefinition) => {\n      let {\n        errors,\n        values\n      } = _ref;\n\n      try {\n        const paramName = paramDefinition.name;\n        const argumentValue = taskArguments[paramName];\n\n        const resolvedArgumentValue = this._resolveArgument(paramDefinition, argumentValue);\n\n        if (resolvedArgumentValue !== undefined) {\n          values[paramName] = resolvedArgumentValue;\n        }\n      } catch (error) {\n        if (errors_1.HardhatError.isHardhatError(error)) {\n          errors.push(error);\n        }\n      }\n\n      return {\n        errors,\n        values\n      };\n    }, initResolvedArguments);\n    const {\n      errors: resolveErrors,\n      values: resolvedValues\n    } = resolvedArguments; // if has argument errors, throw the first one\n\n    if (resolveErrors.length > 0) {\n      throw resolveErrors[0];\n    } // append the rest of arguments that where not in the task param definitions\n\n\n    const resolvedTaskArguments = Object.assign(Object.assign({}, taskArguments), resolvedValues);\n    return resolvedTaskArguments;\n  }\n  /**\n   * Resolves an argument according to a ParamDefinition rules.\n   *\n   * @param paramDefinition\n   * @param argumentValue\n   * @private\n   */\n\n\n  _resolveArgument(paramDefinition, argumentValue) {\n    const {\n      name,\n      isOptional,\n      defaultValue\n    } = paramDefinition;\n\n    if (argumentValue === undefined) {\n      if (isOptional) {\n        // undefined & optional argument -> return defaultValue\n        return defaultValue;\n      } // undefined & mandatory argument -> error\n\n\n      throw new errors_1.HardhatError(errors_list_1.ERRORS.ARGUMENTS.MISSING_TASK_ARGUMENT, {\n        param: name\n      });\n    } // arg was present -> validate type, if applicable\n\n\n    this._checkTypeValidation(paramDefinition, argumentValue);\n\n    return argumentValue;\n  }\n  /**\n   * Checks if value is valid for the specified param definition.\n   *\n   * @param paramDefinition {ParamDefinition} - the param definition for validation\n   * @param argumentValue - the value to be validated\n   * @private\n   * @throws HH301 if value is not valid for the param type\n   */\n\n\n  _checkTypeValidation(paramDefinition, argumentValue) {\n    const {\n      name: paramName,\n      type,\n      isVariadic\n    } = paramDefinition; // in case of variadic param, argValue is an array and the type validation must pass for all values.\n    // otherwise, it's a single value that is to be validated\n\n    const argumentValueContainer = isVariadic ? argumentValue : [argumentValue];\n\n    for (const value of argumentValueContainer) {\n      type.validate(paramName, value);\n    }\n  }\n\n}\n\nexports.Environment = Environment;\nEnvironment._BLACKLISTED_PROPERTIES = [\"injectToGlobal\", \"_runTaskDefinition\"];","map":{"version":3,"mappings":"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","names":["log","Environment","constructor","config","hardhatArguments","tasks","extenders","experimentalHardhatNetworkMessageTraceHooks","userConfig","name","taskArguments","taskDefinition","undefined","errors_1","errors_list_1","ARGUMENTS","UNRECOGNIZED_TASK","task","resolvedTaskArguments","_resolveValidTaskArguments","_runTaskDefinition","e","paths","configFile","networkName","network","defaultNetwork","networkConfig","networks","NETWORK","CONFIG_NOT_FOUND","artifacts","artifacts_1","provider","map","hook","trace","isCallMessageTrace","_extenders","forEach","extender","injectToGlobal","blacklist","_BLACKLISTED_PROPERTIES","globalAsAny","global","previousValues","previousHre","hre","key","value","Object","entries","includes","_","runSuperFunction","task_definitions_1","_taskArguments","parentTaskDefinition","isDefined","TASK_DEFINITIONS","RUNSUPER_NOT_AVAILABLE","taskName","runSuper","previousRunSuper","uninjectFromGlobal","action","paramDefinitions","positionalParamDefinitions","nonPositionalParamDefinitions","values","allTaskParamDefinitions","initResolvedArguments","errors","resolvedArguments","reduce","paramDefinition","paramName","argumentValue","resolvedArgumentValue","_resolveArgument","error","isHardhatError","push","resolveErrors","resolvedValues","length","isOptional","defaultValue","MISSING_TASK_ARGUMENT","param","_checkTypeValidation","type","isVariadic","argumentValueContainer","validate","exports"],"sourceRoot":"","sources":["../../src/internal/core/runtime-environment.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}