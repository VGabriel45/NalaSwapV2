{"ast":null,"code":"'use strict';\n\nconst {\n  Headers,\n  HeadersList,\n  fill\n} = require('./headers');\n\nconst {\n  extractBody,\n  cloneBody,\n  mixinBody\n} = require('./body');\n\nconst util = require('../core/util');\n\nconst {\n  kEnumerableProperty\n} = util;\n\nconst {\n  responseURL,\n  isValidReasonPhrase,\n  toUSVString\n} = require('./util');\n\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenResponseHeaderNames\n} = require('./constants');\n\nconst {\n  kState,\n  kHeaders,\n  kGuard,\n  kRealm\n} = require('./symbols');\n\nconst {\n  kHeadersList\n} = require('../core/symbols');\n\nconst assert = require('assert'); // https://fetch.spec.whatwg.org/#response-class\n\n\nclass Response {\n  // Creates network error Response.\n  static error() {\n    // TODO\n    const relevantRealm = {\n      settingsObject: {}\n    }; // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n\n    const responseObject = new Response();\n    responseObject[kState] = makeNetworkError();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm;\n    return responseObject;\n  } // Creates a redirect Response that redirects to url with status status.\n\n\n  static redirect() {\n    const relevantRealm = {\n      settingsObject: {}\n    };\n\n    if (arguments.length < 1) {\n      throw new TypeError(`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${arguments.length} present.`);\n    }\n\n    const status = arguments.length >= 2 ? arguments.length <= 1 ? undefined : arguments[1] : 302;\n    const url = toUSVString(arguments.length <= 0 ? undefined : arguments[0]); // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n\n    let parsedURL;\n\n    try {\n      parsedURL = new URL(url);\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      });\n    } // 3. If status is not a redirect status, then throw a RangeError.\n\n\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code');\n    } // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n\n\n    const responseObject = new Response();\n    responseObject[kRealm] = relevantRealm;\n    responseObject[kHeaders][kGuard] = 'immutable';\n    responseObject[kHeaders][kRealm] = relevantRealm; // 5. Set responseObject’s response’s status to status.\n\n    responseObject[kState].status = status; // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n\n    const value = parsedURL.toString(); // 7. Append `Location`/value to responseObject’s response’s header list.\n\n    responseObject[kState].headersList.push('location', value); // 8. Return responseObject.\n\n    return responseObject;\n  } // https://fetch.spec.whatwg.org/#dom-response\n\n\n  constructor() {\n    if (arguments.length >= 1 && typeof (arguments.length <= 1 ? undefined : arguments[1]) !== 'object' && (arguments.length <= 1 ? undefined : arguments[1]) !== undefined) {\n      throw new TypeError(\"Failed to construct 'Request': cannot convert to dictionary.\");\n    }\n\n    const body = arguments.length >= 1 ? arguments.length <= 0 ? undefined : arguments[0] : null;\n    const init = arguments.length >= 2 ? (arguments.length <= 1 ? undefined : arguments[1]) ?? {} : {}; // TODO\n\n    this[kRealm] = {\n      settingsObject: {}\n    }; // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError();\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(`Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`);\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText');\n      }\n    } // 3. Set this’s response to a new response.\n\n\n    this[kState] = makeResponse({}); // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n\n    this[kHeaders] = new Headers();\n    this[kHeaders][kGuard] = 'response';\n    this[kHeaders][kHeadersList] = this[kState].headersList;\n    this[kHeaders][kRealm] = this[kRealm]; // 5. Set this’s response’s status to init[\"status\"].\n\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status;\n    } // 6. Set this’s response’s status message to init[\"statusText\"].\n\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText);\n    } // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n\n\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers);\n    } // 8. If body is non-null, then:\n\n\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body');\n      } // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n\n\n      const [extractedBody, contentType] = extractBody(body);\n      this[kState].body = extractedBody; // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    }\n\n    return this.constructor.name;\n  } // Returns response’s type, e.g., \"cors\".\n\n\n  get type() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The type getter steps are to return this’s response’s type.\n\n\n    return this[kState].type;\n  } // Returns response’s URL, if it has one; otherwise the empty string.\n\n\n  get url() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n\n\n    let url = responseURL(this[kState]);\n\n    if (url == null) {\n      return '';\n    }\n\n    if (url.hash) {\n      url = new URL(url);\n      url.hash = '';\n    }\n\n    return url.toString();\n  } // Returns whether response was obtained through a redirect.\n\n\n  get redirected() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n\n\n    return this[kState].urlList.length > 1;\n  } // Returns response’s status.\n\n\n  get status() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The status getter steps are to return this’s response’s status.\n\n\n    return this[kState].status;\n  } // Returns whether response’s status is an ok status.\n\n\n  get ok() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n\n\n    return this[kState].status >= 200 && this[kState].status <= 299;\n  } // Returns response’s status message.\n\n\n  get statusText() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The statusText getter steps are to return this’s response’s status\n    // message.\n\n\n    return this[kState].statusText;\n  } // Returns response’s headers as Headers.\n\n\n  get headers() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // The headers getter steps are to return this’s headers.\n\n\n    return this[kHeaders];\n  } // Returns a clone of response.\n\n\n  clone() {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation');\n    } // 1. If this is unusable, then throw a TypeError.\n\n\n    if (this.bodyUsed || this.body && this.body.locked) {\n      throw new TypeError();\n    } // 2. Let clonedResponse be the result of cloning this’s response.\n\n\n    const clonedResponse = cloneResponse(this[kState]); // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n\n    const clonedResponseObject = new Response();\n    clonedResponseObject[kState] = clonedResponse;\n    clonedResponseObject[kRealm] = this[kRealm];\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList;\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard];\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm];\n    return clonedResponseObject;\n  }\n\n}\n\nmixinBody(Response.prototype);\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n}); // https://fetch.spec.whatwg.org/#concept-response-clone\n\nfunction cloneResponse(response) {\n  // To clone a response response, run these steps:\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(cloneResponse(response.internalResponse), response.type);\n  } // 2. Let newResponse be a copy of response, except for its body.\n\n\n  const newResponse = makeResponse({ ...response,\n    body: null\n  }); // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body);\n  } // 4. Return newResponse.\n\n\n  return newResponse;\n}\n\nfunction makeResponse(init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList ? new HeadersList(...init.headersList) : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  };\n}\n\nfunction makeNetworkError(reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error: reason instanceof Error ? reason : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  });\n} // https://fetch.spec.whatwg.org/#concept-filtered-response\n\n\nfunction filterResponse(response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n    const headers = [];\n\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenResponseHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1]);\n      }\n    }\n\n    return makeResponse({ ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    });\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n    // TODO: This is not correct...\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'cors'\n    });\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    });\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n    return makeResponse({ ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    });\n  } else {\n    assert(false);\n  }\n}\n\nmodule.exports = {\n  makeNetworkError,\n  makeResponse,\n  filterResponse,\n  Response\n};","map":{"version":3,"names":["Headers","HeadersList","fill","require","extractBody","cloneBody","mixinBody","util","kEnumerableProperty","responseURL","isValidReasonPhrase","toUSVString","redirectStatus","nullBodyStatus","forbiddenResponseHeaderNames","kState","kHeaders","kGuard","kRealm","kHeadersList","assert","Response","error","relevantRealm","settingsObject","responseObject","makeNetworkError","headersList","redirect","length","TypeError","status","url","parsedURL","URL","err","Object","assign","cause","includes","RangeError","value","toString","push","constructor","undefined","body","init","Number","isFinite","statusText","String","makeResponse","headers","extractedBody","contentType","has","set","Symbol","toStringTag","name","type","hash","redirected","urlList","ok","clone","bodyUsed","locked","clonedResponse","cloneResponse","clonedResponseObject","prototype","defineProperties","response","internalResponse","filterResponse","newResponse","aborted","rangeRequested","timingAllowPassed","timingInfo","cacheState","reason","Error","n","module","exports"],"sources":["/Users/ja/Desktop/MyProjects/NalaSwap/webapp/nalaswap/node_modules/undici/lib/fetch/response.js"],"sourcesContent":["'use strict'\n\nconst { Headers, HeadersList, fill } = require('./headers')\nconst { extractBody, cloneBody, mixinBody } = require('./body')\nconst util = require('../core/util')\nconst { kEnumerableProperty } = util\nconst { responseURL, isValidReasonPhrase, toUSVString } = require('./util')\nconst {\n  redirectStatus,\n  nullBodyStatus,\n  forbiddenResponseHeaderNames\n} = require('./constants')\nconst { kState, kHeaders, kGuard, kRealm } = require('./symbols')\nconst { kHeadersList } = require('../core/symbols')\nconst assert = require('assert')\n\n// https://fetch.spec.whatwg.org/#response-class\nclass Response {\n  // Creates network error Response.\n  static error () {\n    // TODO\n    const relevantRealm = { settingsObject: {} }\n\n    // The static error() method steps are to return the result of creating a\n    // Response object, given a new network error, \"immutable\", and this’s\n    // relevant Realm.\n    const responseObject = new Response()\n    responseObject[kState] = makeNetworkError()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kHeadersList] = responseObject[kState].headersList\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n    return responseObject\n  }\n\n  // Creates a redirect Response that redirects to url with status status.\n  static redirect (...args) {\n    const relevantRealm = { settingsObject: {} }\n\n    if (args.length < 1) {\n      throw new TypeError(\n        `Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`\n      )\n    }\n\n    const status = args.length >= 2 ? args[1] : 302\n    const url = toUSVString(args[0])\n\n    // 1. Let parsedURL be the result of parsing url with current settings\n    // object’s API base URL.\n    // 2. If parsedURL is failure, then throw a TypeError.\n    // TODO: base-URL?\n    let parsedURL\n    try {\n      parsedURL = new URL(url)\n    } catch (err) {\n      throw Object.assign(new TypeError('Failed to parse URL from ' + url), {\n        cause: err\n      })\n    }\n\n    // 3. If status is not a redirect status, then throw a RangeError.\n    if (!redirectStatus.includes(status)) {\n      throw new RangeError('Invalid status code')\n    }\n\n    // 4. Let responseObject be the result of creating a Response object,\n    // given a new response, \"immutable\", and this’s relevant Realm.\n    const responseObject = new Response()\n    responseObject[kRealm] = relevantRealm\n    responseObject[kHeaders][kGuard] = 'immutable'\n    responseObject[kHeaders][kRealm] = relevantRealm\n\n    // 5. Set responseObject’s response’s status to status.\n    responseObject[kState].status = status\n\n    // 6. Let value be parsedURL, serialized and isomorphic encoded.\n    // TODO: isomorphic encoded?\n    const value = parsedURL.toString()\n\n    // 7. Append `Location`/value to responseObject’s response’s header list.\n    responseObject[kState].headersList.push('location', value)\n\n    // 8. Return responseObject.\n    return responseObject\n  }\n\n  // https://fetch.spec.whatwg.org/#dom-response\n  constructor (...args) {\n    if (\n      args.length >= 1 &&\n      typeof args[1] !== 'object' &&\n      args[1] !== undefined\n    ) {\n      throw new TypeError(\n        \"Failed to construct 'Request': cannot convert to dictionary.\"\n      )\n    }\n\n    const body = args.length >= 1 ? args[0] : null\n    const init = args.length >= 2 ? args[1] ?? {} : {}\n\n    // TODO\n    this[kRealm] = { settingsObject: {} }\n\n    // 1. If init[\"status\"] is not in the range 200 to 599, inclusive, then\n    // throw a RangeError.\n    if ('status' in init && init.status !== undefined) {\n      if (!Number.isFinite(init.status)) {\n        throw new TypeError()\n      }\n\n      if (init.status < 200 || init.status > 599) {\n        throw new RangeError(\n          `Failed to construct 'Response': The status provided (${init.status}) is outside the range [200, 599].`\n        )\n      }\n    }\n\n    if ('statusText' in init && init.statusText !== undefined) {\n      // 2. If init[\"statusText\"] does not match the reason-phrase token\n      // production, then throw a TypeError.\n      // See, https://datatracker.ietf.org/doc/html/rfc7230#section-3.1.2:\n      //   reason-phrase  = *( HTAB / SP / VCHAR / obs-text )\n      if (!isValidReasonPhrase(String(init.statusText))) {\n        throw new TypeError('Invalid statusText')\n      }\n    }\n\n    // 3. Set this’s response to a new response.\n    this[kState] = makeResponse({})\n\n    // 4. Set this’s headers to a new Headers object with this’s relevant\n    // Realm, whose header list is this’s response’s header list and guard\n    // is \"response\".\n    this[kHeaders] = new Headers()\n    this[kHeaders][kGuard] = 'response'\n    this[kHeaders][kHeadersList] = this[kState].headersList\n    this[kHeaders][kRealm] = this[kRealm]\n\n    // 5. Set this’s response’s status to init[\"status\"].\n    if ('status' in init && init.status !== undefined) {\n      this[kState].status = init.status\n    }\n\n    // 6. Set this’s response’s status message to init[\"statusText\"].\n    if ('statusText' in init && init.statusText !== undefined) {\n      this[kState].statusText = String(init.statusText)\n    }\n\n    // 7. If init[\"headers\"] exists, then fill this’s headers with init[\"headers\"].\n    if ('headers' in init) {\n      fill(this[kState].headersList, init.headers)\n    }\n\n    // 8. If body is non-null, then:\n    if (body != null) {\n      // 1. If init[\"status\"] is a null body status, then throw a TypeError.\n      if (nullBodyStatus.includes(init.status)) {\n        throw new TypeError('Response with null body status cannot have body')\n      }\n\n      // 2. Let Content-Type be null.\n      // 3. Set this’s response’s body and Content-Type to the result of\n      // extracting body.\n      const [extractedBody, contentType] = extractBody(body)\n      this[kState].body = extractedBody\n\n      // 4. If Content-Type is non-null and this’s response’s header list does\n      // not contain `Content-Type`, then append `Content-Type`/Content-Type\n      // to this’s response’s header list.\n      if (contentType && !this.headers.has('content-type')) {\n        this.headers.set('content-type', contentType)\n      }\n    }\n  }\n\n  get [Symbol.toStringTag] () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    return this.constructor.name\n  }\n\n  // Returns response’s type, e.g., \"cors\".\n  get type () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The type getter steps are to return this’s response’s type.\n    return this[kState].type\n  }\n\n  // Returns response’s URL, if it has one; otherwise the empty string.\n  get url () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The url getter steps are to return the empty string if this’s\n    // response’s URL is null; otherwise this’s response’s URL,\n    // serialized with exclude fragment set to true.\n    let url = responseURL(this[kState])\n\n    if (url == null) {\n      return ''\n    }\n\n    if (url.hash) {\n      url = new URL(url)\n      url.hash = ''\n    }\n\n    return url.toString()\n  }\n\n  // Returns whether response was obtained through a redirect.\n  get redirected () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The redirected getter steps are to return true if this’s response’s URL\n    // list has more than one item; otherwise false.\n    return this[kState].urlList.length > 1\n  }\n\n  // Returns response’s status.\n  get status () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The status getter steps are to return this’s response’s status.\n    return this[kState].status\n  }\n\n  // Returns whether response’s status is an ok status.\n  get ok () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The ok getter steps are to return true if this’s response’s status is an\n    // ok status; otherwise false.\n    return this[kState].status >= 200 && this[kState].status <= 299\n  }\n\n  // Returns response’s status message.\n  get statusText () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The statusText getter steps are to return this’s response’s status\n    // message.\n    return this[kState].statusText\n  }\n\n  // Returns response’s headers as Headers.\n  get headers () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // The headers getter steps are to return this’s headers.\n    return this[kHeaders]\n  }\n\n  // Returns a clone of response.\n  clone () {\n    if (!(this instanceof Response)) {\n      throw new TypeError('Illegal invocation')\n    }\n\n    // 1. If this is unusable, then throw a TypeError.\n    if (this.bodyUsed || (this.body && this.body.locked)) {\n      throw new TypeError()\n    }\n\n    // 2. Let clonedResponse be the result of cloning this’s response.\n    const clonedResponse = cloneResponse(this[kState])\n\n    // 3. Return the result of creating a Response object, given\n    // clonedResponse, this’s headers’s guard, and this’s relevant Realm.\n    const clonedResponseObject = new Response()\n    clonedResponseObject[kState] = clonedResponse\n    clonedResponseObject[kRealm] = this[kRealm]\n    clonedResponseObject[kHeaders][kHeadersList] = clonedResponse.headersList\n    clonedResponseObject[kHeaders][kGuard] = this[kHeaders][kGuard]\n    clonedResponseObject[kHeaders][kRealm] = this[kHeaders][kRealm]\n\n    return clonedResponseObject\n  }\n}\nmixinBody(Response.prototype)\n\nObject.defineProperties(Response.prototype, {\n  type: kEnumerableProperty,\n  url: kEnumerableProperty,\n  status: kEnumerableProperty,\n  ok: kEnumerableProperty,\n  redirected: kEnumerableProperty,\n  statusText: kEnumerableProperty,\n  headers: kEnumerableProperty,\n  clone: kEnumerableProperty\n})\n\n// https://fetch.spec.whatwg.org/#concept-response-clone\nfunction cloneResponse (response) {\n  // To clone a response response, run these steps:\n\n  // 1. If response is a filtered response, then return a new identical\n  // filtered response whose internal response is a clone of response’s\n  // internal response.\n  if (response.internalResponse) {\n    return filterResponse(\n      cloneResponse(response.internalResponse),\n      response.type\n    )\n  }\n\n  // 2. Let newResponse be a copy of response, except for its body.\n  const newResponse = makeResponse({ ...response, body: null })\n\n  // 3. If response’s body is non-null, then set newResponse’s body to the\n  // result of cloning response’s body.\n  if (response.body != null) {\n    newResponse.body = cloneBody(response.body)\n  }\n\n  // 4. Return newResponse.\n  return newResponse\n}\n\nfunction makeResponse (init) {\n  return {\n    internalResponse: null,\n    aborted: false,\n    rangeRequested: false,\n    timingAllowPassed: false,\n    type: 'default',\n    status: 200,\n    timingInfo: null,\n    cacheState: '',\n    statusText: '',\n    ...init,\n    headersList: init.headersList\n      ? new HeadersList(...init.headersList)\n      : new HeadersList(),\n    urlList: init.urlList ? [...init.urlList] : []\n  }\n}\n\nfunction makeNetworkError (reason) {\n  return makeResponse({\n    type: 'error',\n    status: 0,\n    error:\n      reason instanceof Error\n        ? reason\n        : new Error(reason ? String(reason) : reason),\n    aborted: reason && reason.name === 'AbortError'\n  })\n}\n\n// https://fetch.spec.whatwg.org/#concept-filtered-response\nfunction filterResponse (response, type) {\n  // Set response to the following filtered response with response as its\n  // internal response, depending on request’s response tainting:\n  if (type === 'basic') {\n    // A basic filtered response is a filtered response whose type is \"basic\"\n    // and header list excludes any headers in internal response’s header list\n    // whose name is a forbidden response-header name.\n\n    const headers = []\n    for (let n = 0; n < response.headersList.length; n += 2) {\n      if (!forbiddenResponseHeaderNames.includes(response.headersList[n])) {\n        headers.push(response.headersList[n + 0], response.headersList[n + 1])\n      }\n    }\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      headersList: new HeadersList(...headers),\n      type: 'basic'\n    })\n  } else if (type === 'cors') {\n    // A CORS filtered response is a filtered response whose type is \"cors\"\n    // and header list excludes any headers in internal response’s header\n    // list whose name is not a CORS-safelisted response-header name, given\n    // internal response’s CORS-exposed header-name list.\n\n    // TODO: This is not correct...\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'cors'\n    })\n  } else if (type === 'opaque') {\n    // An opaque filtered response is a filtered response whose type is\n    // \"opaque\", URL list is the empty list, status is 0, status message\n    // is the empty byte sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaque',\n      urlList: [],\n      status: 0,\n      statusText: '',\n      body: null\n    })\n  } else if (type === 'opaqueredirect') {\n    // An opaque-redirect filtered response is a filtered response whose type\n    // is \"opaqueredirect\", status is 0, status message is the empty byte\n    // sequence, header list is empty, and body is null.\n\n    return makeResponse({\n      ...response,\n      internalResponse: response,\n      type: 'opaqueredirect',\n      status: 0,\n      statusText: '',\n      headersList: new HeadersList(),\n      body: null\n    })\n  } else {\n    assert(false)\n  }\n}\n\nmodule.exports = { makeNetworkError, makeResponse, filterResponse, Response }\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}